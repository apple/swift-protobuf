// Sources/SwiftProtobufPluginLibrary/CodeGenerator.swift
//
// Copyright (c) 2014 - 2023 Apple Inc. and the project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See LICENSE.txt for license information:
// https://github.com/apple/swift-protobuf/blob/main/LICENSE.txt
//
// -----------------------------------------------------------------------------
///
/// This provides the basic interface for writing a CodeGenerator.
///
// -----------------------------------------------------------------------------

import Foundation

/// A protocol that generator should conform to then get easy support for
/// being a protocol buffer compiler pluign.
public protocol CodeGenerator {
  /// Generates code for the given proto files.
  ///
  /// - Parameters:
  ///   - parameter: The parameter (or paramenters) passed for the generator.
  ///       This is for parameters specific to this generator,
  ///       `parse(parameter:)` (below) can be used to split back out
  ///       multiple parameters into the combined for the protocol buffer
  ///       compiler uses.
  ///   - protoCompilerContext: Context information about the protocol buffer
  ///       compiler being used.
  ///   - generatorOutputs: A object that can be used to send back the
  ///       generated outputs.
  ///
  /// - Throws: Can throw any `Error` to fail generate. `String(describing:)`
  ///       will be called on the error to provide the error string reported
  ///       to the user attempting to generate sources.
  func generate(
    files: [FileDescriptor],
    parameter: CodeGeneratorParameter,
    protoCompilerContext: ProtoCompilerContext,
    generatorOutputs: GeneratorOutputs) throws

  /// The list of features this CodeGenerator support to be reported back to
  /// the protocol buffer compiler.
  var supportedFeatures: [Google_Protobuf_Compiler_CodeGeneratorResponse.Feature] { get }
}

/// Uses the given `Google_Protobuf_Compiler_CodeGeneratorRequest` and
/// `CodeGenerator` to get code generated and create the
/// `Google_Protobuf_Compiler_CodeGeneratorResponse`. If there is a failure,
/// the failure will be used in the response to be returned to the protocol
/// buffer compiler to then be reported.
///
/// - Parameters:
///   - request: The request proto as generated by the protocol buffer compiler.
///   - geneator: The `CodeGenerator` to use for generation.
///
/// - Returns a filled out response with the success or failure of the
///    generation.
public func generateCode(
  request: Google_Protobuf_Compiler_CodeGeneratorRequest,
  generator: CodeGenerator
) -> Google_Protobuf_Compiler_CodeGeneratorResponse {
  // TODO: This will need update to support editions and language specific features.

  let descriptorSet = DescriptorSet(protos: request.protoFile)

  var files = [FileDescriptor]()
  for name in request.fileToGenerate {
    guard let fileDescriptor = descriptorSet.fileDescriptor(named: name) else {
      return Google_Protobuf_Compiler_CodeGeneratorResponse(
        error:
          "protoc asked plugin to generate a file but did not provide a descriptor for the file: \(name)"
      )
    }
    files.append(fileDescriptor)
  }

  let context = InternalProtoCompilerContext(request: request)
  let outputs = InternalGeneratorOutputs()
  let parameter = InternalCodeGeneratorParameter(request.parameter)

  do {
    try generator.generate(
      files: files, parameter: parameter, protoCompilerContext: context,
      generatorOutputs: outputs)
  } catch let e {
    return Google_Protobuf_Compiler_CodeGeneratorResponse(error: String(describing: e))
  }

  return Google_Protobuf_Compiler_CodeGeneratorResponse(
    files: outputs.files, supportedFeatures: generator.supportedFeatures)
}

// MARK: Internal supporting types

/// Internal implementation of `CodeGeneratorParameter` for
/// `generateCode(request:generator:)`
struct InternalCodeGeneratorParameter: CodeGeneratorParameter {
  let parameter: String

  init(_ parameter: String) {
    self.parameter = parameter
  }

  var parsedPairs: [(key: String, value: String)] {
    guard !parameter.isEmpty else {
      return []
    }
    let parts = parameter.components(separatedBy: ",")
    return parts.map { s -> (key: String, value: String) in
      guard let index = s.range(of: "=")?.lowerBound else {
        // Key only, no value ("baz" in example).
        return (trimWhitespace(s), "")
      }
      return (
        key: trimWhitespace(s[..<index]),
        value: trimWhitespace(s[s.index(after: index)...])
      )
    }
  }
}

/// Internal implementation of `ProtoCompilerContext` for
/// `generateCode(request:generator:)`
private struct InternalProtoCompilerContext: ProtoCompilerContext {
  let version: Google_Protobuf_Compiler_Version?

  init(request: Google_Protobuf_Compiler_CodeGeneratorRequest) {
    self.version = request.hasCompilerVersion ? request.compilerVersion : nil
  }
}

/// Internal implementation of `GeneratorOutputs` for
/// `generateCode(request:generator:)`
private final class InternalGeneratorOutputs: GeneratorOutputs {

  enum OutputError: Error, CustomStringConvertible {
    /// Attempt to add two files with the same name.
    case duplicateName(String)

    var description: String {
      switch self {
      case .duplicateName(let name):
        return "Generator tried to generate two files named \(name)."
      }
    }
  }

  var files: [Google_Protobuf_Compiler_CodeGeneratorResponse.File] = []

  func add(fileName: String, contents: String) throws {
    guard !files.contains(where: { $0.name == fileName }) else {
      throw OutputError.duplicateName(fileName)
    }
    files.append(
      Google_Protobuf_Compiler_CodeGeneratorResponse.File(
        name: fileName,
        content: contents))
  }
}
