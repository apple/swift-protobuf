// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/protobuf/util/json_format_proto3.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
//
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file or at
// https://developers.google.com/open-source/licenses/bsd

// LINT: LEGACY_NAMES

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Proto3_EnumType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case foo // = 0
  case bar // = 1
  case tlsv12 // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .foo
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .foo
    case 1: self = .bar
    case 2: self = .tlsv12
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .foo: return 0
    case .bar: return 1
    case .tlsv12: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Proto3_EnumType] = [
    .foo,
    .bar,
    .tlsv12,
  ]

}

struct Proto3_MessageType: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto3_TestMessage: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var boolValue: Bool {
    get {_storage._boolValue}
    set {_uniqueStorage()._boolValue = newValue}
  }

  var int32Value: Int32 {
    get {_storage._int32Value}
    set {_uniqueStorage()._int32Value = newValue}
  }

  var int64Value: Int64 {
    get {_storage._int64Value}
    set {_uniqueStorage()._int64Value = newValue}
  }

  var uint32Value: UInt32 {
    get {_storage._uint32Value}
    set {_uniqueStorage()._uint32Value = newValue}
  }

  var uint64Value: UInt64 {
    get {_storage._uint64Value}
    set {_uniqueStorage()._uint64Value = newValue}
  }

  var floatValue: Float {
    get {_storage._floatValue}
    set {_uniqueStorage()._floatValue = newValue}
  }

  var doubleValue: Double {
    get {_storage._doubleValue}
    set {_uniqueStorage()._doubleValue = newValue}
  }

  var stringValue: String {
    get {_storage._stringValue}
    set {_uniqueStorage()._stringValue = newValue}
  }

  var bytesValue: Data {
    get {_storage._bytesValue}
    set {_uniqueStorage()._bytesValue = newValue}
  }

  var enumValue: Proto3_EnumType {
    get {_storage._enumValue}
    set {_uniqueStorage()._enumValue = newValue}
  }

  var messageValue: Proto3_MessageType {
    get {_storage._messageValue ?? Proto3_MessageType()}
    set {_uniqueStorage()._messageValue = newValue}
  }
  /// Returns true if `messageValue` has been explicitly set.
  var hasMessageValue: Bool {_storage._messageValue != nil}
  /// Clears the value of `messageValue`. Subsequent reads from it will return its default value.
  mutating func clearMessageValue() {_uniqueStorage()._messageValue = nil}

  var repeatedBoolValue: [Bool] {
    get {_storage._repeatedBoolValue}
    set {_uniqueStorage()._repeatedBoolValue = newValue}
  }

  var repeatedInt32Value: [Int32] {
    get {_storage._repeatedInt32Value}
    set {_uniqueStorage()._repeatedInt32Value = newValue}
  }

  var repeatedInt64Value: [Int64] {
    get {_storage._repeatedInt64Value}
    set {_uniqueStorage()._repeatedInt64Value = newValue}
  }

  var repeatedUint32Value: [UInt32] {
    get {_storage._repeatedUint32Value}
    set {_uniqueStorage()._repeatedUint32Value = newValue}
  }

  var repeatedUint64Value: [UInt64] {
    get {_storage._repeatedUint64Value}
    set {_uniqueStorage()._repeatedUint64Value = newValue}
  }

  var repeatedFloatValue: [Float] {
    get {_storage._repeatedFloatValue}
    set {_uniqueStorage()._repeatedFloatValue = newValue}
  }

  var repeatedDoubleValue: [Double] {
    get {_storage._repeatedDoubleValue}
    set {_uniqueStorage()._repeatedDoubleValue = newValue}
  }

  var repeatedStringValue: [String] {
    get {_storage._repeatedStringValue}
    set {_uniqueStorage()._repeatedStringValue = newValue}
  }

  var repeatedBytesValue: [Data] {
    get {_storage._repeatedBytesValue}
    set {_uniqueStorage()._repeatedBytesValue = newValue}
  }

  var repeatedEnumValue: [Proto3_EnumType] {
    get {_storage._repeatedEnumValue}
    set {_uniqueStorage()._repeatedEnumValue = newValue}
  }

  var repeatedMessageValue: [Proto3_MessageType] {
    get {_storage._repeatedMessageValue}
    set {_uniqueStorage()._repeatedMessageValue = newValue}
  }

  var optionalBoolValue: Bool {
    get {_storage._optionalBoolValue ?? false}
    set {_uniqueStorage()._optionalBoolValue = newValue}
  }
  /// Returns true if `optionalBoolValue` has been explicitly set.
  var hasOptionalBoolValue: Bool {_storage._optionalBoolValue != nil}
  /// Clears the value of `optionalBoolValue`. Subsequent reads from it will return its default value.
  mutating func clearOptionalBoolValue() {_uniqueStorage()._optionalBoolValue = nil}

  var optionalInt32Value: Int32 {
    get {_storage._optionalInt32Value ?? 0}
    set {_uniqueStorage()._optionalInt32Value = newValue}
  }
  /// Returns true if `optionalInt32Value` has been explicitly set.
  var hasOptionalInt32Value: Bool {_storage._optionalInt32Value != nil}
  /// Clears the value of `optionalInt32Value`. Subsequent reads from it will return its default value.
  mutating func clearOptionalInt32Value() {_uniqueStorage()._optionalInt32Value = nil}

  var optionalInt64Value: Int64 {
    get {_storage._optionalInt64Value ?? 0}
    set {_uniqueStorage()._optionalInt64Value = newValue}
  }
  /// Returns true if `optionalInt64Value` has been explicitly set.
  var hasOptionalInt64Value: Bool {_storage._optionalInt64Value != nil}
  /// Clears the value of `optionalInt64Value`. Subsequent reads from it will return its default value.
  mutating func clearOptionalInt64Value() {_uniqueStorage()._optionalInt64Value = nil}

  var optionalUint32Value: UInt32 {
    get {_storage._optionalUint32Value ?? 0}
    set {_uniqueStorage()._optionalUint32Value = newValue}
  }
  /// Returns true if `optionalUint32Value` has been explicitly set.
  var hasOptionalUint32Value: Bool {_storage._optionalUint32Value != nil}
  /// Clears the value of `optionalUint32Value`. Subsequent reads from it will return its default value.
  mutating func clearOptionalUint32Value() {_uniqueStorage()._optionalUint32Value = nil}

  var optionalUint64Value: UInt64 {
    get {_storage._optionalUint64Value ?? 0}
    set {_uniqueStorage()._optionalUint64Value = newValue}
  }
  /// Returns true if `optionalUint64Value` has been explicitly set.
  var hasOptionalUint64Value: Bool {_storage._optionalUint64Value != nil}
  /// Clears the value of `optionalUint64Value`. Subsequent reads from it will return its default value.
  mutating func clearOptionalUint64Value() {_uniqueStorage()._optionalUint64Value = nil}

  var optionalFloatValue: Float {
    get {_storage._optionalFloatValue ?? 0}
    set {_uniqueStorage()._optionalFloatValue = newValue}
  }
  /// Returns true if `optionalFloatValue` has been explicitly set.
  var hasOptionalFloatValue: Bool {_storage._optionalFloatValue != nil}
  /// Clears the value of `optionalFloatValue`. Subsequent reads from it will return its default value.
  mutating func clearOptionalFloatValue() {_uniqueStorage()._optionalFloatValue = nil}

  var optionalDoubleValue: Double {
    get {_storage._optionalDoubleValue ?? 0}
    set {_uniqueStorage()._optionalDoubleValue = newValue}
  }
  /// Returns true if `optionalDoubleValue` has been explicitly set.
  var hasOptionalDoubleValue: Bool {_storage._optionalDoubleValue != nil}
  /// Clears the value of `optionalDoubleValue`. Subsequent reads from it will return its default value.
  mutating func clearOptionalDoubleValue() {_uniqueStorage()._optionalDoubleValue = nil}

  var optionalStringValue: String {
    get {_storage._optionalStringValue ?? String()}
    set {_uniqueStorage()._optionalStringValue = newValue}
  }
  /// Returns true if `optionalStringValue` has been explicitly set.
  var hasOptionalStringValue: Bool {_storage._optionalStringValue != nil}
  /// Clears the value of `optionalStringValue`. Subsequent reads from it will return its default value.
  mutating func clearOptionalStringValue() {_uniqueStorage()._optionalStringValue = nil}

  var optionalBytesValue: Data {
    get {_storage._optionalBytesValue ?? Data()}
    set {_uniqueStorage()._optionalBytesValue = newValue}
  }
  /// Returns true if `optionalBytesValue` has been explicitly set.
  var hasOptionalBytesValue: Bool {_storage._optionalBytesValue != nil}
  /// Clears the value of `optionalBytesValue`. Subsequent reads from it will return its default value.
  mutating func clearOptionalBytesValue() {_uniqueStorage()._optionalBytesValue = nil}

  var optionalEnumValue: Proto3_EnumType {
    get {_storage._optionalEnumValue ?? .foo}
    set {_uniqueStorage()._optionalEnumValue = newValue}
  }
  /// Returns true if `optionalEnumValue` has been explicitly set.
  var hasOptionalEnumValue: Bool {_storage._optionalEnumValue != nil}
  /// Clears the value of `optionalEnumValue`. Subsequent reads from it will return its default value.
  mutating func clearOptionalEnumValue() {_uniqueStorage()._optionalEnumValue = nil}

  var optionalMessageValue: Proto3_MessageType {
    get {_storage._optionalMessageValue ?? Proto3_MessageType()}
    set {_uniqueStorage()._optionalMessageValue = newValue}
  }
  /// Returns true if `optionalMessageValue` has been explicitly set.
  var hasOptionalMessageValue: Bool {_storage._optionalMessageValue != nil}
  /// Clears the value of `optionalMessageValue`. Subsequent reads from it will return its default value.
  mutating func clearOptionalMessageValue() {_uniqueStorage()._optionalMessageValue = nil}

  var nonStandardName_: Int32 {
    get {_storage._nonStandardName_}
    set {_uniqueStorage()._nonStandardName_ = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Proto3_TestOneof: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// In JSON format oneof fields behave mostly the same as optional
  /// fields except that:
  ///   1. Oneof fields have field presence information and will be
  ///      printed if it's set no matter whether it's the default value.
  ///   2. Multiple oneof fields in the same oneof cannot appear at the
  ///      same time in the input.
  var oneofValue: Proto3_TestOneof.OneOf_OneofValue? = nil

  var oneofInt32Value: Int32 {
    get {
      if case .oneofInt32Value(let v)? = oneofValue {return v}
      return 0
    }
    set {oneofValue = .oneofInt32Value(newValue)}
  }

  var oneofStringValue: String {
    get {
      if case .oneofStringValue(let v)? = oneofValue {return v}
      return String()
    }
    set {oneofValue = .oneofStringValue(newValue)}
  }

  var oneofBytesValue: Data {
    get {
      if case .oneofBytesValue(let v)? = oneofValue {return v}
      return Data()
    }
    set {oneofValue = .oneofBytesValue(newValue)}
  }

  var oneofEnumValue: Proto3_EnumType {
    get {
      if case .oneofEnumValue(let v)? = oneofValue {return v}
      return .foo
    }
    set {oneofValue = .oneofEnumValue(newValue)}
  }

  var oneofMessageValue: Proto3_MessageType {
    get {
      if case .oneofMessageValue(let v)? = oneofValue {return v}
      return Proto3_MessageType()
    }
    set {oneofValue = .oneofMessageValue(newValue)}
  }

  var oneofNullValue: SwiftProtobuf.Google_Protobuf_NullValue {
    get {
      if case .oneofNullValue(let v)? = oneofValue {return v}
      return .nullValue
    }
    set {oneofValue = .oneofNullValue(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// In JSON format oneof fields behave mostly the same as optional
  /// fields except that:
  ///   1. Oneof fields have field presence information and will be
  ///      printed if it's set no matter whether it's the default value.
  ///   2. Multiple oneof fields in the same oneof cannot appear at the
  ///      same time in the input.
  enum OneOf_OneofValue: Equatable, Sendable {
    case oneofInt32Value(Int32)
    case oneofStringValue(String)
    case oneofBytesValue(Data)
    case oneofEnumValue(Proto3_EnumType)
    case oneofMessageValue(Proto3_MessageType)
    case oneofNullValue(SwiftProtobuf.Google_Protobuf_NullValue)

  }

  init() {}
}

struct Proto3_TestMap: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var boolMap: Dictionary<Bool,Int32> = [:]

  var int32Map: Dictionary<Int32,Int32> = [:]

  var int64Map: Dictionary<Int64,Int32> = [:]

  var uint32Map: Dictionary<UInt32,Int32> = [:]

  var uint64Map: Dictionary<UInt64,Int32> = [:]

  var stringMap: Dictionary<String,Int32> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto3_TestNestedMap: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var boolMap: Dictionary<Bool,Int32> = [:]

  var int32Map: Dictionary<Int32,Int32> = [:]

  var int64Map: Dictionary<Int64,Int32> = [:]

  var uint32Map: Dictionary<UInt32,Int32> = [:]

  var uint64Map: Dictionary<UInt64,Int32> = [:]

  var stringMap: Dictionary<String,Int32> = [:]

  var mapMap: Dictionary<String,Proto3_TestNestedMap> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto3_TestStringMap: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var stringMap: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto3_TestWrapper: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var boolValue: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {_storage._boolValue ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._boolValue = newValue}
  }
  /// Returns true if `boolValue` has been explicitly set.
  var hasBoolValue: Bool {_storage._boolValue != nil}
  /// Clears the value of `boolValue`. Subsequent reads from it will return its default value.
  mutating func clearBoolValue() {_uniqueStorage()._boolValue = nil}

  var int32Value: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {_storage._int32Value ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._int32Value = newValue}
  }
  /// Returns true if `int32Value` has been explicitly set.
  var hasInt32Value: Bool {_storage._int32Value != nil}
  /// Clears the value of `int32Value`. Subsequent reads from it will return its default value.
  mutating func clearInt32Value() {_uniqueStorage()._int32Value = nil}

  var int64Value: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {_storage._int64Value ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_uniqueStorage()._int64Value = newValue}
  }
  /// Returns true if `int64Value` has been explicitly set.
  var hasInt64Value: Bool {_storage._int64Value != nil}
  /// Clears the value of `int64Value`. Subsequent reads from it will return its default value.
  mutating func clearInt64Value() {_uniqueStorage()._int64Value = nil}

  var uint32Value: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {_storage._uint32Value ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_uniqueStorage()._uint32Value = newValue}
  }
  /// Returns true if `uint32Value` has been explicitly set.
  var hasUint32Value: Bool {_storage._uint32Value != nil}
  /// Clears the value of `uint32Value`. Subsequent reads from it will return its default value.
  mutating func clearUint32Value() {_uniqueStorage()._uint32Value = nil}

  var uint64Value: SwiftProtobuf.Google_Protobuf_UInt64Value {
    get {_storage._uint64Value ?? SwiftProtobuf.Google_Protobuf_UInt64Value()}
    set {_uniqueStorage()._uint64Value = newValue}
  }
  /// Returns true if `uint64Value` has been explicitly set.
  var hasUint64Value: Bool {_storage._uint64Value != nil}
  /// Clears the value of `uint64Value`. Subsequent reads from it will return its default value.
  mutating func clearUint64Value() {_uniqueStorage()._uint64Value = nil}

  var floatValue: SwiftProtobuf.Google_Protobuf_FloatValue {
    get {_storage._floatValue ?? SwiftProtobuf.Google_Protobuf_FloatValue()}
    set {_uniqueStorage()._floatValue = newValue}
  }
  /// Returns true if `floatValue` has been explicitly set.
  var hasFloatValue: Bool {_storage._floatValue != nil}
  /// Clears the value of `floatValue`. Subsequent reads from it will return its default value.
  mutating func clearFloatValue() {_uniqueStorage()._floatValue = nil}

  var doubleValue: SwiftProtobuf.Google_Protobuf_DoubleValue {
    get {_storage._doubleValue ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
    set {_uniqueStorage()._doubleValue = newValue}
  }
  /// Returns true if `doubleValue` has been explicitly set.
  var hasDoubleValue: Bool {_storage._doubleValue != nil}
  /// Clears the value of `doubleValue`. Subsequent reads from it will return its default value.
  mutating func clearDoubleValue() {_uniqueStorage()._doubleValue = nil}

  var stringValue: SwiftProtobuf.Google_Protobuf_StringValue {
    get {_storage._stringValue ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._stringValue = newValue}
  }
  /// Returns true if `stringValue` has been explicitly set.
  var hasStringValue: Bool {_storage._stringValue != nil}
  /// Clears the value of `stringValue`. Subsequent reads from it will return its default value.
  mutating func clearStringValue() {_uniqueStorage()._stringValue = nil}

  var bytesValue: SwiftProtobuf.Google_Protobuf_BytesValue {
    get {_storage._bytesValue ?? SwiftProtobuf.Google_Protobuf_BytesValue()}
    set {_uniqueStorage()._bytesValue = newValue}
  }
  /// Returns true if `bytesValue` has been explicitly set.
  var hasBytesValue: Bool {_storage._bytesValue != nil}
  /// Clears the value of `bytesValue`. Subsequent reads from it will return its default value.
  mutating func clearBytesValue() {_uniqueStorage()._bytesValue = nil}

  var repeatedBoolValue: [SwiftProtobuf.Google_Protobuf_BoolValue] {
    get {_storage._repeatedBoolValue}
    set {_uniqueStorage()._repeatedBoolValue = newValue}
  }

  var repeatedInt32Value: [SwiftProtobuf.Google_Protobuf_Int32Value] {
    get {_storage._repeatedInt32Value}
    set {_uniqueStorage()._repeatedInt32Value = newValue}
  }

  var repeatedInt64Value: [SwiftProtobuf.Google_Protobuf_Int64Value] {
    get {_storage._repeatedInt64Value}
    set {_uniqueStorage()._repeatedInt64Value = newValue}
  }

  var repeatedUint32Value: [SwiftProtobuf.Google_Protobuf_UInt32Value] {
    get {_storage._repeatedUint32Value}
    set {_uniqueStorage()._repeatedUint32Value = newValue}
  }

  var repeatedUint64Value: [SwiftProtobuf.Google_Protobuf_UInt64Value] {
    get {_storage._repeatedUint64Value}
    set {_uniqueStorage()._repeatedUint64Value = newValue}
  }

  var repeatedFloatValue: [SwiftProtobuf.Google_Protobuf_FloatValue] {
    get {_storage._repeatedFloatValue}
    set {_uniqueStorage()._repeatedFloatValue = newValue}
  }

  var repeatedDoubleValue: [SwiftProtobuf.Google_Protobuf_DoubleValue] {
    get {_storage._repeatedDoubleValue}
    set {_uniqueStorage()._repeatedDoubleValue = newValue}
  }

  var repeatedStringValue: [SwiftProtobuf.Google_Protobuf_StringValue] {
    get {_storage._repeatedStringValue}
    set {_uniqueStorage()._repeatedStringValue = newValue}
  }

  var repeatedBytesValue: [SwiftProtobuf.Google_Protobuf_BytesValue] {
    get {_storage._repeatedBytesValue}
    set {_uniqueStorage()._repeatedBytesValue = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Proto3_TestTimestamp: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {_value ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var repeatedValue: [SwiftProtobuf.Google_Protobuf_Timestamp] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _value: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Proto3_TestDuration: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: SwiftProtobuf.Google_Protobuf_Duration {
    get {_value ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var repeatedValue: [SwiftProtobuf.Google_Protobuf_Duration] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _value: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

struct Proto3_TestFieldMask: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {_value ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _value: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

struct Proto3_TestStruct: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: SwiftProtobuf.Google_Protobuf_Struct {
    get {_value ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var repeatedValue: [SwiftProtobuf.Google_Protobuf_Struct] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _value: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

struct Proto3_TestAny: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: SwiftProtobuf.Google_Protobuf_Any {
    get {_value ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var repeatedValue: [SwiftProtobuf.Google_Protobuf_Any] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _value: SwiftProtobuf.Google_Protobuf_Any? = nil
}

struct Proto3_TestValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: SwiftProtobuf.Google_Protobuf_Value {
    get {_value ?? SwiftProtobuf.Google_Protobuf_Value()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var repeatedValue: [SwiftProtobuf.Google_Protobuf_Value] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _value: SwiftProtobuf.Google_Protobuf_Value? = nil
}

struct Proto3_TestListValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: SwiftProtobuf.Google_Protobuf_ListValue {
    get {_value ?? SwiftProtobuf.Google_Protobuf_ListValue()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var repeatedValue: [SwiftProtobuf.Google_Protobuf_ListValue] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _value: SwiftProtobuf.Google_Protobuf_ListValue? = nil
}

struct Proto3_TestBoolValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var boolValue: Bool = false

  var boolMap: Dictionary<Bool,Int32> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto3_TestNullValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nullValue: SwiftProtobuf.Google_Protobuf_NullValue = .nullValue

  var repeatedNullValue: [SwiftProtobuf.Google_Protobuf_NullValue] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto3_TestCustomJsonName: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto3_TestEvilJson: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var regularValue: Int32 = 0

  var script: Int32 = 0

  var quotes: Int32 = 0

  var scriptAndQuotes: Int32 = 0

  var emptyString: Int32 = 0

  var backslash: Int32 = 0

  var lowCodepoint: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto3_TestExtensions: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var extensions: Proto2Unittest_TestAllExtensions {
    get {_extensions ?? Proto2Unittest_TestAllExtensions()}
    set {_extensions = newValue}
  }
  /// Returns true if `extensions` has been explicitly set.
  var hasExtensions: Bool {self._extensions != nil}
  /// Clears the value of `extensions`. Subsequent reads from it will return its default value.
  mutating func clearExtensions() {self._extensions = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _extensions: Proto2Unittest_TestAllExtensions? = nil
}

struct Proto3_TestEnumValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var enumValue1: Proto3_EnumType = .foo

  var enumValue2: Proto3_EnumType = .foo

  var enumValue3: Proto3_EnumType = .foo

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto3_MapsTestCases: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var emptyMap: Proto3_EmptyMap {
    get {_emptyMap ?? Proto3_EmptyMap()}
    set {_emptyMap = newValue}
  }
  /// Returns true if `emptyMap` has been explicitly set.
  var hasEmptyMap: Bool {self._emptyMap != nil}
  /// Clears the value of `emptyMap`. Subsequent reads from it will return its default value.
  mutating func clearEmptyMap() {self._emptyMap = nil}

  var stringToInt: Proto3_StringtoInt {
    get {_stringToInt ?? Proto3_StringtoInt()}
    set {_stringToInt = newValue}
  }
  /// Returns true if `stringToInt` has been explicitly set.
  var hasStringToInt: Bool {self._stringToInt != nil}
  /// Clears the value of `stringToInt`. Subsequent reads from it will return its default value.
  mutating func clearStringToInt() {self._stringToInt = nil}

  var intToString: Proto3_IntToString {
    get {_intToString ?? Proto3_IntToString()}
    set {_intToString = newValue}
  }
  /// Returns true if `intToString` has been explicitly set.
  var hasIntToString: Bool {self._intToString != nil}
  /// Clears the value of `intToString`. Subsequent reads from it will return its default value.
  mutating func clearIntToString() {self._intToString = nil}

  var mixed1: Proto3_Mixed1 {
    get {_mixed1 ?? Proto3_Mixed1()}
    set {_mixed1 = newValue}
  }
  /// Returns true if `mixed1` has been explicitly set.
  var hasMixed1: Bool {self._mixed1 != nil}
  /// Clears the value of `mixed1`. Subsequent reads from it will return its default value.
  mutating func clearMixed1() {self._mixed1 = nil}

  var mixed2: Proto3_Mixed2 {
    get {_mixed2 ?? Proto3_Mixed2()}
    set {_mixed2 = newValue}
  }
  /// Returns true if `mixed2` has been explicitly set.
  var hasMixed2: Bool {self._mixed2 != nil}
  /// Clears the value of `mixed2`. Subsequent reads from it will return its default value.
  mutating func clearMixed2() {self._mixed2 = nil}

  var mapOfObjects: Proto3_MapOfObjects {
    get {_mapOfObjects ?? Proto3_MapOfObjects()}
    set {_mapOfObjects = newValue}
  }
  /// Returns true if `mapOfObjects` has been explicitly set.
  var hasMapOfObjects: Bool {self._mapOfObjects != nil}
  /// Clears the value of `mapOfObjects`. Subsequent reads from it will return its default value.
  mutating func clearMapOfObjects() {self._mapOfObjects = nil}

  /// Empty key tests
  var emptyKeyStringToInt1: Proto3_StringtoInt {
    get {_emptyKeyStringToInt1 ?? Proto3_StringtoInt()}
    set {_emptyKeyStringToInt1 = newValue}
  }
  /// Returns true if `emptyKeyStringToInt1` has been explicitly set.
  var hasEmptyKeyStringToInt1: Bool {self._emptyKeyStringToInt1 != nil}
  /// Clears the value of `emptyKeyStringToInt1`. Subsequent reads from it will return its default value.
  mutating func clearEmptyKeyStringToInt1() {self._emptyKeyStringToInt1 = nil}

  var emptyKeyStringToInt2: Proto3_StringtoInt {
    get {_emptyKeyStringToInt2 ?? Proto3_StringtoInt()}
    set {_emptyKeyStringToInt2 = newValue}
  }
  /// Returns true if `emptyKeyStringToInt2` has been explicitly set.
  var hasEmptyKeyStringToInt2: Bool {self._emptyKeyStringToInt2 != nil}
  /// Clears the value of `emptyKeyStringToInt2`. Subsequent reads from it will return its default value.
  mutating func clearEmptyKeyStringToInt2() {self._emptyKeyStringToInt2 = nil}

  var emptyKeyStringToInt3: Proto3_StringtoInt {
    get {_emptyKeyStringToInt3 ?? Proto3_StringtoInt()}
    set {_emptyKeyStringToInt3 = newValue}
  }
  /// Returns true if `emptyKeyStringToInt3` has been explicitly set.
  var hasEmptyKeyStringToInt3: Bool {self._emptyKeyStringToInt3 != nil}
  /// Clears the value of `emptyKeyStringToInt3`. Subsequent reads from it will return its default value.
  mutating func clearEmptyKeyStringToInt3() {self._emptyKeyStringToInt3 = nil}

  var emptyKeyBoolToString: Proto3_BoolToString {
    get {_emptyKeyBoolToString ?? Proto3_BoolToString()}
    set {_emptyKeyBoolToString = newValue}
  }
  /// Returns true if `emptyKeyBoolToString` has been explicitly set.
  var hasEmptyKeyBoolToString: Bool {self._emptyKeyBoolToString != nil}
  /// Clears the value of `emptyKeyBoolToString`. Subsequent reads from it will return its default value.
  mutating func clearEmptyKeyBoolToString() {self._emptyKeyBoolToString = nil}

  var emptyKeyIntToString: Proto3_IntToString {
    get {_emptyKeyIntToString ?? Proto3_IntToString()}
    set {_emptyKeyIntToString = newValue}
  }
  /// Returns true if `emptyKeyIntToString` has been explicitly set.
  var hasEmptyKeyIntToString: Bool {self._emptyKeyIntToString != nil}
  /// Clears the value of `emptyKeyIntToString`. Subsequent reads from it will return its default value.
  mutating func clearEmptyKeyIntToString() {self._emptyKeyIntToString = nil}

  var emptyKeyMixed: Proto3_Mixed1 {
    get {_emptyKeyMixed ?? Proto3_Mixed1()}
    set {_emptyKeyMixed = newValue}
  }
  /// Returns true if `emptyKeyMixed` has been explicitly set.
  var hasEmptyKeyMixed: Bool {self._emptyKeyMixed != nil}
  /// Clears the value of `emptyKeyMixed`. Subsequent reads from it will return its default value.
  mutating func clearEmptyKeyMixed() {self._emptyKeyMixed = nil}

  var emptyKeyMapObjects: Proto3_MapOfObjects {
    get {_emptyKeyMapObjects ?? Proto3_MapOfObjects()}
    set {_emptyKeyMapObjects = newValue}
  }
  /// Returns true if `emptyKeyMapObjects` has been explicitly set.
  var hasEmptyKeyMapObjects: Bool {self._emptyKeyMapObjects != nil}
  /// Clears the value of `emptyKeyMapObjects`. Subsequent reads from it will return its default value.
  mutating func clearEmptyKeyMapObjects() {self._emptyKeyMapObjects = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _emptyMap: Proto3_EmptyMap? = nil
  fileprivate var _stringToInt: Proto3_StringtoInt? = nil
  fileprivate var _intToString: Proto3_IntToString? = nil
  fileprivate var _mixed1: Proto3_Mixed1? = nil
  fileprivate var _mixed2: Proto3_Mixed2? = nil
  fileprivate var _mapOfObjects: Proto3_MapOfObjects? = nil
  fileprivate var _emptyKeyStringToInt1: Proto3_StringtoInt? = nil
  fileprivate var _emptyKeyStringToInt2: Proto3_StringtoInt? = nil
  fileprivate var _emptyKeyStringToInt3: Proto3_StringtoInt? = nil
  fileprivate var _emptyKeyBoolToString: Proto3_BoolToString? = nil
  fileprivate var _emptyKeyIntToString: Proto3_IntToString? = nil
  fileprivate var _emptyKeyMixed: Proto3_Mixed1? = nil
  fileprivate var _emptyKeyMapObjects: Proto3_MapOfObjects? = nil
}

struct Proto3_EmptyMap: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var map: Dictionary<Int32,Int32> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto3_StringtoInt: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var map: Dictionary<String,Int32> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto3_IntToString: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var map: Dictionary<Int32,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto3_BoolToString: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var map: Dictionary<Bool,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto3_Mixed1: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var msg: String = String()

  var map: Dictionary<String,Float> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto3_Mixed2: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var map: Dictionary<Int32,Bool> = [:]

  var ee: Proto3_Mixed2.E = .e0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum E: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case e0 // = 0
    case e1 // = 1
    case e2 // = 2
    case e3 // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .e0
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .e0
      case 1: self = .e1
      case 2: self = .e2
      case 3: self = .e3
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .e0: return 0
      case .e1: return 1
      case .e2: return 2
      case .e3: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Proto3_Mixed2.E] = [
      .e0,
      .e1,
      .e2,
      .e3,
    ]

  }

  init() {}
}

struct Proto3_MapOfObjects: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var map: Dictionary<String,Proto3_MapOfObjects.M> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct M: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var innerText: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Proto3_MapOfEnums: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var map: Dictionary<String,Proto3_EnumType> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto3_MapIn: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var other: String = String()

  var things: [String] = []

  var mapInput: Dictionary<String,String> = [:]

  var mapAny: Dictionary<String,SwiftProtobuf.Google_Protobuf_Any> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto3_MapOut: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var map1: Dictionary<String,Proto3_MapM> = [:]

  var map2: Dictionary<String,Proto3_MapOut> = [:]

  var map3: Dictionary<Int32,String> = [:]

  var map4: Dictionary<Bool,String> = [:]

  var bar: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A message with exactly the same wire representation as MapOut, but using
/// repeated message fields instead of map fields. We use this message to test
/// the wire-format compatibility of the JSON transcoder (e.g., whether it
/// handles missing keys correctly).
struct Proto3_MapOutWireFormat: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var map1: [Proto3_MapOutWireFormat.Map1Entry] = []

  var map2: [Proto3_MapOutWireFormat.Map2Entry] = []

  var map3: [Proto3_MapOutWireFormat.Map3Entry] = []

  var map4: [Proto3_MapOutWireFormat.Map4Entry] = []

  var bar: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Map1Entry: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var key: String = String()

    var value: Proto3_MapM {
      get {_value ?? Proto3_MapM()}
      set {_value = newValue}
    }
    /// Returns true if `value` has been explicitly set.
    var hasValue: Bool {self._value != nil}
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    mutating func clearValue() {self._value = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _value: Proto3_MapM? = nil
  }

  struct Map2Entry: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var key: String = String()

    var value: Proto3_MapOut {
      get {_value ?? Proto3_MapOut()}
      set {_value = newValue}
    }
    /// Returns true if `value` has been explicitly set.
    var hasValue: Bool {self._value != nil}
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    mutating func clearValue() {self._value = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _value: Proto3_MapOut? = nil
  }

  struct Map3Entry: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var key: Int32 = 0

    var value: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Map4Entry: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var key: Bool = false

    var value: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Proto3_MapM: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var foo: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto3"

extension Proto3_EnumType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0FOO\0\u{1}BAR\0\u{1}TLSv1_2\0")
}

extension Proto3_MessageType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MessageType"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}value\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularInt32Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto3_MessageType, rhs: Proto3_MessageType) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto3_TestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TestMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}bool_value\0\u{3}int32_value\0\u{3}int64_value\0\u{3}uint32_value\0\u{3}uint64_value\0\u{3}float_value\0\u{3}double_value\0\u{3}string_value\0\u{3}bytes_value\0\u{3}enum_value\0\u{3}message_value\0\u{4}\u{a}repeated_bool_value\0\u{3}repeated_int32_value\0\u{3}repeated_int64_value\0\u{3}repeated_uint32_value\0\u{3}repeated_uint64_value\0\u{3}repeated_float_value\0\u{3}repeated_double_value\0\u{3}repeated_string_value\0\u{3}repeated_bytes_value\0\u{3}repeated_enum_value\0\u{3}repeated_message_value\0\u{4}\u{a}optional_bool_value\0\u{3}optional_int32_value\0\u{3}optional_int64_value\0\u{3}optional_uint32_value\0\u{3}optional_uint64_value\0\u{3}optional_float_value\0\u{3}optional_double_value\0\u{3}optional_string_value\0\u{3}optional_bytes_value\0\u{3}optional_enum_value\0\u{3}optional_message_value\0\u{3}_nonStandard_name_\0")

  fileprivate class _StorageClass {
    var _boolValue: Bool = false
    var _int32Value: Int32 = 0
    var _int64Value: Int64 = 0
    var _uint32Value: UInt32 = 0
    var _uint64Value: UInt64 = 0
    var _floatValue: Float = 0
    var _doubleValue: Double = 0
    var _stringValue: String = String()
    var _bytesValue: Data = Data()
    var _enumValue: Proto3_EnumType = .foo
    var _messageValue: Proto3_MessageType? = nil
    var _repeatedBoolValue: [Bool] = []
    var _repeatedInt32Value: [Int32] = []
    var _repeatedInt64Value: [Int64] = []
    var _repeatedUint32Value: [UInt32] = []
    var _repeatedUint64Value: [UInt64] = []
    var _repeatedFloatValue: [Float] = []
    var _repeatedDoubleValue: [Double] = []
    var _repeatedStringValue: [String] = []
    var _repeatedBytesValue: [Data] = []
    var _repeatedEnumValue: [Proto3_EnumType] = []
    var _repeatedMessageValue: [Proto3_MessageType] = []
    var _optionalBoolValue: Bool? = nil
    var _optionalInt32Value: Int32? = nil
    var _optionalInt64Value: Int64? = nil
    var _optionalUint32Value: UInt32? = nil
    var _optionalUint64Value: UInt64? = nil
    var _optionalFloatValue: Float? = nil
    var _optionalDoubleValue: Double? = nil
    var _optionalStringValue: String? = nil
    var _optionalBytesValue: Data? = nil
    var _optionalEnumValue: Proto3_EnumType? = nil
    var _optionalMessageValue: Proto3_MessageType? = nil
    var _nonStandardName_: Int32 = 0

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _boolValue = source._boolValue
      _int32Value = source._int32Value
      _int64Value = source._int64Value
      _uint32Value = source._uint32Value
      _uint64Value = source._uint64Value
      _floatValue = source._floatValue
      _doubleValue = source._doubleValue
      _stringValue = source._stringValue
      _bytesValue = source._bytesValue
      _enumValue = source._enumValue
      _messageValue = source._messageValue
      _repeatedBoolValue = source._repeatedBoolValue
      _repeatedInt32Value = source._repeatedInt32Value
      _repeatedInt64Value = source._repeatedInt64Value
      _repeatedUint32Value = source._repeatedUint32Value
      _repeatedUint64Value = source._repeatedUint64Value
      _repeatedFloatValue = source._repeatedFloatValue
      _repeatedDoubleValue = source._repeatedDoubleValue
      _repeatedStringValue = source._repeatedStringValue
      _repeatedBytesValue = source._repeatedBytesValue
      _repeatedEnumValue = source._repeatedEnumValue
      _repeatedMessageValue = source._repeatedMessageValue
      _optionalBoolValue = source._optionalBoolValue
      _optionalInt32Value = source._optionalInt32Value
      _optionalInt64Value = source._optionalInt64Value
      _optionalUint32Value = source._optionalUint32Value
      _optionalUint64Value = source._optionalUint64Value
      _optionalFloatValue = source._optionalFloatValue
      _optionalDoubleValue = source._optionalDoubleValue
      _optionalStringValue = source._optionalStringValue
      _optionalBytesValue = source._optionalBytesValue
      _optionalEnumValue = source._optionalEnumValue
      _optionalMessageValue = source._optionalMessageValue
      _nonStandardName_ = source._nonStandardName_
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBoolField(value: &_storage._boolValue) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._int32Value) }()
        case 3: try { try decoder.decodeSingularInt64Field(value: &_storage._int64Value) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._uint32Value) }()
        case 5: try { try decoder.decodeSingularUInt64Field(value: &_storage._uint64Value) }()
        case 6: try { try decoder.decodeSingularFloatField(value: &_storage._floatValue) }()
        case 7: try { try decoder.decodeSingularDoubleField(value: &_storage._doubleValue) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._stringValue) }()
        case 9: try { try decoder.decodeSingularBytesField(value: &_storage._bytesValue) }()
        case 10: try { try decoder.decodeSingularEnumField(value: &_storage._enumValue) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._messageValue) }()
        case 21: try { try decoder.decodeRepeatedBoolField(value: &_storage._repeatedBoolValue) }()
        case 22: try { try decoder.decodeRepeatedInt32Field(value: &_storage._repeatedInt32Value) }()
        case 23: try { try decoder.decodeRepeatedInt64Field(value: &_storage._repeatedInt64Value) }()
        case 24: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._repeatedUint32Value) }()
        case 25: try { try decoder.decodeRepeatedUInt64Field(value: &_storage._repeatedUint64Value) }()
        case 26: try { try decoder.decodeRepeatedFloatField(value: &_storage._repeatedFloatValue) }()
        case 27: try { try decoder.decodeRepeatedDoubleField(value: &_storage._repeatedDoubleValue) }()
        case 28: try { try decoder.decodeRepeatedStringField(value: &_storage._repeatedStringValue) }()
        case 29: try { try decoder.decodeRepeatedBytesField(value: &_storage._repeatedBytesValue) }()
        case 30: try { try decoder.decodeRepeatedEnumField(value: &_storage._repeatedEnumValue) }()
        case 31: try { try decoder.decodeRepeatedMessageField(value: &_storage._repeatedMessageValue) }()
        case 41: try { try decoder.decodeSingularBoolField(value: &_storage._optionalBoolValue) }()
        case 42: try { try decoder.decodeSingularInt32Field(value: &_storage._optionalInt32Value) }()
        case 43: try { try decoder.decodeSingularInt64Field(value: &_storage._optionalInt64Value) }()
        case 44: try { try decoder.decodeSingularUInt32Field(value: &_storage._optionalUint32Value) }()
        case 45: try { try decoder.decodeSingularUInt64Field(value: &_storage._optionalUint64Value) }()
        case 46: try { try decoder.decodeSingularFloatField(value: &_storage._optionalFloatValue) }()
        case 47: try { try decoder.decodeSingularDoubleField(value: &_storage._optionalDoubleValue) }()
        case 48: try { try decoder.decodeSingularStringField(value: &_storage._optionalStringValue) }()
        case 49: try { try decoder.decodeSingularBytesField(value: &_storage._optionalBytesValue) }()
        case 50: try { try decoder.decodeSingularEnumField(value: &_storage._optionalEnumValue) }()
        case 51: try { try decoder.decodeSingularMessageField(value: &_storage._optionalMessageValue) }()
        case 52: try { try decoder.decodeSingularInt32Field(value: &_storage._nonStandardName_) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._boolValue != false {
        try visitor.visitSingularBoolField(value: _storage._boolValue, fieldNumber: 1)
      }
      if _storage._int32Value != 0 {
        try visitor.visitSingularInt32Field(value: _storage._int32Value, fieldNumber: 2)
      }
      if _storage._int64Value != 0 {
        try visitor.visitSingularInt64Field(value: _storage._int64Value, fieldNumber: 3)
      }
      if _storage._uint32Value != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._uint32Value, fieldNumber: 4)
      }
      if _storage._uint64Value != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._uint64Value, fieldNumber: 5)
      }
      if _storage._floatValue.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._floatValue, fieldNumber: 6)
      }
      if _storage._doubleValue.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._doubleValue, fieldNumber: 7)
      }
      if !_storage._stringValue.isEmpty {
        try visitor.visitSingularStringField(value: _storage._stringValue, fieldNumber: 8)
      }
      if !_storage._bytesValue.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._bytesValue, fieldNumber: 9)
      }
      if _storage._enumValue != .foo {
        try visitor.visitSingularEnumField(value: _storage._enumValue, fieldNumber: 10)
      }
      try { if let v = _storage._messageValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      if !_storage._repeatedBoolValue.isEmpty {
        try visitor.visitPackedBoolField(value: _storage._repeatedBoolValue, fieldNumber: 21)
      }
      if !_storage._repeatedInt32Value.isEmpty {
        try visitor.visitPackedInt32Field(value: _storage._repeatedInt32Value, fieldNumber: 22)
      }
      if !_storage._repeatedInt64Value.isEmpty {
        try visitor.visitPackedInt64Field(value: _storage._repeatedInt64Value, fieldNumber: 23)
      }
      if !_storage._repeatedUint32Value.isEmpty {
        try visitor.visitPackedUInt32Field(value: _storage._repeatedUint32Value, fieldNumber: 24)
      }
      if !_storage._repeatedUint64Value.isEmpty {
        try visitor.visitPackedUInt64Field(value: _storage._repeatedUint64Value, fieldNumber: 25)
      }
      if !_storage._repeatedFloatValue.isEmpty {
        try visitor.visitPackedFloatField(value: _storage._repeatedFloatValue, fieldNumber: 26)
      }
      if !_storage._repeatedDoubleValue.isEmpty {
        try visitor.visitPackedDoubleField(value: _storage._repeatedDoubleValue, fieldNumber: 27)
      }
      if !_storage._repeatedStringValue.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._repeatedStringValue, fieldNumber: 28)
      }
      if !_storage._repeatedBytesValue.isEmpty {
        try visitor.visitRepeatedBytesField(value: _storage._repeatedBytesValue, fieldNumber: 29)
      }
      if !_storage._repeatedEnumValue.isEmpty {
        try visitor.visitPackedEnumField(value: _storage._repeatedEnumValue, fieldNumber: 30)
      }
      if !_storage._repeatedMessageValue.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._repeatedMessageValue, fieldNumber: 31)
      }
      try { if let v = _storage._optionalBoolValue {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 41)
      } }()
      try { if let v = _storage._optionalInt32Value {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 42)
      } }()
      try { if let v = _storage._optionalInt64Value {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 43)
      } }()
      try { if let v = _storage._optionalUint32Value {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 44)
      } }()
      try { if let v = _storage._optionalUint64Value {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 45)
      } }()
      try { if let v = _storage._optionalFloatValue {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 46)
      } }()
      try { if let v = _storage._optionalDoubleValue {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 47)
      } }()
      try { if let v = _storage._optionalStringValue {
        try visitor.visitSingularStringField(value: v, fieldNumber: 48)
      } }()
      try { if let v = _storage._optionalBytesValue {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 49)
      } }()
      try { if let v = _storage._optionalEnumValue {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 50)
      } }()
      try { if let v = _storage._optionalMessageValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
      } }()
      if _storage._nonStandardName_ != 0 {
        try visitor.visitSingularInt32Field(value: _storage._nonStandardName_, fieldNumber: 52)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto3_TestMessage, rhs: Proto3_TestMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._boolValue != rhs_storage._boolValue {return false}
        if _storage._int32Value != rhs_storage._int32Value {return false}
        if _storage._int64Value != rhs_storage._int64Value {return false}
        if _storage._uint32Value != rhs_storage._uint32Value {return false}
        if _storage._uint64Value != rhs_storage._uint64Value {return false}
        if _storage._floatValue != rhs_storage._floatValue {return false}
        if _storage._doubleValue != rhs_storage._doubleValue {return false}
        if _storage._stringValue != rhs_storage._stringValue {return false}
        if _storage._bytesValue != rhs_storage._bytesValue {return false}
        if _storage._enumValue != rhs_storage._enumValue {return false}
        if _storage._messageValue != rhs_storage._messageValue {return false}
        if _storage._repeatedBoolValue != rhs_storage._repeatedBoolValue {return false}
        if _storage._repeatedInt32Value != rhs_storage._repeatedInt32Value {return false}
        if _storage._repeatedInt64Value != rhs_storage._repeatedInt64Value {return false}
        if _storage._repeatedUint32Value != rhs_storage._repeatedUint32Value {return false}
        if _storage._repeatedUint64Value != rhs_storage._repeatedUint64Value {return false}
        if _storage._repeatedFloatValue != rhs_storage._repeatedFloatValue {return false}
        if _storage._repeatedDoubleValue != rhs_storage._repeatedDoubleValue {return false}
        if _storage._repeatedStringValue != rhs_storage._repeatedStringValue {return false}
        if _storage._repeatedBytesValue != rhs_storage._repeatedBytesValue {return false}
        if _storage._repeatedEnumValue != rhs_storage._repeatedEnumValue {return false}
        if _storage._repeatedMessageValue != rhs_storage._repeatedMessageValue {return false}
        if _storage._optionalBoolValue != rhs_storage._optionalBoolValue {return false}
        if _storage._optionalInt32Value != rhs_storage._optionalInt32Value {return false}
        if _storage._optionalInt64Value != rhs_storage._optionalInt64Value {return false}
        if _storage._optionalUint32Value != rhs_storage._optionalUint32Value {return false}
        if _storage._optionalUint64Value != rhs_storage._optionalUint64Value {return false}
        if _storage._optionalFloatValue != rhs_storage._optionalFloatValue {return false}
        if _storage._optionalDoubleValue != rhs_storage._optionalDoubleValue {return false}
        if _storage._optionalStringValue != rhs_storage._optionalStringValue {return false}
        if _storage._optionalBytesValue != rhs_storage._optionalBytesValue {return false}
        if _storage._optionalEnumValue != rhs_storage._optionalEnumValue {return false}
        if _storage._optionalMessageValue != rhs_storage._optionalMessageValue {return false}
        if _storage._nonStandardName_ != rhs_storage._nonStandardName_ {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto3_TestOneof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TestOneof"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}oneof_int32_value\0\u{3}oneof_string_value\0\u{3}oneof_bytes_value\0\u{3}oneof_enum_value\0\u{3}oneof_message_value\0\u{3}oneof_null_value\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {
          if self.oneofValue != nil {try decoder.handleConflictingOneOf()}
          self.oneofValue = .oneofInt32Value(v)
        }
      }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.oneofValue != nil {try decoder.handleConflictingOneOf()}
          self.oneofValue = .oneofStringValue(v)
        }
      }()
      case 3: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.oneofValue != nil {try decoder.handleConflictingOneOf()}
          self.oneofValue = .oneofBytesValue(v)
        }
      }()
      case 4: try {
        var v: Proto3_EnumType?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.oneofValue != nil {try decoder.handleConflictingOneOf()}
          self.oneofValue = .oneofEnumValue(v)
        }
      }()
      case 5: try {
        var v: Proto3_MessageType?
        var hadOneofValue = false
        if let current = self.oneofValue {
          hadOneofValue = true
          if case .oneofMessageValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.oneofValue = .oneofMessageValue(v)
        }
      }()
      case 6: try {
        var v: SwiftProtobuf.Google_Protobuf_NullValue?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.oneofValue != nil {try decoder.handleConflictingOneOf()}
          self.oneofValue = .oneofNullValue(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.oneofValue {
    case .oneofInt32Value?: try {
      guard case .oneofInt32Value(let v)? = self.oneofValue else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }()
    case .oneofStringValue?: try {
      guard case .oneofStringValue(let v)? = self.oneofValue else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .oneofBytesValue?: try {
      guard case .oneofBytesValue(let v)? = self.oneofValue else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }()
    case .oneofEnumValue?: try {
      guard case .oneofEnumValue(let v)? = self.oneofValue else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    }()
    case .oneofMessageValue?: try {
      guard case .oneofMessageValue(let v)? = self.oneofValue else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .oneofNullValue?: try {
      guard case .oneofNullValue(let v)? = self.oneofValue else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto3_TestOneof, rhs: Proto3_TestOneof) -> Bool {
    if lhs.oneofValue != rhs.oneofValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto3_TestMap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TestMap"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}bool_map\0\u{3}int32_map\0\u{3}int64_map\0\u{3}uint32_map\0\u{3}uint64_map\0\u{3}string_map\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufBool,SwiftProtobuf.ProtobufInt32>.self, value: &self.boolMap) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt32,SwiftProtobuf.ProtobufInt32>.self, value: &self.int32Map) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt64,SwiftProtobuf.ProtobufInt32>.self, value: &self.int64Map) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufUInt32,SwiftProtobuf.ProtobufInt32>.self, value: &self.uint32Map) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufUInt64,SwiftProtobuf.ProtobufInt32>.self, value: &self.uint64Map) }()
      case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt32>.self, value: &self.stringMap) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.boolMap.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufBool,SwiftProtobuf.ProtobufInt32>.self, value: self.boolMap, fieldNumber: 1)
    }
    if !self.int32Map.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt32,SwiftProtobuf.ProtobufInt32>.self, value: self.int32Map, fieldNumber: 2)
    }
    if !self.int64Map.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt64,SwiftProtobuf.ProtobufInt32>.self, value: self.int64Map, fieldNumber: 3)
    }
    if !self.uint32Map.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufUInt32,SwiftProtobuf.ProtobufInt32>.self, value: self.uint32Map, fieldNumber: 4)
    }
    if !self.uint64Map.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufUInt64,SwiftProtobuf.ProtobufInt32>.self, value: self.uint64Map, fieldNumber: 5)
    }
    if !self.stringMap.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt32>.self, value: self.stringMap, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto3_TestMap, rhs: Proto3_TestMap) -> Bool {
    if lhs.boolMap != rhs.boolMap {return false}
    if lhs.int32Map != rhs.int32Map {return false}
    if lhs.int64Map != rhs.int64Map {return false}
    if lhs.uint32Map != rhs.uint32Map {return false}
    if lhs.uint64Map != rhs.uint64Map {return false}
    if lhs.stringMap != rhs.stringMap {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto3_TestNestedMap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TestNestedMap"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}bool_map\0\u{3}int32_map\0\u{3}int64_map\0\u{3}uint32_map\0\u{3}uint64_map\0\u{3}string_map\0\u{3}map_map\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufBool,SwiftProtobuf.ProtobufInt32>.self, value: &self.boolMap) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt32,SwiftProtobuf.ProtobufInt32>.self, value: &self.int32Map) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt64,SwiftProtobuf.ProtobufInt32>.self, value: &self.int64Map) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufUInt32,SwiftProtobuf.ProtobufInt32>.self, value: &self.uint32Map) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufUInt64,SwiftProtobuf.ProtobufInt32>.self, value: &self.uint64Map) }()
      case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt32>.self, value: &self.stringMap) }()
      case 7: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Proto3_TestNestedMap>.self, value: &self.mapMap) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.boolMap.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufBool,SwiftProtobuf.ProtobufInt32>.self, value: self.boolMap, fieldNumber: 1)
    }
    if !self.int32Map.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt32,SwiftProtobuf.ProtobufInt32>.self, value: self.int32Map, fieldNumber: 2)
    }
    if !self.int64Map.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt64,SwiftProtobuf.ProtobufInt32>.self, value: self.int64Map, fieldNumber: 3)
    }
    if !self.uint32Map.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufUInt32,SwiftProtobuf.ProtobufInt32>.self, value: self.uint32Map, fieldNumber: 4)
    }
    if !self.uint64Map.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufUInt64,SwiftProtobuf.ProtobufInt32>.self, value: self.uint64Map, fieldNumber: 5)
    }
    if !self.stringMap.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt32>.self, value: self.stringMap, fieldNumber: 6)
    }
    if !self.mapMap.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Proto3_TestNestedMap>.self, value: self.mapMap, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto3_TestNestedMap, rhs: Proto3_TestNestedMap) -> Bool {
    if lhs.boolMap != rhs.boolMap {return false}
    if lhs.int32Map != rhs.int32Map {return false}
    if lhs.int64Map != rhs.int64Map {return false}
    if lhs.uint32Map != rhs.uint32Map {return false}
    if lhs.uint64Map != rhs.uint64Map {return false}
    if lhs.stringMap != rhs.stringMap {return false}
    if lhs.mapMap != rhs.mapMap {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto3_TestStringMap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TestStringMap"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}string_map\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.stringMap) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.stringMap.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.stringMap, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto3_TestStringMap, rhs: Proto3_TestStringMap) -> Bool {
    if lhs.stringMap != rhs.stringMap {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto3_TestWrapper: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TestWrapper"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}bool_value\0\u{3}int32_value\0\u{3}int64_value\0\u{3}uint32_value\0\u{3}uint64_value\0\u{3}float_value\0\u{3}double_value\0\u{3}string_value\0\u{3}bytes_value\0\u{4}\u{2}repeated_bool_value\0\u{3}repeated_int32_value\0\u{3}repeated_int64_value\0\u{3}repeated_uint32_value\0\u{3}repeated_uint64_value\0\u{3}repeated_float_value\0\u{3}repeated_double_value\0\u{3}repeated_string_value\0\u{3}repeated_bytes_value\0")

  fileprivate class _StorageClass {
    var _boolValue: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _int32Value: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _int64Value: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
    var _uint32Value: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
    var _uint64Value: SwiftProtobuf.Google_Protobuf_UInt64Value? = nil
    var _floatValue: SwiftProtobuf.Google_Protobuf_FloatValue? = nil
    var _doubleValue: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
    var _stringValue: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _bytesValue: SwiftProtobuf.Google_Protobuf_BytesValue? = nil
    var _repeatedBoolValue: [SwiftProtobuf.Google_Protobuf_BoolValue] = []
    var _repeatedInt32Value: [SwiftProtobuf.Google_Protobuf_Int32Value] = []
    var _repeatedInt64Value: [SwiftProtobuf.Google_Protobuf_Int64Value] = []
    var _repeatedUint32Value: [SwiftProtobuf.Google_Protobuf_UInt32Value] = []
    var _repeatedUint64Value: [SwiftProtobuf.Google_Protobuf_UInt64Value] = []
    var _repeatedFloatValue: [SwiftProtobuf.Google_Protobuf_FloatValue] = []
    var _repeatedDoubleValue: [SwiftProtobuf.Google_Protobuf_DoubleValue] = []
    var _repeatedStringValue: [SwiftProtobuf.Google_Protobuf_StringValue] = []
    var _repeatedBytesValue: [SwiftProtobuf.Google_Protobuf_BytesValue] = []

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _boolValue = source._boolValue
      _int32Value = source._int32Value
      _int64Value = source._int64Value
      _uint32Value = source._uint32Value
      _uint64Value = source._uint64Value
      _floatValue = source._floatValue
      _doubleValue = source._doubleValue
      _stringValue = source._stringValue
      _bytesValue = source._bytesValue
      _repeatedBoolValue = source._repeatedBoolValue
      _repeatedInt32Value = source._repeatedInt32Value
      _repeatedInt64Value = source._repeatedInt64Value
      _repeatedUint32Value = source._repeatedUint32Value
      _repeatedUint64Value = source._repeatedUint64Value
      _repeatedFloatValue = source._repeatedFloatValue
      _repeatedDoubleValue = source._repeatedDoubleValue
      _repeatedStringValue = source._repeatedStringValue
      _repeatedBytesValue = source._repeatedBytesValue
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._boolValue) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._int32Value) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._int64Value) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._uint32Value) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._uint64Value) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._floatValue) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._doubleValue) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._stringValue) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._bytesValue) }()
        case 11: try { try decoder.decodeRepeatedMessageField(value: &_storage._repeatedBoolValue) }()
        case 12: try { try decoder.decodeRepeatedMessageField(value: &_storage._repeatedInt32Value) }()
        case 13: try { try decoder.decodeRepeatedMessageField(value: &_storage._repeatedInt64Value) }()
        case 14: try { try decoder.decodeRepeatedMessageField(value: &_storage._repeatedUint32Value) }()
        case 15: try { try decoder.decodeRepeatedMessageField(value: &_storage._repeatedUint64Value) }()
        case 16: try { try decoder.decodeRepeatedMessageField(value: &_storage._repeatedFloatValue) }()
        case 17: try { try decoder.decodeRepeatedMessageField(value: &_storage._repeatedDoubleValue) }()
        case 18: try { try decoder.decodeRepeatedMessageField(value: &_storage._repeatedStringValue) }()
        case 19: try { try decoder.decodeRepeatedMessageField(value: &_storage._repeatedBytesValue) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._boolValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._int32Value {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._int64Value {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._uint32Value {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._uint64Value {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._floatValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._doubleValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._stringValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._bytesValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if !_storage._repeatedBoolValue.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._repeatedBoolValue, fieldNumber: 11)
      }
      if !_storage._repeatedInt32Value.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._repeatedInt32Value, fieldNumber: 12)
      }
      if !_storage._repeatedInt64Value.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._repeatedInt64Value, fieldNumber: 13)
      }
      if !_storage._repeatedUint32Value.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._repeatedUint32Value, fieldNumber: 14)
      }
      if !_storage._repeatedUint64Value.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._repeatedUint64Value, fieldNumber: 15)
      }
      if !_storage._repeatedFloatValue.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._repeatedFloatValue, fieldNumber: 16)
      }
      if !_storage._repeatedDoubleValue.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._repeatedDoubleValue, fieldNumber: 17)
      }
      if !_storage._repeatedStringValue.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._repeatedStringValue, fieldNumber: 18)
      }
      if !_storage._repeatedBytesValue.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._repeatedBytesValue, fieldNumber: 19)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto3_TestWrapper, rhs: Proto3_TestWrapper) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._boolValue != rhs_storage._boolValue {return false}
        if _storage._int32Value != rhs_storage._int32Value {return false}
        if _storage._int64Value != rhs_storage._int64Value {return false}
        if _storage._uint32Value != rhs_storage._uint32Value {return false}
        if _storage._uint64Value != rhs_storage._uint64Value {return false}
        if _storage._floatValue != rhs_storage._floatValue {return false}
        if _storage._doubleValue != rhs_storage._doubleValue {return false}
        if _storage._stringValue != rhs_storage._stringValue {return false}
        if _storage._bytesValue != rhs_storage._bytesValue {return false}
        if _storage._repeatedBoolValue != rhs_storage._repeatedBoolValue {return false}
        if _storage._repeatedInt32Value != rhs_storage._repeatedInt32Value {return false}
        if _storage._repeatedInt64Value != rhs_storage._repeatedInt64Value {return false}
        if _storage._repeatedUint32Value != rhs_storage._repeatedUint32Value {return false}
        if _storage._repeatedUint64Value != rhs_storage._repeatedUint64Value {return false}
        if _storage._repeatedFloatValue != rhs_storage._repeatedFloatValue {return false}
        if _storage._repeatedDoubleValue != rhs_storage._repeatedDoubleValue {return false}
        if _storage._repeatedStringValue != rhs_storage._repeatedStringValue {return false}
        if _storage._repeatedBytesValue != rhs_storage._repeatedBytesValue {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto3_TestTimestamp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TestTimestamp"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}value\0\u{3}repeated_value\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.repeatedValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.repeatedValue.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.repeatedValue, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto3_TestTimestamp, rhs: Proto3_TestTimestamp) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs.repeatedValue != rhs.repeatedValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto3_TestDuration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TestDuration"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}value\0\u{3}repeated_value\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.repeatedValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.repeatedValue.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.repeatedValue, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto3_TestDuration, rhs: Proto3_TestDuration) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs.repeatedValue != rhs.repeatedValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto3_TestFieldMask: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TestFieldMask"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}value\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto3_TestFieldMask, rhs: Proto3_TestFieldMask) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto3_TestStruct: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TestStruct"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}value\0\u{3}repeated_value\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.repeatedValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.repeatedValue.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.repeatedValue, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto3_TestStruct, rhs: Proto3_TestStruct) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs.repeatedValue != rhs.repeatedValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto3_TestAny: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TestAny"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}value\0\u{3}repeated_value\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.repeatedValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.repeatedValue.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.repeatedValue, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto3_TestAny, rhs: Proto3_TestAny) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs.repeatedValue != rhs.repeatedValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto3_TestValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TestValue"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}value\0\u{3}repeated_value\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.repeatedValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.repeatedValue.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.repeatedValue, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto3_TestValue, rhs: Proto3_TestValue) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs.repeatedValue != rhs.repeatedValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto3_TestListValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TestListValue"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}value\0\u{3}repeated_value\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.repeatedValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.repeatedValue.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.repeatedValue, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto3_TestListValue, rhs: Proto3_TestListValue) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs.repeatedValue != rhs.repeatedValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto3_TestBoolValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TestBoolValue"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}bool_value\0\u{3}bool_map\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.boolValue) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufBool,SwiftProtobuf.ProtobufInt32>.self, value: &self.boolMap) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.boolValue != false {
      try visitor.visitSingularBoolField(value: self.boolValue, fieldNumber: 1)
    }
    if !self.boolMap.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufBool,SwiftProtobuf.ProtobufInt32>.self, value: self.boolMap, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto3_TestBoolValue, rhs: Proto3_TestBoolValue) -> Bool {
    if lhs.boolValue != rhs.boolValue {return false}
    if lhs.boolMap != rhs.boolMap {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto3_TestNullValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TestNullValue"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{4}\u{14}null_value\0\u{3}repeated_null_value\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 20: try { try decoder.decodeSingularEnumField(value: &self.nullValue) }()
      case 21: try { try decoder.decodeRepeatedEnumField(value: &self.repeatedNullValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.nullValue != .nullValue {
      try visitor.visitSingularEnumField(value: self.nullValue, fieldNumber: 20)
    }
    if !self.repeatedNullValue.isEmpty {
      try visitor.visitPackedEnumField(value: self.repeatedNullValue, fieldNumber: 21)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto3_TestNullValue, rhs: Proto3_TestNullValue) -> Bool {
    if lhs.nullValue != rhs.nullValue {return false}
    if lhs.repeatedNullValue != rhs.repeatedNullValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto3_TestCustomJsonName: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TestCustomJsonName"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{5}value\0@value\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularInt32Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto3_TestCustomJsonName, rhs: Proto3_TestCustomJsonName) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto3_TestEvilJson: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TestEvilJson"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{5}regular_value\0regular_name\0\u{5}script\0</script>\0\u{5}quotes\0unbalanced\"quotes\0\u{5}script_and_quotes\0\"<script>alert('hello!);</script>\0\u{5}empty_string\0\0\u{5}backslash\0\\\0\u{5}low_codepoint\0\u{1}\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.regularValue) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.script) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.quotes) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.scriptAndQuotes) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.emptyString) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.backslash) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.lowCodepoint) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.regularValue != 0 {
      try visitor.visitSingularInt32Field(value: self.regularValue, fieldNumber: 1)
    }
    if self.script != 0 {
      try visitor.visitSingularInt32Field(value: self.script, fieldNumber: 2)
    }
    if self.quotes != 0 {
      try visitor.visitSingularInt32Field(value: self.quotes, fieldNumber: 3)
    }
    if self.scriptAndQuotes != 0 {
      try visitor.visitSingularInt32Field(value: self.scriptAndQuotes, fieldNumber: 4)
    }
    if self.emptyString != 0 {
      try visitor.visitSingularInt32Field(value: self.emptyString, fieldNumber: 5)
    }
    if self.backslash != 0 {
      try visitor.visitSingularInt32Field(value: self.backslash, fieldNumber: 6)
    }
    if self.lowCodepoint != 0 {
      try visitor.visitSingularInt32Field(value: self.lowCodepoint, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto3_TestEvilJson, rhs: Proto3_TestEvilJson) -> Bool {
    if lhs.regularValue != rhs.regularValue {return false}
    if lhs.script != rhs.script {return false}
    if lhs.quotes != rhs.quotes {return false}
    if lhs.scriptAndQuotes != rhs.scriptAndQuotes {return false}
    if lhs.emptyString != rhs.emptyString {return false}
    if lhs.backslash != rhs.backslash {return false}
    if lhs.lowCodepoint != rhs.lowCodepoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto3_TestExtensions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TestExtensions"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}extensions\0")

  public var isInitialized: Bool {
    if let v = self._extensions, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._extensions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._extensions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto3_TestExtensions, rhs: Proto3_TestExtensions) -> Bool {
    if lhs._extensions != rhs._extensions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto3_TestEnumValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TestEnumValue"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}enum_value1\0\u{3}enum_value2\0\u{3}enum_value3\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.enumValue1) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.enumValue2) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.enumValue3) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enumValue1 != .foo {
      try visitor.visitSingularEnumField(value: self.enumValue1, fieldNumber: 1)
    }
    if self.enumValue2 != .foo {
      try visitor.visitSingularEnumField(value: self.enumValue2, fieldNumber: 2)
    }
    if self.enumValue3 != .foo {
      try visitor.visitSingularEnumField(value: self.enumValue3, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto3_TestEnumValue, rhs: Proto3_TestEnumValue) -> Bool {
    if lhs.enumValue1 != rhs.enumValue1 {return false}
    if lhs.enumValue2 != rhs.enumValue2 {return false}
    if lhs.enumValue3 != rhs.enumValue3 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto3_MapsTestCases: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MapsTestCases"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}empty_map\0\u{3}string_to_int\0\u{3}int_to_string\0\u{1}mixed1\0\u{1}mixed2\0\u{3}map_of_objects\0\u{3}empty_key_string_to_int1\0\u{3}empty_key_string_to_int2\0\u{3}empty_key_string_to_int3\0\u{3}empty_key_bool_to_string\0\u{3}empty_key_int_to_string\0\u{3}empty_key_mixed\0\u{3}empty_key_map_objects\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._emptyMap) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._stringToInt) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._intToString) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._mixed1) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._mixed2) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._mapOfObjects) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._emptyKeyStringToInt1) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._emptyKeyStringToInt2) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._emptyKeyStringToInt3) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._emptyKeyBoolToString) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._emptyKeyIntToString) }()
      case 12: try { try decoder.decodeSingularMessageField(value: &self._emptyKeyMixed) }()
      case 13: try { try decoder.decodeSingularMessageField(value: &self._emptyKeyMapObjects) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._emptyMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._stringToInt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._intToString {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._mixed1 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._mixed2 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._mapOfObjects {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._emptyKeyStringToInt1 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._emptyKeyStringToInt2 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._emptyKeyStringToInt3 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._emptyKeyBoolToString {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._emptyKeyIntToString {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._emptyKeyMixed {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    } }()
    try { if let v = self._emptyKeyMapObjects {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto3_MapsTestCases, rhs: Proto3_MapsTestCases) -> Bool {
    if lhs._emptyMap != rhs._emptyMap {return false}
    if lhs._stringToInt != rhs._stringToInt {return false}
    if lhs._intToString != rhs._intToString {return false}
    if lhs._mixed1 != rhs._mixed1 {return false}
    if lhs._mixed2 != rhs._mixed2 {return false}
    if lhs._mapOfObjects != rhs._mapOfObjects {return false}
    if lhs._emptyKeyStringToInt1 != rhs._emptyKeyStringToInt1 {return false}
    if lhs._emptyKeyStringToInt2 != rhs._emptyKeyStringToInt2 {return false}
    if lhs._emptyKeyStringToInt3 != rhs._emptyKeyStringToInt3 {return false}
    if lhs._emptyKeyBoolToString != rhs._emptyKeyBoolToString {return false}
    if lhs._emptyKeyIntToString != rhs._emptyKeyIntToString {return false}
    if lhs._emptyKeyMixed != rhs._emptyKeyMixed {return false}
    if lhs._emptyKeyMapObjects != rhs._emptyKeyMapObjects {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto3_EmptyMap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EmptyMap"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}map\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt32,SwiftProtobuf.ProtobufInt32>.self, value: &self.map) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.map.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt32,SwiftProtobuf.ProtobufInt32>.self, value: self.map, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto3_EmptyMap, rhs: Proto3_EmptyMap) -> Bool {
    if lhs.map != rhs.map {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto3_StringtoInt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StringtoInt"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}map\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt32>.self, value: &self.map) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.map.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt32>.self, value: self.map, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto3_StringtoInt, rhs: Proto3_StringtoInt) -> Bool {
    if lhs.map != rhs.map {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto3_IntToString: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IntToString"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}map\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt32,SwiftProtobuf.ProtobufString>.self, value: &self.map) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.map.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt32,SwiftProtobuf.ProtobufString>.self, value: self.map, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto3_IntToString, rhs: Proto3_IntToString) -> Bool {
    if lhs.map != rhs.map {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto3_BoolToString: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BoolToString"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}map\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufBool,SwiftProtobuf.ProtobufString>.self, value: &self.map) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.map.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufBool,SwiftProtobuf.ProtobufString>.self, value: self.map, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto3_BoolToString, rhs: Proto3_BoolToString) -> Bool {
    if lhs.map != rhs.map {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto3_Mixed1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Mixed1"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}msg\0\u{1}map\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufFloat>.self, value: &self.map) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 1)
    }
    if !self.map.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufFloat>.self, value: self.map, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto3_Mixed1, rhs: Proto3_Mixed1) -> Bool {
    if lhs.msg != rhs.msg {return false}
    if lhs.map != rhs.map {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto3_Mixed2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Mixed2"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}map\0\u{1}ee\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt32,SwiftProtobuf.ProtobufBool>.self, value: &self.map) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.ee) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.map.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt32,SwiftProtobuf.ProtobufBool>.self, value: self.map, fieldNumber: 1)
    }
    if self.ee != .e0 {
      try visitor.visitSingularEnumField(value: self.ee, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto3_Mixed2, rhs: Proto3_Mixed2) -> Bool {
    if lhs.map != rhs.map {return false}
    if lhs.ee != rhs.ee {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto3_Mixed2.E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0E0\0\u{1}E1\0\u{1}E2\0\u{1}E3\0")
}

extension Proto3_MapOfObjects: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MapOfObjects"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}map\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Proto3_MapOfObjects.M>.self, value: &self.map) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.map.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Proto3_MapOfObjects.M>.self, value: self.map, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto3_MapOfObjects, rhs: Proto3_MapOfObjects) -> Bool {
    if lhs.map != rhs.map {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto3_MapOfObjects.M: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Proto3_MapOfObjects.protoMessageName + ".M"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}inner_text\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.innerText) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.innerText.isEmpty {
      try visitor.visitSingularStringField(value: self.innerText, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto3_MapOfObjects.M, rhs: Proto3_MapOfObjects.M) -> Bool {
    if lhs.innerText != rhs.innerText {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto3_MapOfEnums: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MapOfEnums"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}map\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufEnumMap<SwiftProtobuf.ProtobufString,Proto3_EnumType>.self, value: &self.map) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.map.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufEnumMap<SwiftProtobuf.ProtobufString,Proto3_EnumType>.self, value: self.map, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto3_MapOfEnums, rhs: Proto3_MapOfEnums) -> Bool {
    if lhs.map != rhs.map {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto3_MapIn: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MapIn"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}other\0\u{1}things\0\u{3}map_input\0\u{3}map_any\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.other) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.things) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.mapInput) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Any>.self, value: &self.mapAny) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.other.isEmpty {
      try visitor.visitSingularStringField(value: self.other, fieldNumber: 1)
    }
    if !self.things.isEmpty {
      try visitor.visitRepeatedStringField(value: self.things, fieldNumber: 2)
    }
    if !self.mapInput.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.mapInput, fieldNumber: 3)
    }
    if !self.mapAny.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Any>.self, value: self.mapAny, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto3_MapIn, rhs: Proto3_MapIn) -> Bool {
    if lhs.other != rhs.other {return false}
    if lhs.things != rhs.things {return false}
    if lhs.mapInput != rhs.mapInput {return false}
    if lhs.mapAny != rhs.mapAny {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto3_MapOut: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MapOut"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}map1\0\u{1}map2\0\u{1}map3\0\u{1}bar\0\u{1}map4\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Proto3_MapM>.self, value: &self.map1) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Proto3_MapOut>.self, value: &self.map2) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt32,SwiftProtobuf.ProtobufString>.self, value: &self.map3) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.bar) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufBool,SwiftProtobuf.ProtobufString>.self, value: &self.map4) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.map1.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Proto3_MapM>.self, value: self.map1, fieldNumber: 1)
    }
    if !self.map2.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Proto3_MapOut>.self, value: self.map2, fieldNumber: 2)
    }
    if !self.map3.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt32,SwiftProtobuf.ProtobufString>.self, value: self.map3, fieldNumber: 3)
    }
    if !self.bar.isEmpty {
      try visitor.visitSingularStringField(value: self.bar, fieldNumber: 4)
    }
    if !self.map4.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufBool,SwiftProtobuf.ProtobufString>.self, value: self.map4, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto3_MapOut, rhs: Proto3_MapOut) -> Bool {
    if lhs.map1 != rhs.map1 {return false}
    if lhs.map2 != rhs.map2 {return false}
    if lhs.map3 != rhs.map3 {return false}
    if lhs.map4 != rhs.map4 {return false}
    if lhs.bar != rhs.bar {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto3_MapOutWireFormat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MapOutWireFormat"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}map1\0\u{1}map2\0\u{1}map3\0\u{1}bar\0\u{1}map4\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.map1) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.map2) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.map3) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.bar) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.map4) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.map1.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.map1, fieldNumber: 1)
    }
    if !self.map2.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.map2, fieldNumber: 2)
    }
    if !self.map3.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.map3, fieldNumber: 3)
    }
    if !self.bar.isEmpty {
      try visitor.visitSingularStringField(value: self.bar, fieldNumber: 4)
    }
    if !self.map4.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.map4, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto3_MapOutWireFormat, rhs: Proto3_MapOutWireFormat) -> Bool {
    if lhs.map1 != rhs.map1 {return false}
    if lhs.map2 != rhs.map2 {return false}
    if lhs.map3 != rhs.map3 {return false}
    if lhs.map4 != rhs.map4 {return false}
    if lhs.bar != rhs.bar {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto3_MapOutWireFormat.Map1Entry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Proto3_MapOutWireFormat.protoMessageName + ".Map1Entry"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}key\0\u{1}value\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto3_MapOutWireFormat.Map1Entry, rhs: Proto3_MapOutWireFormat.Map1Entry) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto3_MapOutWireFormat.Map2Entry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Proto3_MapOutWireFormat.protoMessageName + ".Map2Entry"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}key\0\u{1}value\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto3_MapOutWireFormat.Map2Entry, rhs: Proto3_MapOutWireFormat.Map2Entry) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto3_MapOutWireFormat.Map3Entry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Proto3_MapOutWireFormat.protoMessageName + ".Map3Entry"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}key\0\u{1}value\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.key != 0 {
      try visitor.visitSingularInt32Field(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto3_MapOutWireFormat.Map3Entry, rhs: Proto3_MapOutWireFormat.Map3Entry) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto3_MapOutWireFormat.Map4Entry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Proto3_MapOutWireFormat.protoMessageName + ".Map4Entry"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}key\0\u{1}value\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.key != false {
      try visitor.visitSingularBoolField(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto3_MapOutWireFormat.Map4Entry, rhs: Proto3_MapOutWireFormat.Map4Entry) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto3_MapM: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MapM"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}foo\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.foo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.foo.isEmpty {
      try visitor.visitSingularStringField(value: self.foo, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto3_MapM, rhs: Proto3_MapM) -> Bool {
    if lhs.foo != rhs.foo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
