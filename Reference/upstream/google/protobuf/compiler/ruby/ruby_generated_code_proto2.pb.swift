// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/protobuf/compiler/ruby/ruby_generated_code_proto2.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
//
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file or at
// https://developers.google.com/open-source/licenses/bsd

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum A_B_C_TestEnum: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
  case `default` = 0
  case a = 1
  case b = 2
  case c = 3

  init() {
    self = .default
  }

}

struct A_B_C_TestMessage: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var optionalInt32: Int32 {
    get {_storage._optionalInt32 ?? 1}
    set {_uniqueStorage()._optionalInt32 = newValue}
  }
  /// Returns true if `optionalInt32` has been explicitly set.
  var hasOptionalInt32: Bool {_storage._optionalInt32 != nil}
  /// Clears the value of `optionalInt32`. Subsequent reads from it will return its default value.
  mutating func clearOptionalInt32() {_uniqueStorage()._optionalInt32 = nil}

  var optionalInt64: Int64 {
    get {_storage._optionalInt64 ?? 2}
    set {_uniqueStorage()._optionalInt64 = newValue}
  }
  /// Returns true if `optionalInt64` has been explicitly set.
  var hasOptionalInt64: Bool {_storage._optionalInt64 != nil}
  /// Clears the value of `optionalInt64`. Subsequent reads from it will return its default value.
  mutating func clearOptionalInt64() {_uniqueStorage()._optionalInt64 = nil}

  var optionalUint32: UInt32 {
    get {_storage._optionalUint32 ?? 3}
    set {_uniqueStorage()._optionalUint32 = newValue}
  }
  /// Returns true if `optionalUint32` has been explicitly set.
  var hasOptionalUint32: Bool {_storage._optionalUint32 != nil}
  /// Clears the value of `optionalUint32`. Subsequent reads from it will return its default value.
  mutating func clearOptionalUint32() {_uniqueStorage()._optionalUint32 = nil}

  var optionalUint64: UInt64 {
    get {_storage._optionalUint64 ?? 4}
    set {_uniqueStorage()._optionalUint64 = newValue}
  }
  /// Returns true if `optionalUint64` has been explicitly set.
  var hasOptionalUint64: Bool {_storage._optionalUint64 != nil}
  /// Clears the value of `optionalUint64`. Subsequent reads from it will return its default value.
  mutating func clearOptionalUint64() {_uniqueStorage()._optionalUint64 = nil}

  var optionalBool: Bool {
    get {_storage._optionalBool ?? true}
    set {_uniqueStorage()._optionalBool = newValue}
  }
  /// Returns true if `optionalBool` has been explicitly set.
  var hasOptionalBool: Bool {_storage._optionalBool != nil}
  /// Clears the value of `optionalBool`. Subsequent reads from it will return its default value.
  mutating func clearOptionalBool() {_uniqueStorage()._optionalBool = nil}

  var optionalDouble: Double {
    get {_storage._optionalDouble ?? 6}
    set {_uniqueStorage()._optionalDouble = newValue}
  }
  /// Returns true if `optionalDouble` has been explicitly set.
  var hasOptionalDouble: Bool {_storage._optionalDouble != nil}
  /// Clears the value of `optionalDouble`. Subsequent reads from it will return its default value.
  mutating func clearOptionalDouble() {_uniqueStorage()._optionalDouble = nil}

  var optionalFloat: Float {
    get {_storage._optionalFloat ?? 7}
    set {_uniqueStorage()._optionalFloat = newValue}
  }
  /// Returns true if `optionalFloat` has been explicitly set.
  var hasOptionalFloat: Bool {_storage._optionalFloat != nil}
  /// Clears the value of `optionalFloat`. Subsequent reads from it will return its default value.
  mutating func clearOptionalFloat() {_uniqueStorage()._optionalFloat = nil}

  var optionalString: String {
    get {_storage._optionalString ?? "default str"}
    set {_uniqueStorage()._optionalString = newValue}
  }
  /// Returns true if `optionalString` has been explicitly set.
  var hasOptionalString: Bool {_storage._optionalString != nil}
  /// Clears the value of `optionalString`. Subsequent reads from it will return its default value.
  mutating func clearOptionalString() {_uniqueStorage()._optionalString = nil}

  var optionalBytes: Data {
    get {_storage._optionalBytes ?? Data([0, 1, 2, 64, 102, 117, 98, 97, 114])}
    set {_uniqueStorage()._optionalBytes = newValue}
  }
  /// Returns true if `optionalBytes` has been explicitly set.
  var hasOptionalBytes: Bool {_storage._optionalBytes != nil}
  /// Clears the value of `optionalBytes`. Subsequent reads from it will return its default value.
  mutating func clearOptionalBytes() {_uniqueStorage()._optionalBytes = nil}

  var optionalEnum: A_B_C_TestEnum {
    get {_storage._optionalEnum ?? .a}
    set {_uniqueStorage()._optionalEnum = newValue}
  }
  /// Returns true if `optionalEnum` has been explicitly set.
  var hasOptionalEnum: Bool {_storage._optionalEnum != nil}
  /// Clears the value of `optionalEnum`. Subsequent reads from it will return its default value.
  mutating func clearOptionalEnum() {_uniqueStorage()._optionalEnum = nil}

  var optionalMsg: A_B_C_TestMessage {
    get {_storage._optionalMsg ?? A_B_C_TestMessage()}
    set {_uniqueStorage()._optionalMsg = newValue}
  }
  /// Returns true if `optionalMsg` has been explicitly set.
  var hasOptionalMsg: Bool {_storage._optionalMsg != nil}
  /// Clears the value of `optionalMsg`. Subsequent reads from it will return its default value.
  mutating func clearOptionalMsg() {_uniqueStorage()._optionalMsg = nil}

  var optionalProto2Submessage: A_B_C_TestImportedMessage {
    get {_storage._optionalProto2Submessage ?? A_B_C_TestImportedMessage()}
    set {_uniqueStorage()._optionalProto2Submessage = newValue}
  }
  /// Returns true if `optionalProto2Submessage` has been explicitly set.
  var hasOptionalProto2Submessage: Bool {_storage._optionalProto2Submessage != nil}
  /// Clears the value of `optionalProto2Submessage`. Subsequent reads from it will return its default value.
  mutating func clearOptionalProto2Submessage() {_uniqueStorage()._optionalProto2Submessage = nil}

  var repeatedInt32: [Int32] {
    get {_storage._repeatedInt32}
    set {_uniqueStorage()._repeatedInt32 = newValue}
  }

  var repeatedInt64: [Int64] {
    get {_storage._repeatedInt64}
    set {_uniqueStorage()._repeatedInt64 = newValue}
  }

  var repeatedUint32: [UInt32] {
    get {_storage._repeatedUint32}
    set {_uniqueStorage()._repeatedUint32 = newValue}
  }

  var repeatedUint64: [UInt64] {
    get {_storage._repeatedUint64}
    set {_uniqueStorage()._repeatedUint64 = newValue}
  }

  var repeatedBool: [Bool] {
    get {_storage._repeatedBool}
    set {_uniqueStorage()._repeatedBool = newValue}
  }

  var repeatedDouble: [Double] {
    get {_storage._repeatedDouble}
    set {_uniqueStorage()._repeatedDouble = newValue}
  }

  var repeatedFloat: [Float] {
    get {_storage._repeatedFloat}
    set {_uniqueStorage()._repeatedFloat = newValue}
  }

  var repeatedString: [String] {
    get {_storage._repeatedString}
    set {_uniqueStorage()._repeatedString = newValue}
  }

  var repeatedBytes: [Data] {
    get {_storage._repeatedBytes}
    set {_uniqueStorage()._repeatedBytes = newValue}
  }

  var repeatedEnum: [A_B_C_TestEnum] {
    get {_storage._repeatedEnum}
    set {_uniqueStorage()._repeatedEnum = newValue}
  }

  var repeatedMsg: [A_B_C_TestMessage] {
    get {_storage._repeatedMsg}
    set {_uniqueStorage()._repeatedMsg = newValue}
  }

  var requiredInt32: Int32 {
    get {_storage._requiredInt32 ?? 0}
    set {_uniqueStorage()._requiredInt32 = newValue}
  }
  /// Returns true if `requiredInt32` has been explicitly set.
  var hasRequiredInt32: Bool {_storage._requiredInt32 != nil}
  /// Clears the value of `requiredInt32`. Subsequent reads from it will return its default value.
  mutating func clearRequiredInt32() {_uniqueStorage()._requiredInt32 = nil}

  var requiredInt64: Int64 {
    get {_storage._requiredInt64 ?? 0}
    set {_uniqueStorage()._requiredInt64 = newValue}
  }
  /// Returns true if `requiredInt64` has been explicitly set.
  var hasRequiredInt64: Bool {_storage._requiredInt64 != nil}
  /// Clears the value of `requiredInt64`. Subsequent reads from it will return its default value.
  mutating func clearRequiredInt64() {_uniqueStorage()._requiredInt64 = nil}

  var requiredUint32: UInt32 {
    get {_storage._requiredUint32 ?? 0}
    set {_uniqueStorage()._requiredUint32 = newValue}
  }
  /// Returns true if `requiredUint32` has been explicitly set.
  var hasRequiredUint32: Bool {_storage._requiredUint32 != nil}
  /// Clears the value of `requiredUint32`. Subsequent reads from it will return its default value.
  mutating func clearRequiredUint32() {_uniqueStorage()._requiredUint32 = nil}

  var requiredUint64: UInt64 {
    get {_storage._requiredUint64 ?? 0}
    set {_uniqueStorage()._requiredUint64 = newValue}
  }
  /// Returns true if `requiredUint64` has been explicitly set.
  var hasRequiredUint64: Bool {_storage._requiredUint64 != nil}
  /// Clears the value of `requiredUint64`. Subsequent reads from it will return its default value.
  mutating func clearRequiredUint64() {_uniqueStorage()._requiredUint64 = nil}

  var requiredBool: Bool {
    get {_storage._requiredBool ?? false}
    set {_uniqueStorage()._requiredBool = newValue}
  }
  /// Returns true if `requiredBool` has been explicitly set.
  var hasRequiredBool: Bool {_storage._requiredBool != nil}
  /// Clears the value of `requiredBool`. Subsequent reads from it will return its default value.
  mutating func clearRequiredBool() {_uniqueStorage()._requiredBool = nil}

  var requiredDouble: Double {
    get {_storage._requiredDouble ?? 0}
    set {_uniqueStorage()._requiredDouble = newValue}
  }
  /// Returns true if `requiredDouble` has been explicitly set.
  var hasRequiredDouble: Bool {_storage._requiredDouble != nil}
  /// Clears the value of `requiredDouble`. Subsequent reads from it will return its default value.
  mutating func clearRequiredDouble() {_uniqueStorage()._requiredDouble = nil}

  var requiredFloat: Float {
    get {_storage._requiredFloat ?? 0}
    set {_uniqueStorage()._requiredFloat = newValue}
  }
  /// Returns true if `requiredFloat` has been explicitly set.
  var hasRequiredFloat: Bool {_storage._requiredFloat != nil}
  /// Clears the value of `requiredFloat`. Subsequent reads from it will return its default value.
  mutating func clearRequiredFloat() {_uniqueStorage()._requiredFloat = nil}

  var requiredString: String {
    get {_storage._requiredString ?? String()}
    set {_uniqueStorage()._requiredString = newValue}
  }
  /// Returns true if `requiredString` has been explicitly set.
  var hasRequiredString: Bool {_storage._requiredString != nil}
  /// Clears the value of `requiredString`. Subsequent reads from it will return its default value.
  mutating func clearRequiredString() {_uniqueStorage()._requiredString = nil}

  var requiredBytes: Data {
    get {_storage._requiredBytes ?? Data()}
    set {_uniqueStorage()._requiredBytes = newValue}
  }
  /// Returns true if `requiredBytes` has been explicitly set.
  var hasRequiredBytes: Bool {_storage._requiredBytes != nil}
  /// Clears the value of `requiredBytes`. Subsequent reads from it will return its default value.
  mutating func clearRequiredBytes() {_uniqueStorage()._requiredBytes = nil}

  var requiredEnum: A_B_C_TestEnum {
    get {_storage._requiredEnum ?? .default}
    set {_uniqueStorage()._requiredEnum = newValue}
  }
  /// Returns true if `requiredEnum` has been explicitly set.
  var hasRequiredEnum: Bool {_storage._requiredEnum != nil}
  /// Clears the value of `requiredEnum`. Subsequent reads from it will return its default value.
  mutating func clearRequiredEnum() {_uniqueStorage()._requiredEnum = nil}

  var requiredMsg: A_B_C_TestMessage {
    get {_storage._requiredMsg ?? A_B_C_TestMessage()}
    set {_uniqueStorage()._requiredMsg = newValue}
  }
  /// Returns true if `requiredMsg` has been explicitly set.
  var hasRequiredMsg: Bool {_storage._requiredMsg != nil}
  /// Clears the value of `requiredMsg`. Subsequent reads from it will return its default value.
  mutating func clearRequiredMsg() {_uniqueStorage()._requiredMsg = nil}

  var myOneof: OneOf_MyOneof? {
    get {return _storage._myOneof}
    set {_uniqueStorage()._myOneof = newValue}
  }

  var oneofInt32: Int32 {
    get {
      if case .oneofInt32(let v)? = _storage._myOneof {return v}
      return 0
    }
    set {_uniqueStorage()._myOneof = .oneofInt32(newValue)}
  }

  var oneofInt64: Int64 {
    get {
      if case .oneofInt64(let v)? = _storage._myOneof {return v}
      return 0
    }
    set {_uniqueStorage()._myOneof = .oneofInt64(newValue)}
  }

  var oneofUint32: UInt32 {
    get {
      if case .oneofUint32(let v)? = _storage._myOneof {return v}
      return 0
    }
    set {_uniqueStorage()._myOneof = .oneofUint32(newValue)}
  }

  var oneofUint64: UInt64 {
    get {
      if case .oneofUint64(let v)? = _storage._myOneof {return v}
      return 0
    }
    set {_uniqueStorage()._myOneof = .oneofUint64(newValue)}
  }

  var oneofBool: Bool {
    get {
      if case .oneofBool(let v)? = _storage._myOneof {return v}
      return false
    }
    set {_uniqueStorage()._myOneof = .oneofBool(newValue)}
  }

  var oneofDouble: Double {
    get {
      if case .oneofDouble(let v)? = _storage._myOneof {return v}
      return 0
    }
    set {_uniqueStorage()._myOneof = .oneofDouble(newValue)}
  }

  var oneofFloat: Float {
    get {
      if case .oneofFloat(let v)? = _storage._myOneof {return v}
      return 0
    }
    set {_uniqueStorage()._myOneof = .oneofFloat(newValue)}
  }

  var oneofString: String {
    get {
      if case .oneofString(let v)? = _storage._myOneof {return v}
      return String()
    }
    set {_uniqueStorage()._myOneof = .oneofString(newValue)}
  }

  var oneofBytes: Data {
    get {
      if case .oneofBytes(let v)? = _storage._myOneof {return v}
      return Data()
    }
    set {_uniqueStorage()._myOneof = .oneofBytes(newValue)}
  }

  var oneofEnum: A_B_C_TestEnum {
    get {
      if case .oneofEnum(let v)? = _storage._myOneof {return v}
      return .default
    }
    set {_uniqueStorage()._myOneof = .oneofEnum(newValue)}
  }

  var oneofMsg: A_B_C_TestMessage {
    get {
      if case .oneofMsg(let v)? = _storage._myOneof {return v}
      return A_B_C_TestMessage()
    }
    set {_uniqueStorage()._myOneof = .oneofMsg(newValue)}
  }

  var nestedMessage: A_B_C_TestMessage.NestedMessage {
    get {_storage._nestedMessage ?? A_B_C_TestMessage.NestedMessage()}
    set {_uniqueStorage()._nestedMessage = newValue}
  }
  /// Returns true if `nestedMessage` has been explicitly set.
  var hasNestedMessage: Bool {_storage._nestedMessage != nil}
  /// Clears the value of `nestedMessage`. Subsequent reads from it will return its default value.
  mutating func clearNestedMessage() {_uniqueStorage()._nestedMessage = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_MyOneof: Equatable, Sendable {
    case oneofInt32(Int32)
    case oneofInt64(Int64)
    case oneofUint32(UInt32)
    case oneofUint64(UInt64)
    case oneofBool(Bool)
    case oneofDouble(Double)
    case oneofFloat(Float)
    case oneofString(String)
    case oneofBytes(Data)
    case oneofEnum(A_B_C_TestEnum)
    case oneofMsg(A_B_C_TestMessage)

    fileprivate var isInitialized: Bool {
      guard case .oneofMsg(let v) = self else {return true}
      return v.isInitialized
    }

  }

  struct NestedMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var foo: Int32 {
      get {_foo ?? 0}
      set {_foo = newValue}
    }
    /// Returns true if `foo` has been explicitly set.
    var hasFoo: Bool {self._foo != nil}
    /// Clears the value of `foo`. Subsequent reads from it will return its default value.
    mutating func clearFoo() {self._foo = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _foo: Int32? = nil
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "A.B.C"

extension A_B_C_TestEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0Default\0\u{1}A\0\u{1}B\0\u{1}C\0")
}

extension A_B_C_TestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TestMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}optional_int32\0\u{3}optional_int64\0\u{3}optional_uint32\0\u{3}optional_uint64\0\u{3}optional_bool\0\u{3}optional_double\0\u{3}optional_float\0\u{3}optional_string\0\u{3}optional_bytes\0\u{3}optional_enum\0\u{3}optional_msg\0\u{3}optional_proto2_submessage\0\u{4}\u{9}repeated_int32\0\u{3}repeated_int64\0\u{3}repeated_uint32\0\u{3}repeated_uint64\0\u{3}repeated_bool\0\u{3}repeated_double\0\u{3}repeated_float\0\u{3}repeated_string\0\u{3}repeated_bytes\0\u{3}repeated_enum\0\u{3}repeated_msg\0\u{4}\u{a}required_int32\0\u{3}required_int64\0\u{3}required_uint32\0\u{3}required_uint64\0\u{3}required_bool\0\u{3}required_double\0\u{3}required_float\0\u{3}required_string\0\u{3}required_bytes\0\u{3}required_enum\0\u{3}required_msg\0\u{4}\u{a}oneof_int32\0\u{3}oneof_int64\0\u{3}oneof_uint32\0\u{3}oneof_uint64\0\u{3}oneof_bool\0\u{3}oneof_double\0\u{3}oneof_float\0\u{3}oneof_string\0\u{3}oneof_bytes\0\u{3}oneof_enum\0\u{3}oneof_msg\0\u{4}\u{9}nested_message\0")

  fileprivate class _StorageClass {
    var _optionalInt32: Int32? = nil
    var _optionalInt64: Int64? = nil
    var _optionalUint32: UInt32? = nil
    var _optionalUint64: UInt64? = nil
    var _optionalBool: Bool? = nil
    var _optionalDouble: Double? = nil
    var _optionalFloat: Float? = nil
    var _optionalString: String? = nil
    var _optionalBytes: Data? = nil
    var _optionalEnum: A_B_C_TestEnum? = nil
    var _optionalMsg: A_B_C_TestMessage? = nil
    var _optionalProto2Submessage: A_B_C_TestImportedMessage? = nil
    var _repeatedInt32: [Int32] = []
    var _repeatedInt64: [Int64] = []
    var _repeatedUint32: [UInt32] = []
    var _repeatedUint64: [UInt64] = []
    var _repeatedBool: [Bool] = []
    var _repeatedDouble: [Double] = []
    var _repeatedFloat: [Float] = []
    var _repeatedString: [String] = []
    var _repeatedBytes: [Data] = []
    var _repeatedEnum: [A_B_C_TestEnum] = []
    var _repeatedMsg: [A_B_C_TestMessage] = []
    var _requiredInt32: Int32? = nil
    var _requiredInt64: Int64? = nil
    var _requiredUint32: UInt32? = nil
    var _requiredUint64: UInt64? = nil
    var _requiredBool: Bool? = nil
    var _requiredDouble: Double? = nil
    var _requiredFloat: Float? = nil
    var _requiredString: String? = nil
    var _requiredBytes: Data? = nil
    var _requiredEnum: A_B_C_TestEnum? = nil
    var _requiredMsg: A_B_C_TestMessage? = nil
    var _myOneof: A_B_C_TestMessage.OneOf_MyOneof?
    var _nestedMessage: A_B_C_TestMessage.NestedMessage? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _optionalInt32 = source._optionalInt32
      _optionalInt64 = source._optionalInt64
      _optionalUint32 = source._optionalUint32
      _optionalUint64 = source._optionalUint64
      _optionalBool = source._optionalBool
      _optionalDouble = source._optionalDouble
      _optionalFloat = source._optionalFloat
      _optionalString = source._optionalString
      _optionalBytes = source._optionalBytes
      _optionalEnum = source._optionalEnum
      _optionalMsg = source._optionalMsg
      _optionalProto2Submessage = source._optionalProto2Submessage
      _repeatedInt32 = source._repeatedInt32
      _repeatedInt64 = source._repeatedInt64
      _repeatedUint32 = source._repeatedUint32
      _repeatedUint64 = source._repeatedUint64
      _repeatedBool = source._repeatedBool
      _repeatedDouble = source._repeatedDouble
      _repeatedFloat = source._repeatedFloat
      _repeatedString = source._repeatedString
      _repeatedBytes = source._repeatedBytes
      _repeatedEnum = source._repeatedEnum
      _repeatedMsg = source._repeatedMsg
      _requiredInt32 = source._requiredInt32
      _requiredInt64 = source._requiredInt64
      _requiredUint32 = source._requiredUint32
      _requiredUint64 = source._requiredUint64
      _requiredBool = source._requiredBool
      _requiredDouble = source._requiredDouble
      _requiredFloat = source._requiredFloat
      _requiredString = source._requiredString
      _requiredBytes = source._requiredBytes
      _requiredEnum = source._requiredEnum
      _requiredMsg = source._requiredMsg
      _myOneof = source._myOneof
      _nestedMessage = source._nestedMessage
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._requiredInt32 == nil {return false}
      if _storage._requiredInt64 == nil {return false}
      if _storage._requiredUint32 == nil {return false}
      if _storage._requiredUint64 == nil {return false}
      if _storage._requiredBool == nil {return false}
      if _storage._requiredDouble == nil {return false}
      if _storage._requiredFloat == nil {return false}
      if _storage._requiredString == nil {return false}
      if _storage._requiredBytes == nil {return false}
      if _storage._requiredEnum == nil {return false}
      if _storage._requiredMsg == nil {return false}
      if let v = _storage._optionalMsg, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._repeatedMsg) {return false}
      if let v = _storage._requiredMsg, !v.isInitialized {return false}
      if let v = _storage._myOneof, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._optionalInt32) }()
        case 2: try { try decoder.decodeSingularInt64Field(value: &_storage._optionalInt64) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._optionalUint32) }()
        case 4: try { try decoder.decodeSingularUInt64Field(value: &_storage._optionalUint64) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._optionalBool) }()
        case 6: try { try decoder.decodeSingularDoubleField(value: &_storage._optionalDouble) }()
        case 7: try { try decoder.decodeSingularFloatField(value: &_storage._optionalFloat) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._optionalString) }()
        case 9: try { try decoder.decodeSingularBytesField(value: &_storage._optionalBytes) }()
        case 10: try { try decoder.decodeSingularEnumField(value: &_storage._optionalEnum) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._optionalMsg) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._optionalProto2Submessage) }()
        case 21: try { try decoder.decodeRepeatedInt32Field(value: &_storage._repeatedInt32) }()
        case 22: try { try decoder.decodeRepeatedInt64Field(value: &_storage._repeatedInt64) }()
        case 23: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._repeatedUint32) }()
        case 24: try { try decoder.decodeRepeatedUInt64Field(value: &_storage._repeatedUint64) }()
        case 25: try { try decoder.decodeRepeatedBoolField(value: &_storage._repeatedBool) }()
        case 26: try { try decoder.decodeRepeatedDoubleField(value: &_storage._repeatedDouble) }()
        case 27: try { try decoder.decodeRepeatedFloatField(value: &_storage._repeatedFloat) }()
        case 28: try { try decoder.decodeRepeatedStringField(value: &_storage._repeatedString) }()
        case 29: try { try decoder.decodeRepeatedBytesField(value: &_storage._repeatedBytes) }()
        case 30: try { try decoder.decodeRepeatedEnumField(value: &_storage._repeatedEnum) }()
        case 31: try { try decoder.decodeRepeatedMessageField(value: &_storage._repeatedMsg) }()
        case 41: try { try decoder.decodeSingularInt32Field(value: &_storage._requiredInt32) }()
        case 42: try { try decoder.decodeSingularInt64Field(value: &_storage._requiredInt64) }()
        case 43: try { try decoder.decodeSingularUInt32Field(value: &_storage._requiredUint32) }()
        case 44: try { try decoder.decodeSingularUInt64Field(value: &_storage._requiredUint64) }()
        case 45: try { try decoder.decodeSingularBoolField(value: &_storage._requiredBool) }()
        case 46: try { try decoder.decodeSingularDoubleField(value: &_storage._requiredDouble) }()
        case 47: try { try decoder.decodeSingularFloatField(value: &_storage._requiredFloat) }()
        case 48: try { try decoder.decodeSingularStringField(value: &_storage._requiredString) }()
        case 49: try { try decoder.decodeSingularBytesField(value: &_storage._requiredBytes) }()
        case 50: try { try decoder.decodeSingularEnumField(value: &_storage._requiredEnum) }()
        case 51: try { try decoder.decodeSingularMessageField(value: &_storage._requiredMsg) }()
        case 61: try {
          var v: Int32?
          try decoder.decodeSingularInt32Field(value: &v)
          if let v = v {
            if _storage._myOneof != nil {try decoder.handleConflictingOneOf()}
            _storage._myOneof = .oneofInt32(v)
          }
        }()
        case 62: try {
          var v: Int64?
          try decoder.decodeSingularInt64Field(value: &v)
          if let v = v {
            if _storage._myOneof != nil {try decoder.handleConflictingOneOf()}
            _storage._myOneof = .oneofInt64(v)
          }
        }()
        case 63: try {
          var v: UInt32?
          try decoder.decodeSingularUInt32Field(value: &v)
          if let v = v {
            if _storage._myOneof != nil {try decoder.handleConflictingOneOf()}
            _storage._myOneof = .oneofUint32(v)
          }
        }()
        case 64: try {
          var v: UInt64?
          try decoder.decodeSingularUInt64Field(value: &v)
          if let v = v {
            if _storage._myOneof != nil {try decoder.handleConflictingOneOf()}
            _storage._myOneof = .oneofUint64(v)
          }
        }()
        case 65: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._myOneof != nil {try decoder.handleConflictingOneOf()}
            _storage._myOneof = .oneofBool(v)
          }
        }()
        case 66: try {
          var v: Double?
          try decoder.decodeSingularDoubleField(value: &v)
          if let v = v {
            if _storage._myOneof != nil {try decoder.handleConflictingOneOf()}
            _storage._myOneof = .oneofDouble(v)
          }
        }()
        case 67: try {
          var v: Float?
          try decoder.decodeSingularFloatField(value: &v)
          if let v = v {
            if _storage._myOneof != nil {try decoder.handleConflictingOneOf()}
            _storage._myOneof = .oneofFloat(v)
          }
        }()
        case 68: try {
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {
            if _storage._myOneof != nil {try decoder.handleConflictingOneOf()}
            _storage._myOneof = .oneofString(v)
          }
        }()
        case 69: try {
          var v: Data?
          try decoder.decodeSingularBytesField(value: &v)
          if let v = v {
            if _storage._myOneof != nil {try decoder.handleConflictingOneOf()}
            _storage._myOneof = .oneofBytes(v)
          }
        }()
        case 70: try {
          var v: A_B_C_TestEnum?
          try decoder.decodeSingularEnumField(value: &v)
          if let v = v {
            if _storage._myOneof != nil {try decoder.handleConflictingOneOf()}
            _storage._myOneof = .oneofEnum(v)
          }
        }()
        case 71: try {
          var v: A_B_C_TestMessage?
          var hadOneofValue = false
          if let current = _storage._myOneof {
            hadOneofValue = true
            if case .oneofMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._myOneof = .oneofMsg(v)
          }
        }()
        case 80: try { try decoder.decodeSingularMessageField(value: &_storage._nestedMessage) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._optionalInt32 {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._optionalInt64 {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._optionalUint32 {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._optionalUint64 {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._optionalBool {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._optionalDouble {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._optionalFloat {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._optionalString {
        try visitor.visitSingularStringField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._optionalBytes {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._optionalEnum {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._optionalMsg {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._optionalProto2Submessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if !_storage._repeatedInt32.isEmpty {
        try visitor.visitRepeatedInt32Field(value: _storage._repeatedInt32, fieldNumber: 21)
      }
      if !_storage._repeatedInt64.isEmpty {
        try visitor.visitRepeatedInt64Field(value: _storage._repeatedInt64, fieldNumber: 22)
      }
      if !_storage._repeatedUint32.isEmpty {
        try visitor.visitRepeatedUInt32Field(value: _storage._repeatedUint32, fieldNumber: 23)
      }
      if !_storage._repeatedUint64.isEmpty {
        try visitor.visitRepeatedUInt64Field(value: _storage._repeatedUint64, fieldNumber: 24)
      }
      if !_storage._repeatedBool.isEmpty {
        try visitor.visitRepeatedBoolField(value: _storage._repeatedBool, fieldNumber: 25)
      }
      if !_storage._repeatedDouble.isEmpty {
        try visitor.visitRepeatedDoubleField(value: _storage._repeatedDouble, fieldNumber: 26)
      }
      if !_storage._repeatedFloat.isEmpty {
        try visitor.visitRepeatedFloatField(value: _storage._repeatedFloat, fieldNumber: 27)
      }
      if !_storage._repeatedString.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._repeatedString, fieldNumber: 28)
      }
      if !_storage._repeatedBytes.isEmpty {
        try visitor.visitRepeatedBytesField(value: _storage._repeatedBytes, fieldNumber: 29)
      }
      if !_storage._repeatedEnum.isEmpty {
        try visitor.visitRepeatedEnumField(value: _storage._repeatedEnum, fieldNumber: 30)
      }
      if !_storage._repeatedMsg.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._repeatedMsg, fieldNumber: 31)
      }
      try { if let v = _storage._requiredInt32 {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 41)
      } }()
      try { if let v = _storage._requiredInt64 {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 42)
      } }()
      try { if let v = _storage._requiredUint32 {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 43)
      } }()
      try { if let v = _storage._requiredUint64 {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 44)
      } }()
      try { if let v = _storage._requiredBool {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 45)
      } }()
      try { if let v = _storage._requiredDouble {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 46)
      } }()
      try { if let v = _storage._requiredFloat {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 47)
      } }()
      try { if let v = _storage._requiredString {
        try visitor.visitSingularStringField(value: v, fieldNumber: 48)
      } }()
      try { if let v = _storage._requiredBytes {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 49)
      } }()
      try { if let v = _storage._requiredEnum {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 50)
      } }()
      try { if let v = _storage._requiredMsg {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
      } }()
      switch _storage._myOneof {
      case .oneofInt32?: try {
        guard case .oneofInt32(let v)? = _storage._myOneof else { preconditionFailure() }
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 61)
      }()
      case .oneofInt64?: try {
        guard case .oneofInt64(let v)? = _storage._myOneof else { preconditionFailure() }
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 62)
      }()
      case .oneofUint32?: try {
        guard case .oneofUint32(let v)? = _storage._myOneof else { preconditionFailure() }
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 63)
      }()
      case .oneofUint64?: try {
        guard case .oneofUint64(let v)? = _storage._myOneof else { preconditionFailure() }
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 64)
      }()
      case .oneofBool?: try {
        guard case .oneofBool(let v)? = _storage._myOneof else { preconditionFailure() }
        try visitor.visitSingularBoolField(value: v, fieldNumber: 65)
      }()
      case .oneofDouble?: try {
        guard case .oneofDouble(let v)? = _storage._myOneof else { preconditionFailure() }
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 66)
      }()
      case .oneofFloat?: try {
        guard case .oneofFloat(let v)? = _storage._myOneof else { preconditionFailure() }
        try visitor.visitSingularFloatField(value: v, fieldNumber: 67)
      }()
      case .oneofString?: try {
        guard case .oneofString(let v)? = _storage._myOneof else { preconditionFailure() }
        try visitor.visitSingularStringField(value: v, fieldNumber: 68)
      }()
      case .oneofBytes?: try {
        guard case .oneofBytes(let v)? = _storage._myOneof else { preconditionFailure() }
        try visitor.visitSingularBytesField(value: v, fieldNumber: 69)
      }()
      case .oneofEnum?: try {
        guard case .oneofEnum(let v)? = _storage._myOneof else { preconditionFailure() }
        try visitor.visitSingularEnumField(value: v, fieldNumber: 70)
      }()
      case .oneofMsg?: try {
        guard case .oneofMsg(let v)? = _storage._myOneof else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 71)
      }()
      case nil: break
      }
      try { if let v = _storage._nestedMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 80)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: A_B_C_TestMessage, rhs: A_B_C_TestMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._optionalInt32 != rhs_storage._optionalInt32 {return false}
        if _storage._optionalInt64 != rhs_storage._optionalInt64 {return false}
        if _storage._optionalUint32 != rhs_storage._optionalUint32 {return false}
        if _storage._optionalUint64 != rhs_storage._optionalUint64 {return false}
        if _storage._optionalBool != rhs_storage._optionalBool {return false}
        if _storage._optionalDouble != rhs_storage._optionalDouble {return false}
        if _storage._optionalFloat != rhs_storage._optionalFloat {return false}
        if _storage._optionalString != rhs_storage._optionalString {return false}
        if _storage._optionalBytes != rhs_storage._optionalBytes {return false}
        if _storage._optionalEnum != rhs_storage._optionalEnum {return false}
        if _storage._optionalMsg != rhs_storage._optionalMsg {return false}
        if _storage._optionalProto2Submessage != rhs_storage._optionalProto2Submessage {return false}
        if _storage._repeatedInt32 != rhs_storage._repeatedInt32 {return false}
        if _storage._repeatedInt64 != rhs_storage._repeatedInt64 {return false}
        if _storage._repeatedUint32 != rhs_storage._repeatedUint32 {return false}
        if _storage._repeatedUint64 != rhs_storage._repeatedUint64 {return false}
        if _storage._repeatedBool != rhs_storage._repeatedBool {return false}
        if _storage._repeatedDouble != rhs_storage._repeatedDouble {return false}
        if _storage._repeatedFloat != rhs_storage._repeatedFloat {return false}
        if _storage._repeatedString != rhs_storage._repeatedString {return false}
        if _storage._repeatedBytes != rhs_storage._repeatedBytes {return false}
        if _storage._repeatedEnum != rhs_storage._repeatedEnum {return false}
        if _storage._repeatedMsg != rhs_storage._repeatedMsg {return false}
        if _storage._requiredInt32 != rhs_storage._requiredInt32 {return false}
        if _storage._requiredInt64 != rhs_storage._requiredInt64 {return false}
        if _storage._requiredUint32 != rhs_storage._requiredUint32 {return false}
        if _storage._requiredUint64 != rhs_storage._requiredUint64 {return false}
        if _storage._requiredBool != rhs_storage._requiredBool {return false}
        if _storage._requiredDouble != rhs_storage._requiredDouble {return false}
        if _storage._requiredFloat != rhs_storage._requiredFloat {return false}
        if _storage._requiredString != rhs_storage._requiredString {return false}
        if _storage._requiredBytes != rhs_storage._requiredBytes {return false}
        if _storage._requiredEnum != rhs_storage._requiredEnum {return false}
        if _storage._requiredMsg != rhs_storage._requiredMsg {return false}
        if _storage._myOneof != rhs_storage._myOneof {return false}
        if _storage._nestedMessage != rhs_storage._nestedMessage {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension A_B_C_TestMessage.NestedMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = A_B_C_TestMessage.protoMessageName + ".NestedMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}foo\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._foo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._foo {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: A_B_C_TestMessage.NestedMessage, rhs: A_B_C_TestMessage.NestedMessage) -> Bool {
    if lhs._foo != rhs._foo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
