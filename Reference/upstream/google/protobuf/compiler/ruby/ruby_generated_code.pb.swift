// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/protobuf/compiler/ruby/ruby_generated_code.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
//
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file or at
// https://developers.google.com/open-source/licenses/bsd

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum A_B_C_TestEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case `default` // = 0
  case a // = 1
  case b // = 2
  case c // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .default
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .default
    case 1: self = .a
    case 2: self = .b
    case 3: self = .c
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .default: return 0
    case .a: return 1
    case .b: return 2
    case .c: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [A_B_C_TestEnum] = [
    .default,
    .a,
    .b,
    .c,
  ]

}

struct A_B_C_TestMessage: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var optionalInt32: Int32 {
    get {_storage._optionalInt32}
    set {_uniqueStorage()._optionalInt32 = newValue}
  }

  var optionalInt64: Int64 {
    get {_storage._optionalInt64}
    set {_uniqueStorage()._optionalInt64 = newValue}
  }

  var optionalUint32: UInt32 {
    get {_storage._optionalUint32}
    set {_uniqueStorage()._optionalUint32 = newValue}
  }

  var optionalUint64: UInt64 {
    get {_storage._optionalUint64}
    set {_uniqueStorage()._optionalUint64 = newValue}
  }

  var optionalBool: Bool {
    get {_storage._optionalBool}
    set {_uniqueStorage()._optionalBool = newValue}
  }

  var optionalDouble: Double {
    get {_storage._optionalDouble}
    set {_uniqueStorage()._optionalDouble = newValue}
  }

  var optionalFloat: Float {
    get {_storage._optionalFloat}
    set {_uniqueStorage()._optionalFloat = newValue}
  }

  var optionalString: String {
    get {_storage._optionalString}
    set {_uniqueStorage()._optionalString = newValue}
  }

  var optionalBytes: Data {
    get {_storage._optionalBytes}
    set {_uniqueStorage()._optionalBytes = newValue}
  }

  var optionalEnum: A_B_C_TestEnum {
    get {_storage._optionalEnum}
    set {_uniqueStorage()._optionalEnum = newValue}
  }

  var optionalMsg: A_B_C_TestMessage {
    get {_storage._optionalMsg ?? A_B_C_TestMessage()}
    set {_uniqueStorage()._optionalMsg = newValue}
  }
  /// Returns true if `optionalMsg` has been explicitly set.
  var hasOptionalMsg: Bool {_storage._optionalMsg != nil}
  /// Clears the value of `optionalMsg`. Subsequent reads from it will return its default value.
  mutating func clearOptionalMsg() {_uniqueStorage()._optionalMsg = nil}

  var optionalProto2Submessage: A_B_C_TestImportedMessage {
    get {_storage._optionalProto2Submessage ?? A_B_C_TestImportedMessage()}
    set {_uniqueStorage()._optionalProto2Submessage = newValue}
  }
  /// Returns true if `optionalProto2Submessage` has been explicitly set.
  var hasOptionalProto2Submessage: Bool {_storage._optionalProto2Submessage != nil}
  /// Clears the value of `optionalProto2Submessage`. Subsequent reads from it will return its default value.
  mutating func clearOptionalProto2Submessage() {_uniqueStorage()._optionalProto2Submessage = nil}

  var repeatedInt32: [Int32] {
    get {_storage._repeatedInt32}
    set {_uniqueStorage()._repeatedInt32 = newValue}
  }

  var repeatedInt64: [Int64] {
    get {_storage._repeatedInt64}
    set {_uniqueStorage()._repeatedInt64 = newValue}
  }

  var repeatedUint32: [UInt32] {
    get {_storage._repeatedUint32}
    set {_uniqueStorage()._repeatedUint32 = newValue}
  }

  var repeatedUint64: [UInt64] {
    get {_storage._repeatedUint64}
    set {_uniqueStorage()._repeatedUint64 = newValue}
  }

  var repeatedBool: [Bool] {
    get {_storage._repeatedBool}
    set {_uniqueStorage()._repeatedBool = newValue}
  }

  var repeatedDouble: [Double] {
    get {_storage._repeatedDouble}
    set {_uniqueStorage()._repeatedDouble = newValue}
  }

  var repeatedFloat: [Float] {
    get {_storage._repeatedFloat}
    set {_uniqueStorage()._repeatedFloat = newValue}
  }

  var repeatedString: [String] {
    get {_storage._repeatedString}
    set {_uniqueStorage()._repeatedString = newValue}
  }

  var repeatedBytes: [Data] {
    get {_storage._repeatedBytes}
    set {_uniqueStorage()._repeatedBytes = newValue}
  }

  var repeatedEnum: [A_B_C_TestEnum] {
    get {_storage._repeatedEnum}
    set {_uniqueStorage()._repeatedEnum = newValue}
  }

  var repeatedMsg: [A_B_C_TestMessage] {
    get {_storage._repeatedMsg}
    set {_uniqueStorage()._repeatedMsg = newValue}
  }

  var myOneof: OneOf_MyOneof? {
    get {return _storage._myOneof}
    set {_uniqueStorage()._myOneof = newValue}
  }

  var oneofInt32: Int32 {
    get {
      if case .oneofInt32(let v)? = _storage._myOneof {return v}
      return 0
    }
    set {_uniqueStorage()._myOneof = .oneofInt32(newValue)}
  }

  var oneofInt64: Int64 {
    get {
      if case .oneofInt64(let v)? = _storage._myOneof {return v}
      return 0
    }
    set {_uniqueStorage()._myOneof = .oneofInt64(newValue)}
  }

  var oneofUint32: UInt32 {
    get {
      if case .oneofUint32(let v)? = _storage._myOneof {return v}
      return 0
    }
    set {_uniqueStorage()._myOneof = .oneofUint32(newValue)}
  }

  var oneofUint64: UInt64 {
    get {
      if case .oneofUint64(let v)? = _storage._myOneof {return v}
      return 0
    }
    set {_uniqueStorage()._myOneof = .oneofUint64(newValue)}
  }

  var oneofBool: Bool {
    get {
      if case .oneofBool(let v)? = _storage._myOneof {return v}
      return false
    }
    set {_uniqueStorage()._myOneof = .oneofBool(newValue)}
  }

  var oneofDouble: Double {
    get {
      if case .oneofDouble(let v)? = _storage._myOneof {return v}
      return 0
    }
    set {_uniqueStorage()._myOneof = .oneofDouble(newValue)}
  }

  var oneofFloat: Float {
    get {
      if case .oneofFloat(let v)? = _storage._myOneof {return v}
      return 0
    }
    set {_uniqueStorage()._myOneof = .oneofFloat(newValue)}
  }

  var oneofString: String {
    get {
      if case .oneofString(let v)? = _storage._myOneof {return v}
      return String()
    }
    set {_uniqueStorage()._myOneof = .oneofString(newValue)}
  }

  var oneofBytes: Data {
    get {
      if case .oneofBytes(let v)? = _storage._myOneof {return v}
      return Data()
    }
    set {_uniqueStorage()._myOneof = .oneofBytes(newValue)}
  }

  var oneofEnum: A_B_C_TestEnum {
    get {
      if case .oneofEnum(let v)? = _storage._myOneof {return v}
      return .default
    }
    set {_uniqueStorage()._myOneof = .oneofEnum(newValue)}
  }

  var oneofMsg: A_B_C_TestMessage {
    get {
      if case .oneofMsg(let v)? = _storage._myOneof {return v}
      return A_B_C_TestMessage()
    }
    set {_uniqueStorage()._myOneof = .oneofMsg(newValue)}
  }

  var mapInt32String: Dictionary<Int32,String> {
    get {_storage._mapInt32String}
    set {_uniqueStorage()._mapInt32String = newValue}
  }

  var mapInt64String: Dictionary<Int64,String> {
    get {_storage._mapInt64String}
    set {_uniqueStorage()._mapInt64String = newValue}
  }

  var mapUint32String: Dictionary<UInt32,String> {
    get {_storage._mapUint32String}
    set {_uniqueStorage()._mapUint32String = newValue}
  }

  var mapUint64String: Dictionary<UInt64,String> {
    get {_storage._mapUint64String}
    set {_uniqueStorage()._mapUint64String = newValue}
  }

  var mapBoolString: Dictionary<Bool,String> {
    get {_storage._mapBoolString}
    set {_uniqueStorage()._mapBoolString = newValue}
  }

  var mapStringString: Dictionary<String,String> {
    get {_storage._mapStringString}
    set {_uniqueStorage()._mapStringString = newValue}
  }

  var mapStringMsg: Dictionary<String,A_B_C_TestMessage> {
    get {_storage._mapStringMsg}
    set {_uniqueStorage()._mapStringMsg = newValue}
  }

  var mapStringEnum: Dictionary<String,A_B_C_TestEnum> {
    get {_storage._mapStringEnum}
    set {_uniqueStorage()._mapStringEnum = newValue}
  }

  var mapStringInt32: Dictionary<String,Int32> {
    get {_storage._mapStringInt32}
    set {_uniqueStorage()._mapStringInt32 = newValue}
  }

  var mapStringBool: Dictionary<String,Bool> {
    get {_storage._mapStringBool}
    set {_uniqueStorage()._mapStringBool = newValue}
  }

  var nestedMessage: A_B_C_TestMessage.NestedMessage {
    get {_storage._nestedMessage ?? A_B_C_TestMessage.NestedMessage()}
    set {_uniqueStorage()._nestedMessage = newValue}
  }
  /// Returns true if `nestedMessage` has been explicitly set.
  var hasNestedMessage: Bool {_storage._nestedMessage != nil}
  /// Clears the value of `nestedMessage`. Subsequent reads from it will return its default value.
  mutating func clearNestedMessage() {_uniqueStorage()._nestedMessage = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_MyOneof: Equatable, Sendable {
    case oneofInt32(Int32)
    case oneofInt64(Int64)
    case oneofUint32(UInt32)
    case oneofUint64(UInt64)
    case oneofBool(Bool)
    case oneofDouble(Double)
    case oneofFloat(Float)
    case oneofString(String)
    case oneofBytes(Data)
    case oneofEnum(A_B_C_TestEnum)
    case oneofMsg(A_B_C_TestMessage)

  }

  struct NestedMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var foo: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "A.B.C"

extension A_B_C_TestEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0Default\0\u{1}A\0\u{1}B\0\u{1}C\0")
}

extension A_B_C_TestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TestMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}optional_int32\0\u{3}optional_int64\0\u{3}optional_uint32\0\u{3}optional_uint64\0\u{3}optional_bool\0\u{3}optional_double\0\u{3}optional_float\0\u{3}optional_string\0\u{3}optional_bytes\0\u{3}optional_enum\0\u{3}optional_msg\0\u{3}optional_proto2_submessage\0\u{4}\u{9}repeated_int32\0\u{3}repeated_int64\0\u{3}repeated_uint32\0\u{3}repeated_uint64\0\u{3}repeated_bool\0\u{3}repeated_double\0\u{3}repeated_float\0\u{3}repeated_string\0\u{3}repeated_bytes\0\u{3}repeated_enum\0\u{3}repeated_msg\0\u{4}\u{a}oneof_int32\0\u{3}oneof_int64\0\u{3}oneof_uint32\0\u{3}oneof_uint64\0\u{3}oneof_bool\0\u{3}oneof_double\0\u{3}oneof_float\0\u{3}oneof_string\0\u{3}oneof_bytes\0\u{3}oneof_enum\0\u{3}oneof_msg\0\u{4}\u{a}map_int32_string\0\u{3}map_int64_string\0\u{3}map_uint32_string\0\u{3}map_uint64_string\0\u{3}map_bool_string\0\u{3}map_string_string\0\u{3}map_string_msg\0\u{3}map_string_enum\0\u{3}map_string_int32\0\u{3}map_string_bool\0\u{4}\u{a}nested_message\0")

  fileprivate class _StorageClass {
    var _optionalInt32: Int32 = 0
    var _optionalInt64: Int64 = 0
    var _optionalUint32: UInt32 = 0
    var _optionalUint64: UInt64 = 0
    var _optionalBool: Bool = false
    var _optionalDouble: Double = 0
    var _optionalFloat: Float = 0
    var _optionalString: String = String()
    var _optionalBytes: Data = Data()
    var _optionalEnum: A_B_C_TestEnum = .default
    var _optionalMsg: A_B_C_TestMessage? = nil
    var _optionalProto2Submessage: A_B_C_TestImportedMessage? = nil
    var _repeatedInt32: [Int32] = []
    var _repeatedInt64: [Int64] = []
    var _repeatedUint32: [UInt32] = []
    var _repeatedUint64: [UInt64] = []
    var _repeatedBool: [Bool] = []
    var _repeatedDouble: [Double] = []
    var _repeatedFloat: [Float] = []
    var _repeatedString: [String] = []
    var _repeatedBytes: [Data] = []
    var _repeatedEnum: [A_B_C_TestEnum] = []
    var _repeatedMsg: [A_B_C_TestMessage] = []
    var _myOneof: A_B_C_TestMessage.OneOf_MyOneof?
    var _mapInt32String: Dictionary<Int32,String> = [:]
    var _mapInt64String: Dictionary<Int64,String> = [:]
    var _mapUint32String: Dictionary<UInt32,String> = [:]
    var _mapUint64String: Dictionary<UInt64,String> = [:]
    var _mapBoolString: Dictionary<Bool,String> = [:]
    var _mapStringString: Dictionary<String,String> = [:]
    var _mapStringMsg: Dictionary<String,A_B_C_TestMessage> = [:]
    var _mapStringEnum: Dictionary<String,A_B_C_TestEnum> = [:]
    var _mapStringInt32: Dictionary<String,Int32> = [:]
    var _mapStringBool: Dictionary<String,Bool> = [:]
    var _nestedMessage: A_B_C_TestMessage.NestedMessage? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _optionalInt32 = source._optionalInt32
      _optionalInt64 = source._optionalInt64
      _optionalUint32 = source._optionalUint32
      _optionalUint64 = source._optionalUint64
      _optionalBool = source._optionalBool
      _optionalDouble = source._optionalDouble
      _optionalFloat = source._optionalFloat
      _optionalString = source._optionalString
      _optionalBytes = source._optionalBytes
      _optionalEnum = source._optionalEnum
      _optionalMsg = source._optionalMsg
      _optionalProto2Submessage = source._optionalProto2Submessage
      _repeatedInt32 = source._repeatedInt32
      _repeatedInt64 = source._repeatedInt64
      _repeatedUint32 = source._repeatedUint32
      _repeatedUint64 = source._repeatedUint64
      _repeatedBool = source._repeatedBool
      _repeatedDouble = source._repeatedDouble
      _repeatedFloat = source._repeatedFloat
      _repeatedString = source._repeatedString
      _repeatedBytes = source._repeatedBytes
      _repeatedEnum = source._repeatedEnum
      _repeatedMsg = source._repeatedMsg
      _myOneof = source._myOneof
      _mapInt32String = source._mapInt32String
      _mapInt64String = source._mapInt64String
      _mapUint32String = source._mapUint32String
      _mapUint64String = source._mapUint64String
      _mapBoolString = source._mapBoolString
      _mapStringString = source._mapStringString
      _mapStringMsg = source._mapStringMsg
      _mapStringEnum = source._mapStringEnum
      _mapStringInt32 = source._mapStringInt32
      _mapStringBool = source._mapStringBool
      _nestedMessage = source._nestedMessage
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._optionalInt32) }()
        case 2: try { try decoder.decodeSingularInt64Field(value: &_storage._optionalInt64) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._optionalUint32) }()
        case 4: try { try decoder.decodeSingularUInt64Field(value: &_storage._optionalUint64) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._optionalBool) }()
        case 6: try { try decoder.decodeSingularDoubleField(value: &_storage._optionalDouble) }()
        case 7: try { try decoder.decodeSingularFloatField(value: &_storage._optionalFloat) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._optionalString) }()
        case 9: try { try decoder.decodeSingularBytesField(value: &_storage._optionalBytes) }()
        case 10: try { try decoder.decodeSingularEnumField(value: &_storage._optionalEnum) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._optionalMsg) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._optionalProto2Submessage) }()
        case 21: try { try decoder.decodeRepeatedInt32Field(value: &_storage._repeatedInt32) }()
        case 22: try { try decoder.decodeRepeatedInt64Field(value: &_storage._repeatedInt64) }()
        case 23: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._repeatedUint32) }()
        case 24: try { try decoder.decodeRepeatedUInt64Field(value: &_storage._repeatedUint64) }()
        case 25: try { try decoder.decodeRepeatedBoolField(value: &_storage._repeatedBool) }()
        case 26: try { try decoder.decodeRepeatedDoubleField(value: &_storage._repeatedDouble) }()
        case 27: try { try decoder.decodeRepeatedFloatField(value: &_storage._repeatedFloat) }()
        case 28: try { try decoder.decodeRepeatedStringField(value: &_storage._repeatedString) }()
        case 29: try { try decoder.decodeRepeatedBytesField(value: &_storage._repeatedBytes) }()
        case 30: try { try decoder.decodeRepeatedEnumField(value: &_storage._repeatedEnum) }()
        case 31: try { try decoder.decodeRepeatedMessageField(value: &_storage._repeatedMsg) }()
        case 41: try {
          var v: Int32?
          try decoder.decodeSingularInt32Field(value: &v)
          if let v = v {
            if _storage._myOneof != nil {try decoder.handleConflictingOneOf()}
            _storage._myOneof = .oneofInt32(v)
          }
        }()
        case 42: try {
          var v: Int64?
          try decoder.decodeSingularInt64Field(value: &v)
          if let v = v {
            if _storage._myOneof != nil {try decoder.handleConflictingOneOf()}
            _storage._myOneof = .oneofInt64(v)
          }
        }()
        case 43: try {
          var v: UInt32?
          try decoder.decodeSingularUInt32Field(value: &v)
          if let v = v {
            if _storage._myOneof != nil {try decoder.handleConflictingOneOf()}
            _storage._myOneof = .oneofUint32(v)
          }
        }()
        case 44: try {
          var v: UInt64?
          try decoder.decodeSingularUInt64Field(value: &v)
          if let v = v {
            if _storage._myOneof != nil {try decoder.handleConflictingOneOf()}
            _storage._myOneof = .oneofUint64(v)
          }
        }()
        case 45: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._myOneof != nil {try decoder.handleConflictingOneOf()}
            _storage._myOneof = .oneofBool(v)
          }
        }()
        case 46: try {
          var v: Double?
          try decoder.decodeSingularDoubleField(value: &v)
          if let v = v {
            if _storage._myOneof != nil {try decoder.handleConflictingOneOf()}
            _storage._myOneof = .oneofDouble(v)
          }
        }()
        case 47: try {
          var v: Float?
          try decoder.decodeSingularFloatField(value: &v)
          if let v = v {
            if _storage._myOneof != nil {try decoder.handleConflictingOneOf()}
            _storage._myOneof = .oneofFloat(v)
          }
        }()
        case 48: try {
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {
            if _storage._myOneof != nil {try decoder.handleConflictingOneOf()}
            _storage._myOneof = .oneofString(v)
          }
        }()
        case 49: try {
          var v: Data?
          try decoder.decodeSingularBytesField(value: &v)
          if let v = v {
            if _storage._myOneof != nil {try decoder.handleConflictingOneOf()}
            _storage._myOneof = .oneofBytes(v)
          }
        }()
        case 50: try {
          var v: A_B_C_TestEnum?
          try decoder.decodeSingularEnumField(value: &v)
          if let v = v {
            if _storage._myOneof != nil {try decoder.handleConflictingOneOf()}
            _storage._myOneof = .oneofEnum(v)
          }
        }()
        case 51: try {
          var v: A_B_C_TestMessage?
          var hadOneofValue = false
          if let current = _storage._myOneof {
            hadOneofValue = true
            if case .oneofMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._myOneof = .oneofMsg(v)
          }
        }()
        case 61: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt32,SwiftProtobuf.ProtobufString>.self, value: &_storage._mapInt32String) }()
        case 62: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt64,SwiftProtobuf.ProtobufString>.self, value: &_storage._mapInt64String) }()
        case 63: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufUInt32,SwiftProtobuf.ProtobufString>.self, value: &_storage._mapUint32String) }()
        case 64: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufUInt64,SwiftProtobuf.ProtobufString>.self, value: &_storage._mapUint64String) }()
        case 65: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufBool,SwiftProtobuf.ProtobufString>.self, value: &_storage._mapBoolString) }()
        case 66: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._mapStringString) }()
        case 67: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,A_B_C_TestMessage>.self, value: &_storage._mapStringMsg) }()
        case 68: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufEnumMap<SwiftProtobuf.ProtobufString,A_B_C_TestEnum>.self, value: &_storage._mapStringEnum) }()
        case 69: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt32>.self, value: &_storage._mapStringInt32) }()
        case 70: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBool>.self, value: &_storage._mapStringBool) }()
        case 80: try { try decoder.decodeSingularMessageField(value: &_storage._nestedMessage) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._optionalInt32 != 0 {
        try visitor.visitSingularInt32Field(value: _storage._optionalInt32, fieldNumber: 1)
      }
      if _storage._optionalInt64 != 0 {
        try visitor.visitSingularInt64Field(value: _storage._optionalInt64, fieldNumber: 2)
      }
      if _storage._optionalUint32 != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._optionalUint32, fieldNumber: 3)
      }
      if _storage._optionalUint64 != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._optionalUint64, fieldNumber: 4)
      }
      if _storage._optionalBool != false {
        try visitor.visitSingularBoolField(value: _storage._optionalBool, fieldNumber: 5)
      }
      if _storage._optionalDouble.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._optionalDouble, fieldNumber: 6)
      }
      if _storage._optionalFloat.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._optionalFloat, fieldNumber: 7)
      }
      if !_storage._optionalString.isEmpty {
        try visitor.visitSingularStringField(value: _storage._optionalString, fieldNumber: 8)
      }
      if !_storage._optionalBytes.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._optionalBytes, fieldNumber: 9)
      }
      if _storage._optionalEnum != .default {
        try visitor.visitSingularEnumField(value: _storage._optionalEnum, fieldNumber: 10)
      }
      try { if let v = _storage._optionalMsg {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._optionalProto2Submessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if !_storage._repeatedInt32.isEmpty {
        try visitor.visitPackedInt32Field(value: _storage._repeatedInt32, fieldNumber: 21)
      }
      if !_storage._repeatedInt64.isEmpty {
        try visitor.visitPackedInt64Field(value: _storage._repeatedInt64, fieldNumber: 22)
      }
      if !_storage._repeatedUint32.isEmpty {
        try visitor.visitPackedUInt32Field(value: _storage._repeatedUint32, fieldNumber: 23)
      }
      if !_storage._repeatedUint64.isEmpty {
        try visitor.visitPackedUInt64Field(value: _storage._repeatedUint64, fieldNumber: 24)
      }
      if !_storage._repeatedBool.isEmpty {
        try visitor.visitPackedBoolField(value: _storage._repeatedBool, fieldNumber: 25)
      }
      if !_storage._repeatedDouble.isEmpty {
        try visitor.visitPackedDoubleField(value: _storage._repeatedDouble, fieldNumber: 26)
      }
      if !_storage._repeatedFloat.isEmpty {
        try visitor.visitPackedFloatField(value: _storage._repeatedFloat, fieldNumber: 27)
      }
      if !_storage._repeatedString.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._repeatedString, fieldNumber: 28)
      }
      if !_storage._repeatedBytes.isEmpty {
        try visitor.visitRepeatedBytesField(value: _storage._repeatedBytes, fieldNumber: 29)
      }
      if !_storage._repeatedEnum.isEmpty {
        try visitor.visitPackedEnumField(value: _storage._repeatedEnum, fieldNumber: 30)
      }
      if !_storage._repeatedMsg.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._repeatedMsg, fieldNumber: 31)
      }
      switch _storage._myOneof {
      case .oneofInt32?: try {
        guard case .oneofInt32(let v)? = _storage._myOneof else { preconditionFailure() }
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 41)
      }()
      case .oneofInt64?: try {
        guard case .oneofInt64(let v)? = _storage._myOneof else { preconditionFailure() }
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 42)
      }()
      case .oneofUint32?: try {
        guard case .oneofUint32(let v)? = _storage._myOneof else { preconditionFailure() }
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 43)
      }()
      case .oneofUint64?: try {
        guard case .oneofUint64(let v)? = _storage._myOneof else { preconditionFailure() }
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 44)
      }()
      case .oneofBool?: try {
        guard case .oneofBool(let v)? = _storage._myOneof else { preconditionFailure() }
        try visitor.visitSingularBoolField(value: v, fieldNumber: 45)
      }()
      case .oneofDouble?: try {
        guard case .oneofDouble(let v)? = _storage._myOneof else { preconditionFailure() }
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 46)
      }()
      case .oneofFloat?: try {
        guard case .oneofFloat(let v)? = _storage._myOneof else { preconditionFailure() }
        try visitor.visitSingularFloatField(value: v, fieldNumber: 47)
      }()
      case .oneofString?: try {
        guard case .oneofString(let v)? = _storage._myOneof else { preconditionFailure() }
        try visitor.visitSingularStringField(value: v, fieldNumber: 48)
      }()
      case .oneofBytes?: try {
        guard case .oneofBytes(let v)? = _storage._myOneof else { preconditionFailure() }
        try visitor.visitSingularBytesField(value: v, fieldNumber: 49)
      }()
      case .oneofEnum?: try {
        guard case .oneofEnum(let v)? = _storage._myOneof else { preconditionFailure() }
        try visitor.visitSingularEnumField(value: v, fieldNumber: 50)
      }()
      case .oneofMsg?: try {
        guard case .oneofMsg(let v)? = _storage._myOneof else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
      }()
      case nil: break
      }
      if !_storage._mapInt32String.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt32,SwiftProtobuf.ProtobufString>.self, value: _storage._mapInt32String, fieldNumber: 61)
      }
      if !_storage._mapInt64String.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt64,SwiftProtobuf.ProtobufString>.self, value: _storage._mapInt64String, fieldNumber: 62)
      }
      if !_storage._mapUint32String.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufUInt32,SwiftProtobuf.ProtobufString>.self, value: _storage._mapUint32String, fieldNumber: 63)
      }
      if !_storage._mapUint64String.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufUInt64,SwiftProtobuf.ProtobufString>.self, value: _storage._mapUint64String, fieldNumber: 64)
      }
      if !_storage._mapBoolString.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufBool,SwiftProtobuf.ProtobufString>.self, value: _storage._mapBoolString, fieldNumber: 65)
      }
      if !_storage._mapStringString.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._mapStringString, fieldNumber: 66)
      }
      if !_storage._mapStringMsg.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,A_B_C_TestMessage>.self, value: _storage._mapStringMsg, fieldNumber: 67)
      }
      if !_storage._mapStringEnum.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufEnumMap<SwiftProtobuf.ProtobufString,A_B_C_TestEnum>.self, value: _storage._mapStringEnum, fieldNumber: 68)
      }
      if !_storage._mapStringInt32.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt32>.self, value: _storage._mapStringInt32, fieldNumber: 69)
      }
      if !_storage._mapStringBool.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBool>.self, value: _storage._mapStringBool, fieldNumber: 70)
      }
      try { if let v = _storage._nestedMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 80)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: A_B_C_TestMessage, rhs: A_B_C_TestMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._optionalInt32 != rhs_storage._optionalInt32 {return false}
        if _storage._optionalInt64 != rhs_storage._optionalInt64 {return false}
        if _storage._optionalUint32 != rhs_storage._optionalUint32 {return false}
        if _storage._optionalUint64 != rhs_storage._optionalUint64 {return false}
        if _storage._optionalBool != rhs_storage._optionalBool {return false}
        if _storage._optionalDouble != rhs_storage._optionalDouble {return false}
        if _storage._optionalFloat != rhs_storage._optionalFloat {return false}
        if _storage._optionalString != rhs_storage._optionalString {return false}
        if _storage._optionalBytes != rhs_storage._optionalBytes {return false}
        if _storage._optionalEnum != rhs_storage._optionalEnum {return false}
        if _storage._optionalMsg != rhs_storage._optionalMsg {return false}
        if _storage._optionalProto2Submessage != rhs_storage._optionalProto2Submessage {return false}
        if _storage._repeatedInt32 != rhs_storage._repeatedInt32 {return false}
        if _storage._repeatedInt64 != rhs_storage._repeatedInt64 {return false}
        if _storage._repeatedUint32 != rhs_storage._repeatedUint32 {return false}
        if _storage._repeatedUint64 != rhs_storage._repeatedUint64 {return false}
        if _storage._repeatedBool != rhs_storage._repeatedBool {return false}
        if _storage._repeatedDouble != rhs_storage._repeatedDouble {return false}
        if _storage._repeatedFloat != rhs_storage._repeatedFloat {return false}
        if _storage._repeatedString != rhs_storage._repeatedString {return false}
        if _storage._repeatedBytes != rhs_storage._repeatedBytes {return false}
        if _storage._repeatedEnum != rhs_storage._repeatedEnum {return false}
        if _storage._repeatedMsg != rhs_storage._repeatedMsg {return false}
        if _storage._myOneof != rhs_storage._myOneof {return false}
        if _storage._mapInt32String != rhs_storage._mapInt32String {return false}
        if _storage._mapInt64String != rhs_storage._mapInt64String {return false}
        if _storage._mapUint32String != rhs_storage._mapUint32String {return false}
        if _storage._mapUint64String != rhs_storage._mapUint64String {return false}
        if _storage._mapBoolString != rhs_storage._mapBoolString {return false}
        if _storage._mapStringString != rhs_storage._mapStringString {return false}
        if _storage._mapStringMsg != rhs_storage._mapStringMsg {return false}
        if _storage._mapStringEnum != rhs_storage._mapStringEnum {return false}
        if _storage._mapStringInt32 != rhs_storage._mapStringInt32 {return false}
        if _storage._mapStringBool != rhs_storage._mapStringBool {return false}
        if _storage._nestedMessage != rhs_storage._nestedMessage {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension A_B_C_TestMessage.NestedMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = A_B_C_TestMessage.protoMessageName + ".NestedMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}foo\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.foo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.foo != 0 {
      try visitor.visitSingularInt32Field(value: self.foo, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: A_B_C_TestMessage.NestedMessage, rhs: A_B_C_TestMessage.NestedMessage) -> Bool {
    if lhs.foo != rhs.foo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
