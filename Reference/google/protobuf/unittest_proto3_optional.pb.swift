// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/protobuf/unittest_proto3_optional.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct ProtobufUnittest_TestProto3Optional {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var optionalInt32: OneOf_OptionalInt32? {
    get {return _storage._optionalInt32}
    set {_uniqueStorage()._optionalInt32 = newValue}
  }

  /// Singular
  var optionalInt32: Int32 {
    get {
      if case .optionalInt32(let v)? = _storage._optionalInt32 {return v}
      return 0
    }
    set {_uniqueStorage()._optionalInt32 = .optionalInt32(newValue)}
  }

  var optionalInt64: OneOf_OptionalInt64? {
    get {return _storage._optionalInt64}
    set {_uniqueStorage()._optionalInt64 = newValue}
  }

  var optionalInt64: Int64 {
    get {
      if case .optionalInt64(let v)? = _storage._optionalInt64 {return v}
      return 0
    }
    set {_uniqueStorage()._optionalInt64 = .optionalInt64(newValue)}
  }

  var optionalUint32: OneOf_OptionalUint32? {
    get {return _storage._optionalUint32}
    set {_uniqueStorage()._optionalUint32 = newValue}
  }

  var optionalUint32: UInt32 {
    get {
      if case .optionalUint32(let v)? = _storage._optionalUint32 {return v}
      return 0
    }
    set {_uniqueStorage()._optionalUint32 = .optionalUint32(newValue)}
  }

  var optionalUint64: OneOf_OptionalUint64? {
    get {return _storage._optionalUint64}
    set {_uniqueStorage()._optionalUint64 = newValue}
  }

  var optionalUint64: UInt64 {
    get {
      if case .optionalUint64(let v)? = _storage._optionalUint64 {return v}
      return 0
    }
    set {_uniqueStorage()._optionalUint64 = .optionalUint64(newValue)}
  }

  var optionalSint32: OneOf_OptionalSint32? {
    get {return _storage._optionalSint32}
    set {_uniqueStorage()._optionalSint32 = newValue}
  }

  var optionalSint32: Int32 {
    get {
      if case .optionalSint32(let v)? = _storage._optionalSint32 {return v}
      return 0
    }
    set {_uniqueStorage()._optionalSint32 = .optionalSint32(newValue)}
  }

  var optionalSint64: OneOf_OptionalSint64? {
    get {return _storage._optionalSint64}
    set {_uniqueStorage()._optionalSint64 = newValue}
  }

  var optionalSint64: Int64 {
    get {
      if case .optionalSint64(let v)? = _storage._optionalSint64 {return v}
      return 0
    }
    set {_uniqueStorage()._optionalSint64 = .optionalSint64(newValue)}
  }

  var optionalFixed32: OneOf_OptionalFixed32? {
    get {return _storage._optionalFixed32}
    set {_uniqueStorage()._optionalFixed32 = newValue}
  }

  var optionalFixed32: UInt32 {
    get {
      if case .optionalFixed32(let v)? = _storage._optionalFixed32 {return v}
      return 0
    }
    set {_uniqueStorage()._optionalFixed32 = .optionalFixed32(newValue)}
  }

  var optionalFixed64: OneOf_OptionalFixed64? {
    get {return _storage._optionalFixed64}
    set {_uniqueStorage()._optionalFixed64 = newValue}
  }

  var optionalFixed64: UInt64 {
    get {
      if case .optionalFixed64(let v)? = _storage._optionalFixed64 {return v}
      return 0
    }
    set {_uniqueStorage()._optionalFixed64 = .optionalFixed64(newValue)}
  }

  var optionalSfixed32: OneOf_OptionalSfixed32? {
    get {return _storage._optionalSfixed32}
    set {_uniqueStorage()._optionalSfixed32 = newValue}
  }

  var optionalSfixed32: Int32 {
    get {
      if case .optionalSfixed32(let v)? = _storage._optionalSfixed32 {return v}
      return 0
    }
    set {_uniqueStorage()._optionalSfixed32 = .optionalSfixed32(newValue)}
  }

  var optionalSfixed64: OneOf_OptionalSfixed64? {
    get {return _storage._optionalSfixed64}
    set {_uniqueStorage()._optionalSfixed64 = newValue}
  }

  var optionalSfixed64: Int64 {
    get {
      if case .optionalSfixed64(let v)? = _storage._optionalSfixed64 {return v}
      return 0
    }
    set {_uniqueStorage()._optionalSfixed64 = .optionalSfixed64(newValue)}
  }

  var optionalFloat: OneOf_OptionalFloat? {
    get {return _storage._optionalFloat}
    set {_uniqueStorage()._optionalFloat = newValue}
  }

  var optionalFloat: Float {
    get {
      if case .optionalFloat(let v)? = _storage._optionalFloat {return v}
      return 0
    }
    set {_uniqueStorage()._optionalFloat = .optionalFloat(newValue)}
  }

  var optionalDouble: OneOf_OptionalDouble? {
    get {return _storage._optionalDouble}
    set {_uniqueStorage()._optionalDouble = newValue}
  }

  var optionalDouble: Double {
    get {
      if case .optionalDouble(let v)? = _storage._optionalDouble {return v}
      return 0
    }
    set {_uniqueStorage()._optionalDouble = .optionalDouble(newValue)}
  }

  var optionalBool: OneOf_OptionalBool? {
    get {return _storage._optionalBool}
    set {_uniqueStorage()._optionalBool = newValue}
  }

  var optionalBool: Bool {
    get {
      if case .optionalBool(let v)? = _storage._optionalBool {return v}
      return false
    }
    set {_uniqueStorage()._optionalBool = .optionalBool(newValue)}
  }

  var optionalString: OneOf_OptionalString? {
    get {return _storage._optionalString}
    set {_uniqueStorage()._optionalString = newValue}
  }

  var optionalString: String {
    get {
      if case .optionalString(let v)? = _storage._optionalString {return v}
      return String()
    }
    set {_uniqueStorage()._optionalString = .optionalString(newValue)}
  }

  var optionalBytes: OneOf_OptionalBytes? {
    get {return _storage._optionalBytes}
    set {_uniqueStorage()._optionalBytes = newValue}
  }

  var optionalBytes: Data {
    get {
      if case .optionalBytes(let v)? = _storage._optionalBytes {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {_uniqueStorage()._optionalBytes = .optionalBytes(newValue)}
  }

  var optionalCord: OneOf_OptionalCord? {
    get {return _storage._optionalCord}
    set {_uniqueStorage()._optionalCord = newValue}
  }

  var optionalCord: String {
    get {
      if case .optionalCord(let v)? = _storage._optionalCord {return v}
      return String()
    }
    set {_uniqueStorage()._optionalCord = .optionalCord(newValue)}
  }

  var optionalNestedMessage: OneOf_OptionalNestedMessage? {
    get {return _storage._optionalNestedMessage}
    set {_uniqueStorage()._optionalNestedMessage = newValue}
  }

  var optionalNestedMessage: ProtobufUnittest_TestProto3Optional.NestedMessage {
    get {
      if case .optionalNestedMessage(let v)? = _storage._optionalNestedMessage {return v}
      return ProtobufUnittest_TestProto3Optional.NestedMessage()
    }
    set {_uniqueStorage()._optionalNestedMessage = .optionalNestedMessage(newValue)}
  }

  var lazyNestedMessage: OneOf_LazyNestedMessage? {
    get {return _storage._lazyNestedMessage}
    set {_uniqueStorage()._lazyNestedMessage = newValue}
  }

  var lazyNestedMessage: ProtobufUnittest_TestProto3Optional.NestedMessage {
    get {
      if case .lazyNestedMessage(let v)? = _storage._lazyNestedMessage {return v}
      return ProtobufUnittest_TestProto3Optional.NestedMessage()
    }
    set {_uniqueStorage()._lazyNestedMessage = .lazyNestedMessage(newValue)}
  }

  var optionalNestedEnum: OneOf_OptionalNestedEnum? {
    get {return _storage._optionalNestedEnum}
    set {_uniqueStorage()._optionalNestedEnum = newValue}
  }

  var optionalNestedEnum: ProtobufUnittest_TestProto3Optional.NestedEnum {
    get {
      if case .optionalNestedEnum(let v)? = _storage._optionalNestedEnum {return v}
      return .unspecified
    }
    set {_uniqueStorage()._optionalNestedEnum = .optionalNestedEnum(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_OptionalInt32: Equatable {
    /// Singular
    case optionalInt32(Int32)

  #if !swift(>=4.1)
    static func ==(lhs: ProtobufUnittest_TestProto3Optional.OneOf_OptionalInt32, rhs: ProtobufUnittest_TestProto3Optional.OneOf_OptionalInt32) -> Bool {
      switch (lhs, rhs) {
      case (.optionalInt32(let l), .optionalInt32(let r)): return l == r
      }
    }
  #endif
  }

  enum OneOf_OptionalInt64: Equatable {
    case optionalInt64(Int64)

  #if !swift(>=4.1)
    static func ==(lhs: ProtobufUnittest_TestProto3Optional.OneOf_OptionalInt64, rhs: ProtobufUnittest_TestProto3Optional.OneOf_OptionalInt64) -> Bool {
      switch (lhs, rhs) {
      case (.optionalInt64(let l), .optionalInt64(let r)): return l == r
      }
    }
  #endif
  }

  enum OneOf_OptionalUint32: Equatable {
    case optionalUint32(UInt32)

  #if !swift(>=4.1)
    static func ==(lhs: ProtobufUnittest_TestProto3Optional.OneOf_OptionalUint32, rhs: ProtobufUnittest_TestProto3Optional.OneOf_OptionalUint32) -> Bool {
      switch (lhs, rhs) {
      case (.optionalUint32(let l), .optionalUint32(let r)): return l == r
      }
    }
  #endif
  }

  enum OneOf_OptionalUint64: Equatable {
    case optionalUint64(UInt64)

  #if !swift(>=4.1)
    static func ==(lhs: ProtobufUnittest_TestProto3Optional.OneOf_OptionalUint64, rhs: ProtobufUnittest_TestProto3Optional.OneOf_OptionalUint64) -> Bool {
      switch (lhs, rhs) {
      case (.optionalUint64(let l), .optionalUint64(let r)): return l == r
      }
    }
  #endif
  }

  enum OneOf_OptionalSint32: Equatable {
    case optionalSint32(Int32)

  #if !swift(>=4.1)
    static func ==(lhs: ProtobufUnittest_TestProto3Optional.OneOf_OptionalSint32, rhs: ProtobufUnittest_TestProto3Optional.OneOf_OptionalSint32) -> Bool {
      switch (lhs, rhs) {
      case (.optionalSint32(let l), .optionalSint32(let r)): return l == r
      }
    }
  #endif
  }

  enum OneOf_OptionalSint64: Equatable {
    case optionalSint64(Int64)

  #if !swift(>=4.1)
    static func ==(lhs: ProtobufUnittest_TestProto3Optional.OneOf_OptionalSint64, rhs: ProtobufUnittest_TestProto3Optional.OneOf_OptionalSint64) -> Bool {
      switch (lhs, rhs) {
      case (.optionalSint64(let l), .optionalSint64(let r)): return l == r
      }
    }
  #endif
  }

  enum OneOf_OptionalFixed32: Equatable {
    case optionalFixed32(UInt32)

  #if !swift(>=4.1)
    static func ==(lhs: ProtobufUnittest_TestProto3Optional.OneOf_OptionalFixed32, rhs: ProtobufUnittest_TestProto3Optional.OneOf_OptionalFixed32) -> Bool {
      switch (lhs, rhs) {
      case (.optionalFixed32(let l), .optionalFixed32(let r)): return l == r
      }
    }
  #endif
  }

  enum OneOf_OptionalFixed64: Equatable {
    case optionalFixed64(UInt64)

  #if !swift(>=4.1)
    static func ==(lhs: ProtobufUnittest_TestProto3Optional.OneOf_OptionalFixed64, rhs: ProtobufUnittest_TestProto3Optional.OneOf_OptionalFixed64) -> Bool {
      switch (lhs, rhs) {
      case (.optionalFixed64(let l), .optionalFixed64(let r)): return l == r
      }
    }
  #endif
  }

  enum OneOf_OptionalSfixed32: Equatable {
    case optionalSfixed32(Int32)

  #if !swift(>=4.1)
    static func ==(lhs: ProtobufUnittest_TestProto3Optional.OneOf_OptionalSfixed32, rhs: ProtobufUnittest_TestProto3Optional.OneOf_OptionalSfixed32) -> Bool {
      switch (lhs, rhs) {
      case (.optionalSfixed32(let l), .optionalSfixed32(let r)): return l == r
      }
    }
  #endif
  }

  enum OneOf_OptionalSfixed64: Equatable {
    case optionalSfixed64(Int64)

  #if !swift(>=4.1)
    static func ==(lhs: ProtobufUnittest_TestProto3Optional.OneOf_OptionalSfixed64, rhs: ProtobufUnittest_TestProto3Optional.OneOf_OptionalSfixed64) -> Bool {
      switch (lhs, rhs) {
      case (.optionalSfixed64(let l), .optionalSfixed64(let r)): return l == r
      }
    }
  #endif
  }

  enum OneOf_OptionalFloat: Equatable {
    case optionalFloat(Float)

  #if !swift(>=4.1)
    static func ==(lhs: ProtobufUnittest_TestProto3Optional.OneOf_OptionalFloat, rhs: ProtobufUnittest_TestProto3Optional.OneOf_OptionalFloat) -> Bool {
      switch (lhs, rhs) {
      case (.optionalFloat(let l), .optionalFloat(let r)): return l == r
      }
    }
  #endif
  }

  enum OneOf_OptionalDouble: Equatable {
    case optionalDouble(Double)

  #if !swift(>=4.1)
    static func ==(lhs: ProtobufUnittest_TestProto3Optional.OneOf_OptionalDouble, rhs: ProtobufUnittest_TestProto3Optional.OneOf_OptionalDouble) -> Bool {
      switch (lhs, rhs) {
      case (.optionalDouble(let l), .optionalDouble(let r)): return l == r
      }
    }
  #endif
  }

  enum OneOf_OptionalBool: Equatable {
    case optionalBool(Bool)

  #if !swift(>=4.1)
    static func ==(lhs: ProtobufUnittest_TestProto3Optional.OneOf_OptionalBool, rhs: ProtobufUnittest_TestProto3Optional.OneOf_OptionalBool) -> Bool {
      switch (lhs, rhs) {
      case (.optionalBool(let l), .optionalBool(let r)): return l == r
      }
    }
  #endif
  }

  enum OneOf_OptionalString: Equatable {
    case optionalString(String)

  #if !swift(>=4.1)
    static func ==(lhs: ProtobufUnittest_TestProto3Optional.OneOf_OptionalString, rhs: ProtobufUnittest_TestProto3Optional.OneOf_OptionalString) -> Bool {
      switch (lhs, rhs) {
      case (.optionalString(let l), .optionalString(let r)): return l == r
      }
    }
  #endif
  }

  enum OneOf_OptionalBytes: Equatable {
    case optionalBytes(Data)

  #if !swift(>=4.1)
    static func ==(lhs: ProtobufUnittest_TestProto3Optional.OneOf_OptionalBytes, rhs: ProtobufUnittest_TestProto3Optional.OneOf_OptionalBytes) -> Bool {
      switch (lhs, rhs) {
      case (.optionalBytes(let l), .optionalBytes(let r)): return l == r
      }
    }
  #endif
  }

  enum OneOf_OptionalCord: Equatable {
    case optionalCord(String)

  #if !swift(>=4.1)
    static func ==(lhs: ProtobufUnittest_TestProto3Optional.OneOf_OptionalCord, rhs: ProtobufUnittest_TestProto3Optional.OneOf_OptionalCord) -> Bool {
      switch (lhs, rhs) {
      case (.optionalCord(let l), .optionalCord(let r)): return l == r
      }
    }
  #endif
  }

  enum OneOf_OptionalNestedMessage: Equatable {
    case optionalNestedMessage(ProtobufUnittest_TestProto3Optional.NestedMessage)

  #if !swift(>=4.1)
    static func ==(lhs: ProtobufUnittest_TestProto3Optional.OneOf_OptionalNestedMessage, rhs: ProtobufUnittest_TestProto3Optional.OneOf_OptionalNestedMessage) -> Bool {
      switch (lhs, rhs) {
      case (.optionalNestedMessage(let l), .optionalNestedMessage(let r)): return l == r
      }
    }
  #endif
  }

  enum OneOf_LazyNestedMessage: Equatable {
    case lazyNestedMessage(ProtobufUnittest_TestProto3Optional.NestedMessage)

  #if !swift(>=4.1)
    static func ==(lhs: ProtobufUnittest_TestProto3Optional.OneOf_LazyNestedMessage, rhs: ProtobufUnittest_TestProto3Optional.OneOf_LazyNestedMessage) -> Bool {
      switch (lhs, rhs) {
      case (.lazyNestedMessage(let l), .lazyNestedMessage(let r)): return l == r
      }
    }
  #endif
  }

  enum OneOf_OptionalNestedEnum: Equatable {
    case optionalNestedEnum(ProtobufUnittest_TestProto3Optional.NestedEnum)

  #if !swift(>=4.1)
    static func ==(lhs: ProtobufUnittest_TestProto3Optional.OneOf_OptionalNestedEnum, rhs: ProtobufUnittest_TestProto3Optional.OneOf_OptionalNestedEnum) -> Bool {
      switch (lhs, rhs) {
      case (.optionalNestedEnum(let l), .optionalNestedEnum(let r)): return l == r
      }
    }
  #endif
  }

  enum NestedEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unspecified // = 0
    case foo // = 1
    case bar // = 2
    case baz // = 3

    /// Intentionally negative.
    case neg // = -1
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case -1: self = .neg
      case 0: self = .unspecified
      case 1: self = .foo
      case 2: self = .bar
      case 3: self = .baz
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .neg: return -1
      case .unspecified: return 0
      case .foo: return 1
      case .bar: return 2
      case .baz: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  struct NestedMessage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var bb: ProtobufUnittest_TestProto3Optional.NestedMessage.OneOf_Bb? = nil

    /// The field name "b" fails to compile in proto1 because it conflicts with
    /// a local variable named "b" in one of the generated methods.  Doh.
    /// This file needs to compile in proto1 to test backwards-compatibility.
    var bb: Int32 {
      get {
        if case .bb(let v)? = bb {return v}
        return 0
      }
      set {bb = .bb(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Bb: Equatable {
      /// The field name "b" fails to compile in proto1 because it conflicts with
      /// a local variable named "b" in one of the generated methods.  Doh.
      /// This file needs to compile in proto1 to test backwards-compatibility.
      case bb(Int32)

    #if !swift(>=4.1)
      static func ==(lhs: ProtobufUnittest_TestProto3Optional.NestedMessage.OneOf_Bb, rhs: ProtobufUnittest_TestProto3Optional.NestedMessage.OneOf_Bb) -> Bool {
        switch (lhs, rhs) {
        case (.bb(let l), .bb(let r)): return l == r
        }
      }
    #endif
    }

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension ProtobufUnittest_TestProto3Optional.NestedEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [ProtobufUnittest_TestProto3Optional.NestedEnum] = [
    .unspecified,
    .foo,
    .bar,
    .baz,
    .neg,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "protobuf_unittest"

extension ProtobufUnittest_TestProto3Optional: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TestProto3Optional"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "optional_int32"),
    2: .standard(proto: "optional_int64"),
    3: .standard(proto: "optional_uint32"),
    4: .standard(proto: "optional_uint64"),
    5: .standard(proto: "optional_sint32"),
    6: .standard(proto: "optional_sint64"),
    7: .standard(proto: "optional_fixed32"),
    8: .standard(proto: "optional_fixed64"),
    9: .standard(proto: "optional_sfixed32"),
    10: .standard(proto: "optional_sfixed64"),
    11: .standard(proto: "optional_float"),
    12: .standard(proto: "optional_double"),
    13: .standard(proto: "optional_bool"),
    14: .standard(proto: "optional_string"),
    15: .standard(proto: "optional_bytes"),
    16: .standard(proto: "optional_cord"),
    18: .standard(proto: "optional_nested_message"),
    19: .standard(proto: "lazy_nested_message"),
    21: .standard(proto: "optional_nested_enum"),
  ]

  fileprivate class _StorageClass {
    var _optionalInt32: ProtobufUnittest_TestProto3Optional.OneOf_OptionalInt32?
    var _optionalInt64: ProtobufUnittest_TestProto3Optional.OneOf_OptionalInt64?
    var _optionalUint32: ProtobufUnittest_TestProto3Optional.OneOf_OptionalUint32?
    var _optionalUint64: ProtobufUnittest_TestProto3Optional.OneOf_OptionalUint64?
    var _optionalSint32: ProtobufUnittest_TestProto3Optional.OneOf_OptionalSint32?
    var _optionalSint64: ProtobufUnittest_TestProto3Optional.OneOf_OptionalSint64?
    var _optionalFixed32: ProtobufUnittest_TestProto3Optional.OneOf_OptionalFixed32?
    var _optionalFixed64: ProtobufUnittest_TestProto3Optional.OneOf_OptionalFixed64?
    var _optionalSfixed32: ProtobufUnittest_TestProto3Optional.OneOf_OptionalSfixed32?
    var _optionalSfixed64: ProtobufUnittest_TestProto3Optional.OneOf_OptionalSfixed64?
    var _optionalFloat: ProtobufUnittest_TestProto3Optional.OneOf_OptionalFloat?
    var _optionalDouble: ProtobufUnittest_TestProto3Optional.OneOf_OptionalDouble?
    var _optionalBool: ProtobufUnittest_TestProto3Optional.OneOf_OptionalBool?
    var _optionalString: ProtobufUnittest_TestProto3Optional.OneOf_OptionalString?
    var _optionalBytes: ProtobufUnittest_TestProto3Optional.OneOf_OptionalBytes?
    var _optionalCord: ProtobufUnittest_TestProto3Optional.OneOf_OptionalCord?
    var _optionalNestedMessage: ProtobufUnittest_TestProto3Optional.OneOf_OptionalNestedMessage?
    var _lazyNestedMessage: ProtobufUnittest_TestProto3Optional.OneOf_LazyNestedMessage?
    var _optionalNestedEnum: ProtobufUnittest_TestProto3Optional.OneOf_OptionalNestedEnum?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _optionalInt32 = source._optionalInt32
      _optionalInt64 = source._optionalInt64
      _optionalUint32 = source._optionalUint32
      _optionalUint64 = source._optionalUint64
      _optionalSint32 = source._optionalSint32
      _optionalSint64 = source._optionalSint64
      _optionalFixed32 = source._optionalFixed32
      _optionalFixed64 = source._optionalFixed64
      _optionalSfixed32 = source._optionalSfixed32
      _optionalSfixed64 = source._optionalSfixed64
      _optionalFloat = source._optionalFloat
      _optionalDouble = source._optionalDouble
      _optionalBool = source._optionalBool
      _optionalString = source._optionalString
      _optionalBytes = source._optionalBytes
      _optionalCord = source._optionalCord
      _optionalNestedMessage = source._optionalNestedMessage
      _lazyNestedMessage = source._lazyNestedMessage
      _optionalNestedEnum = source._optionalNestedEnum
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          if _storage._optionalInt32 != nil {try decoder.handleConflictingOneOf()}
          var v: Int32?
          try decoder.decodeSingularInt32Field(value: &v)
          if let v = v {_storage._optionalInt32 = .optionalInt32(v)}
        case 2:
          if _storage._optionalInt64 != nil {try decoder.handleConflictingOneOf()}
          var v: Int64?
          try decoder.decodeSingularInt64Field(value: &v)
          if let v = v {_storage._optionalInt64 = .optionalInt64(v)}
        case 3:
          if _storage._optionalUint32 != nil {try decoder.handleConflictingOneOf()}
          var v: UInt32?
          try decoder.decodeSingularUInt32Field(value: &v)
          if let v = v {_storage._optionalUint32 = .optionalUint32(v)}
        case 4:
          if _storage._optionalUint64 != nil {try decoder.handleConflictingOneOf()}
          var v: UInt64?
          try decoder.decodeSingularUInt64Field(value: &v)
          if let v = v {_storage._optionalUint64 = .optionalUint64(v)}
        case 5:
          if _storage._optionalSint32 != nil {try decoder.handleConflictingOneOf()}
          var v: Int32?
          try decoder.decodeSingularSInt32Field(value: &v)
          if let v = v {_storage._optionalSint32 = .optionalSint32(v)}
        case 6:
          if _storage._optionalSint64 != nil {try decoder.handleConflictingOneOf()}
          var v: Int64?
          try decoder.decodeSingularSInt64Field(value: &v)
          if let v = v {_storage._optionalSint64 = .optionalSint64(v)}
        case 7:
          if _storage._optionalFixed32 != nil {try decoder.handleConflictingOneOf()}
          var v: UInt32?
          try decoder.decodeSingularFixed32Field(value: &v)
          if let v = v {_storage._optionalFixed32 = .optionalFixed32(v)}
        case 8:
          if _storage._optionalFixed64 != nil {try decoder.handleConflictingOneOf()}
          var v: UInt64?
          try decoder.decodeSingularFixed64Field(value: &v)
          if let v = v {_storage._optionalFixed64 = .optionalFixed64(v)}
        case 9:
          if _storage._optionalSfixed32 != nil {try decoder.handleConflictingOneOf()}
          var v: Int32?
          try decoder.decodeSingularSFixed32Field(value: &v)
          if let v = v {_storage._optionalSfixed32 = .optionalSfixed32(v)}
        case 10:
          if _storage._optionalSfixed64 != nil {try decoder.handleConflictingOneOf()}
          var v: Int64?
          try decoder.decodeSingularSFixed64Field(value: &v)
          if let v = v {_storage._optionalSfixed64 = .optionalSfixed64(v)}
        case 11:
          if _storage._optionalFloat != nil {try decoder.handleConflictingOneOf()}
          var v: Float?
          try decoder.decodeSingularFloatField(value: &v)
          if let v = v {_storage._optionalFloat = .optionalFloat(v)}
        case 12:
          if _storage._optionalDouble != nil {try decoder.handleConflictingOneOf()}
          var v: Double?
          try decoder.decodeSingularDoubleField(value: &v)
          if let v = v {_storage._optionalDouble = .optionalDouble(v)}
        case 13:
          if _storage._optionalBool != nil {try decoder.handleConflictingOneOf()}
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {_storage._optionalBool = .optionalBool(v)}
        case 14:
          if _storage._optionalString != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._optionalString = .optionalString(v)}
        case 15:
          if _storage._optionalBytes != nil {try decoder.handleConflictingOneOf()}
          var v: Data?
          try decoder.decodeSingularBytesField(value: &v)
          if let v = v {_storage._optionalBytes = .optionalBytes(v)}
        case 16:
          if _storage._optionalCord != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._optionalCord = .optionalCord(v)}
        case 18:
          var v: ProtobufUnittest_TestProto3Optional.NestedMessage?
          if let current = _storage._optionalNestedMessage {
            try decoder.handleConflictingOneOf()
            if case .optionalNestedMessage(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._optionalNestedMessage = .optionalNestedMessage(v)}
        case 19:
          var v: ProtobufUnittest_TestProto3Optional.NestedMessage?
          if let current = _storage._lazyNestedMessage {
            try decoder.handleConflictingOneOf()
            if case .lazyNestedMessage(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._lazyNestedMessage = .lazyNestedMessage(v)}
        case 21:
          if _storage._optionalNestedEnum != nil {try decoder.handleConflictingOneOf()}
          var v: ProtobufUnittest_TestProto3Optional.NestedEnum?
          try decoder.decodeSingularEnumField(value: &v)
          if let v = v {_storage._optionalNestedEnum = .optionalNestedEnum(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if case .optionalInt32(let v)? = _storage._optionalInt32 {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
      }
      if case .optionalInt64(let v)? = _storage._optionalInt64 {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
      }
      if case .optionalUint32(let v)? = _storage._optionalUint32 {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
      }
      if case .optionalUint64(let v)? = _storage._optionalUint64 {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
      }
      if case .optionalSint32(let v)? = _storage._optionalSint32 {
        try visitor.visitSingularSInt32Field(value: v, fieldNumber: 5)
      }
      if case .optionalSint64(let v)? = _storage._optionalSint64 {
        try visitor.visitSingularSInt64Field(value: v, fieldNumber: 6)
      }
      if case .optionalFixed32(let v)? = _storage._optionalFixed32 {
        try visitor.visitSingularFixed32Field(value: v, fieldNumber: 7)
      }
      if case .optionalFixed64(let v)? = _storage._optionalFixed64 {
        try visitor.visitSingularFixed64Field(value: v, fieldNumber: 8)
      }
      if case .optionalSfixed32(let v)? = _storage._optionalSfixed32 {
        try visitor.visitSingularSFixed32Field(value: v, fieldNumber: 9)
      }
      if case .optionalSfixed64(let v)? = _storage._optionalSfixed64 {
        try visitor.visitSingularSFixed64Field(value: v, fieldNumber: 10)
      }
      if case .optionalFloat(let v)? = _storage._optionalFloat {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 11)
      }
      if case .optionalDouble(let v)? = _storage._optionalDouble {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 12)
      }
      if case .optionalBool(let v)? = _storage._optionalBool {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 13)
      }
      if case .optionalString(let v)? = _storage._optionalString {
        try visitor.visitSingularStringField(value: v, fieldNumber: 14)
      }
      if case .optionalBytes(let v)? = _storage._optionalBytes {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 15)
      }
      if case .optionalCord(let v)? = _storage._optionalCord {
        try visitor.visitSingularStringField(value: v, fieldNumber: 16)
      }
      if case .optionalNestedMessage(let v)? = _storage._optionalNestedMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }
      if case .lazyNestedMessage(let v)? = _storage._lazyNestedMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }
      if case .optionalNestedEnum(let v)? = _storage._optionalNestedEnum {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 21)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtobufUnittest_TestProto3Optional, rhs: ProtobufUnittest_TestProto3Optional) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._optionalInt32 != rhs_storage._optionalInt32 {return false}
        if _storage._optionalInt64 != rhs_storage._optionalInt64 {return false}
        if _storage._optionalUint32 != rhs_storage._optionalUint32 {return false}
        if _storage._optionalUint64 != rhs_storage._optionalUint64 {return false}
        if _storage._optionalSint32 != rhs_storage._optionalSint32 {return false}
        if _storage._optionalSint64 != rhs_storage._optionalSint64 {return false}
        if _storage._optionalFixed32 != rhs_storage._optionalFixed32 {return false}
        if _storage._optionalFixed64 != rhs_storage._optionalFixed64 {return false}
        if _storage._optionalSfixed32 != rhs_storage._optionalSfixed32 {return false}
        if _storage._optionalSfixed64 != rhs_storage._optionalSfixed64 {return false}
        if _storage._optionalFloat != rhs_storage._optionalFloat {return false}
        if _storage._optionalDouble != rhs_storage._optionalDouble {return false}
        if _storage._optionalBool != rhs_storage._optionalBool {return false}
        if _storage._optionalString != rhs_storage._optionalString {return false}
        if _storage._optionalBytes != rhs_storage._optionalBytes {return false}
        if _storage._optionalCord != rhs_storage._optionalCord {return false}
        if _storage._optionalNestedMessage != rhs_storage._optionalNestedMessage {return false}
        if _storage._lazyNestedMessage != rhs_storage._lazyNestedMessage {return false}
        if _storage._optionalNestedEnum != rhs_storage._optionalNestedEnum {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtobufUnittest_TestProto3Optional.NestedEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    -1: .same(proto: "NEG"),
    0: .same(proto: "UNSPECIFIED"),
    1: .same(proto: "FOO"),
    2: .same(proto: "BAR"),
    3: .same(proto: "BAZ"),
  ]
}

extension ProtobufUnittest_TestProto3Optional.NestedMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = ProtobufUnittest_TestProto3Optional.protoMessageName + ".NestedMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bb"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        if self.bb != nil {try decoder.handleConflictingOneOf()}
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {self.bb = .bb(v)}
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .bb(let v)? = self.bb {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtobufUnittest_TestProto3Optional.NestedMessage, rhs: ProtobufUnittest_TestProto3Optional.NestedMessage) -> Bool {
    if lhs.bb != rhs.bb {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
