// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/protobuf/descriptor.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Author: kenton@google.com (Kenton Varda)
//  Based on original Protocol Buffers design by
//  Sanjay Ghemawat, Jeff Dean, and others.
//
// The messages in this file describe the definitions found in .proto files.
// A valid .proto file can be translated directly to a FileDescriptorProto
// without any other information (e.g. without reading its imports).

import Foundation

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The protocol compiler can output a FileDescriptorSet containing the .proto
/// files it parses.
struct Google_Protobuf_FileDescriptorSet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var file: [Google_Protobuf_FileDescriptorProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Describes a complete .proto file.
struct Google_Protobuf_FileDescriptorProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// file name, relative to root of source tree
  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  /// e.g. "foo", "foo.bar", etc.
  var package: String {
    get {return _package ?? String()}
    set {_package = newValue}
  }
  /// Returns true if `package` has been explicitly set.
  var hasPackage: Bool {return self._package != nil}
  /// Clears the value of `package`. Subsequent reads from it will return its default value.
  mutating func clearPackage() {self._package = nil}

  /// Names of files imported by this file.
  var dependency: [String] = []

  /// Indexes of the public imported files in the dependency list above.
  var publicDependency: [Int32] = []

  /// Indexes of the weak imported files in the dependency list.
  /// For Google-internal migration only. Do not use.
  var weakDependency: [Int32] = []

  /// All top-level definitions in this file.
  var messageType: [Google_Protobuf_DescriptorProto] = []

  var enumType: [Google_Protobuf_EnumDescriptorProto] = []

  var service: [Google_Protobuf_ServiceDescriptorProto] = []

  var `extension`: [Google_Protobuf_FieldDescriptorProto] = []

  var options: Google_Protobuf_FileOptions {
    get {return _options ?? Google_Protobuf_FileOptions()}
    set {_options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  var hasOptions: Bool {return self._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  mutating func clearOptions() {self._options = nil}

  /// This field contains optional information about the original source code.
  /// You may safely remove this entire field without harming runtime
  /// functionality of the descriptors -- the information is needed only by
  /// development tools.
  var sourceCodeInfo: Google_Protobuf_SourceCodeInfo {
    get {return _sourceCodeInfo ?? Google_Protobuf_SourceCodeInfo()}
    set {_sourceCodeInfo = newValue}
  }
  /// Returns true if `sourceCodeInfo` has been explicitly set.
  var hasSourceCodeInfo: Bool {return self._sourceCodeInfo != nil}
  /// Clears the value of `sourceCodeInfo`. Subsequent reads from it will return its default value.
  mutating func clearSourceCodeInfo() {self._sourceCodeInfo = nil}

  /// The syntax of the proto file.
  /// The supported values are "proto2" and "proto3".
  var syntax: String {
    get {return _syntax ?? String()}
    set {_syntax = newValue}
  }
  /// Returns true if `syntax` has been explicitly set.
  var hasSyntax: Bool {return self._syntax != nil}
  /// Clears the value of `syntax`. Subsequent reads from it will return its default value.
  mutating func clearSyntax() {self._syntax = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _name: String? = nil
  fileprivate var _package: String? = nil
  fileprivate var _options: Google_Protobuf_FileOptions? = nil
  fileprivate var _sourceCodeInfo: Google_Protobuf_SourceCodeInfo? = nil
  fileprivate var _syntax: String? = nil
}

/// Describes a message type.
struct Google_Protobuf_DescriptorProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  var field: [Google_Protobuf_FieldDescriptorProto] = []

  var `extension`: [Google_Protobuf_FieldDescriptorProto] = []

  var nestedType: [Google_Protobuf_DescriptorProto] = []

  var enumType: [Google_Protobuf_EnumDescriptorProto] = []

  var extensionRange: [Google_Protobuf_DescriptorProto.ExtensionRange] = []

  var oneofDecl: [Google_Protobuf_OneofDescriptorProto] = []

  var options: Google_Protobuf_MessageOptions {
    get {return _options ?? Google_Protobuf_MessageOptions()}
    set {_options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  var hasOptions: Bool {return self._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  mutating func clearOptions() {self._options = nil}

  var reservedRange: [Google_Protobuf_DescriptorProto.ReservedRange] = []

  /// Reserved field names, which may not be used by fields in the same message.
  /// A given name may only be reserved once.
  var reservedName: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct ExtensionRange {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Inclusive.
    var start: Int32 {
      get {return _start ?? 0}
      set {_start = newValue}
    }
    /// Returns true if `start` has been explicitly set.
    var hasStart: Bool {return self._start != nil}
    /// Clears the value of `start`. Subsequent reads from it will return its default value.
    mutating func clearStart() {self._start = nil}

    /// Exclusive.
    var end: Int32 {
      get {return _end ?? 0}
      set {_end = newValue}
    }
    /// Returns true if `end` has been explicitly set.
    var hasEnd: Bool {return self._end != nil}
    /// Clears the value of `end`. Subsequent reads from it will return its default value.
    mutating func clearEnd() {self._end = nil}

    var options: Google_Protobuf_ExtensionRangeOptions {
      get {return _options ?? Google_Protobuf_ExtensionRangeOptions()}
      set {_options = newValue}
    }
    /// Returns true if `options` has been explicitly set.
    var hasOptions: Bool {return self._options != nil}
    /// Clears the value of `options`. Subsequent reads from it will return its default value.
    mutating func clearOptions() {self._options = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _start: Int32? = nil
    fileprivate var _end: Int32? = nil
    fileprivate var _options: Google_Protobuf_ExtensionRangeOptions? = nil
  }

  /// Range of reserved tag numbers. Reserved tag numbers may not be used by
  /// fields or extension ranges in the same message. Reserved ranges may
  /// not overlap.
  struct ReservedRange {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Inclusive.
    var start: Int32 {
      get {return _start ?? 0}
      set {_start = newValue}
    }
    /// Returns true if `start` has been explicitly set.
    var hasStart: Bool {return self._start != nil}
    /// Clears the value of `start`. Subsequent reads from it will return its default value.
    mutating func clearStart() {self._start = nil}

    /// Exclusive.
    var end: Int32 {
      get {return _end ?? 0}
      set {_end = newValue}
    }
    /// Returns true if `end` has been explicitly set.
    var hasEnd: Bool {return self._end != nil}
    /// Clears the value of `end`. Subsequent reads from it will return its default value.
    mutating func clearEnd() {self._end = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _start: Int32? = nil
    fileprivate var _end: Int32? = nil
  }

  init() {}

  fileprivate var _name: String? = nil
  fileprivate var _options: Google_Protobuf_MessageOptions? = nil
}

struct Google_Protobuf_ExtensionRangeOptions: SwiftProtobuf.ExtensibleMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The parser stores options it doesn't recognize here. See above.
  var uninterpretedOption: [Google_Protobuf_UninterpretedOption] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
}

/// Describes a field within a message.
struct Google_Protobuf_FieldDescriptorProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String {
    get {return _storage._name ?? String()}
    set {_uniqueStorage()._name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return _storage._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {_uniqueStorage()._name = nil}

  var number: Int32 {
    get {return _storage._number ?? 0}
    set {_uniqueStorage()._number = newValue}
  }
  /// Returns true if `number` has been explicitly set.
  var hasNumber: Bool {return _storage._number != nil}
  /// Clears the value of `number`. Subsequent reads from it will return its default value.
  mutating func clearNumber() {_uniqueStorage()._number = nil}

  var label: Google_Protobuf_FieldDescriptorProto.Label {
    get {return _storage._label ?? .optional}
    set {_uniqueStorage()._label = newValue}
  }
  /// Returns true if `label` has been explicitly set.
  var hasLabel: Bool {return _storage._label != nil}
  /// Clears the value of `label`. Subsequent reads from it will return its default value.
  mutating func clearLabel() {_uniqueStorage()._label = nil}

  /// If type_name is set, this need not be set.  If both this and type_name
  /// are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.
  var type: Google_Protobuf_FieldDescriptorProto.TypeEnum {
    get {return _storage._type ?? .double}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {_uniqueStorage()._type = nil}

  /// For message and enum types, this is the name of the type.  If the name
  /// starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
  /// rules are used to find the type (i.e. first the nested types within this
  /// message are searched, then within the parent, on up to the root
  /// namespace).
  var typeName: String {
    get {return _storage._typeName ?? String()}
    set {_uniqueStorage()._typeName = newValue}
  }
  /// Returns true if `typeName` has been explicitly set.
  var hasTypeName: Bool {return _storage._typeName != nil}
  /// Clears the value of `typeName`. Subsequent reads from it will return its default value.
  mutating func clearTypeName() {_uniqueStorage()._typeName = nil}

  /// For extensions, this is the name of the type being extended.  It is
  /// resolved in the same manner as type_name.
  var extendee: String {
    get {return _storage._extendee ?? String()}
    set {_uniqueStorage()._extendee = newValue}
  }
  /// Returns true if `extendee` has been explicitly set.
  var hasExtendee: Bool {return _storage._extendee != nil}
  /// Clears the value of `extendee`. Subsequent reads from it will return its default value.
  mutating func clearExtendee() {_uniqueStorage()._extendee = nil}

  /// For numeric types, contains the original text representation of the value.
  /// For booleans, "true" or "false".
  /// For strings, contains the default text contents (not escaped in any way).
  /// For bytes, contains the C escaped value.  All bytes >= 128 are escaped.
  /// TODO(kenton):  Base-64 encode?
  var defaultValue: String {
    get {return _storage._defaultValue ?? String()}
    set {_uniqueStorage()._defaultValue = newValue}
  }
  /// Returns true if `defaultValue` has been explicitly set.
  var hasDefaultValue: Bool {return _storage._defaultValue != nil}
  /// Clears the value of `defaultValue`. Subsequent reads from it will return its default value.
  mutating func clearDefaultValue() {_uniqueStorage()._defaultValue = nil}

  /// If set, gives the index of a oneof in the containing type's oneof_decl
  /// list.  This field is a member of that oneof.
  var oneofIndex: Int32 {
    get {return _storage._oneofIndex ?? 0}
    set {_uniqueStorage()._oneofIndex = newValue}
  }
  /// Returns true if `oneofIndex` has been explicitly set.
  var hasOneofIndex: Bool {return _storage._oneofIndex != nil}
  /// Clears the value of `oneofIndex`. Subsequent reads from it will return its default value.
  mutating func clearOneofIndex() {_uniqueStorage()._oneofIndex = nil}

  /// JSON name of this field. The value is set by protocol compiler. If the
  /// user has set a "json_name" option on this field, that option's value
  /// will be used. Otherwise, it's deduced from the field's name by converting
  /// it to camelCase.
  var jsonName: String {
    get {return _storage._jsonName ?? String()}
    set {_uniqueStorage()._jsonName = newValue}
  }
  /// Returns true if `jsonName` has been explicitly set.
  var hasJsonName: Bool {return _storage._jsonName != nil}
  /// Clears the value of `jsonName`. Subsequent reads from it will return its default value.
  mutating func clearJsonName() {_uniqueStorage()._jsonName = nil}

  var options: Google_Protobuf_FieldOptions {
    get {return _storage._options ?? Google_Protobuf_FieldOptions()}
    set {_uniqueStorage()._options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  var hasOptions: Bool {return _storage._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  mutating func clearOptions() {_uniqueStorage()._options = nil}

  /// If true, this is a proto3 "optional". When a proto3 field is optional, it
  /// tracks presence regardless of field type.
  ///
  /// When proto3_optional is true, this field must be belong to a oneof to
  /// signal to old proto3 clients that presence is tracked for this field. This
  /// oneof is known as a "synthetic" oneof, and this field must be its sole
  /// member (each proto3 optional field gets its own synthetic oneof). Synthetic
  /// oneofs exist in the descriptor only, and do not generate any API. Synthetic
  /// oneofs must be ordered after all "real" oneofs.
  ///
  /// For message fields, proto3_optional doesn't create any semantic change,
  /// since non-repeated message fields always track presence. However it still
  /// indicates the semantic detail of whether the user wrote "optional" or not.
  /// This can be useful for round-tripping the .proto file. For consistency we
  /// give message fields a synthetic oneof also, even though it is not required
  /// to track presence. This is especially important because the parser can't
  /// tell if a field is a message or an enum, so it must always create a
  /// synthetic oneof.
  ///
  /// Proto2 optional fields do not set this flag, because they already indicate
  /// optional with `LABEL_OPTIONAL`.
  var proto3Optional: Bool {
    get {return _storage._proto3Optional ?? false}
    set {_uniqueStorage()._proto3Optional = newValue}
  }
  /// Returns true if `proto3Optional` has been explicitly set.
  var hasProto3Optional: Bool {return _storage._proto3Optional != nil}
  /// Clears the value of `proto3Optional`. Subsequent reads from it will return its default value.
  mutating func clearProto3Optional() {_uniqueStorage()._proto3Optional = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// 0 is reserved for errors.
    /// Order is weird for historical reasons.
    case double // = 1
    case float // = 2

    /// Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if
    /// negative values are likely.
    case int64 // = 3
    case uint64 // = 4

    /// Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if
    /// negative values are likely.
    case int32 // = 5
    case fixed64 // = 6
    case fixed32 // = 7
    case bool // = 8
    case string // = 9

    /// Tag-delimited aggregate.
    /// Group type is deprecated and not supported in proto3. However, Proto3
    /// implementations should still be able to parse the group wire format and
    /// treat group fields as unknown fields.
    case group // = 10

    /// Length-delimited aggregate.
    case message // = 11

    /// New in version 2.
    case bytes // = 12
    case uint32 // = 13
    case `enum` // = 14
    case sfixed32 // = 15
    case sfixed64 // = 16

    /// Uses ZigZag encoding.
    case sint32 // = 17

    /// Uses ZigZag encoding.
    case sint64 // = 18

    init() {
      self = .double
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .double
      case 2: self = .float
      case 3: self = .int64
      case 4: self = .uint64
      case 5: self = .int32
      case 6: self = .fixed64
      case 7: self = .fixed32
      case 8: self = .bool
      case 9: self = .string
      case 10: self = .group
      case 11: self = .message
      case 12: self = .bytes
      case 13: self = .uint32
      case 14: self = .enum
      case 15: self = .sfixed32
      case 16: self = .sfixed64
      case 17: self = .sint32
      case 18: self = .sint64
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .double: return 1
      case .float: return 2
      case .int64: return 3
      case .uint64: return 4
      case .int32: return 5
      case .fixed64: return 6
      case .fixed32: return 7
      case .bool: return 8
      case .string: return 9
      case .group: return 10
      case .message: return 11
      case .bytes: return 12
      case .uint32: return 13
      case .enum: return 14
      case .sfixed32: return 15
      case .sfixed64: return 16
      case .sint32: return 17
      case .sint64: return 18
      }
    }

  }

  enum Label: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// 0 is reserved for errors
    case `optional` // = 1
    case `required` // = 2
    case repeated // = 3

    init() {
      self = .optional
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .optional
      case 2: self = .required
      case 3: self = .repeated
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .optional: return 1
      case .required: return 2
      case .repeated: return 3
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Google_Protobuf_FieldDescriptorProto.TypeEnum: CaseIterable {
  // Support synthesized by the compiler.
}

extension Google_Protobuf_FieldDescriptorProto.Label: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// Describes a oneof.
struct Google_Protobuf_OneofDescriptorProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  var options: Google_Protobuf_OneofOptions {
    get {return _options ?? Google_Protobuf_OneofOptions()}
    set {_options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  var hasOptions: Bool {return self._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  mutating func clearOptions() {self._options = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _name: String? = nil
  fileprivate var _options: Google_Protobuf_OneofOptions? = nil
}

/// Describes an enum type.
struct Google_Protobuf_EnumDescriptorProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  var value: [Google_Protobuf_EnumValueDescriptorProto] = []

  var options: Google_Protobuf_EnumOptions {
    get {return _options ?? Google_Protobuf_EnumOptions()}
    set {_options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  var hasOptions: Bool {return self._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  mutating func clearOptions() {self._options = nil}

  /// Range of reserved numeric values. Reserved numeric values may not be used
  /// by enum values in the same enum declaration. Reserved ranges may not
  /// overlap.
  var reservedRange: [Google_Protobuf_EnumDescriptorProto.EnumReservedRange] = []

  /// Reserved enum value names, which may not be reused. A given name may only
  /// be reserved once.
  var reservedName: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Range of reserved numeric values. Reserved values may not be used by
  /// entries in the same enum. Reserved ranges may not overlap.
  ///
  /// Note that this is distinct from DescriptorProto.ReservedRange in that it
  /// is inclusive such that it can appropriately represent the entire int32
  /// domain.
  struct EnumReservedRange {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Inclusive.
    var start: Int32 {
      get {return _start ?? 0}
      set {_start = newValue}
    }
    /// Returns true if `start` has been explicitly set.
    var hasStart: Bool {return self._start != nil}
    /// Clears the value of `start`. Subsequent reads from it will return its default value.
    mutating func clearStart() {self._start = nil}

    /// Inclusive.
    var end: Int32 {
      get {return _end ?? 0}
      set {_end = newValue}
    }
    /// Returns true if `end` has been explicitly set.
    var hasEnd: Bool {return self._end != nil}
    /// Clears the value of `end`. Subsequent reads from it will return its default value.
    mutating func clearEnd() {self._end = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _start: Int32? = nil
    fileprivate var _end: Int32? = nil
  }

  init() {}

  fileprivate var _name: String? = nil
  fileprivate var _options: Google_Protobuf_EnumOptions? = nil
}

/// Describes a value within an enum.
struct Google_Protobuf_EnumValueDescriptorProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  var number: Int32 {
    get {return _number ?? 0}
    set {_number = newValue}
  }
  /// Returns true if `number` has been explicitly set.
  var hasNumber: Bool {return self._number != nil}
  /// Clears the value of `number`. Subsequent reads from it will return its default value.
  mutating func clearNumber() {self._number = nil}

  var options: Google_Protobuf_EnumValueOptions {
    get {return _options ?? Google_Protobuf_EnumValueOptions()}
    set {_options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  var hasOptions: Bool {return self._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  mutating func clearOptions() {self._options = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _name: String? = nil
  fileprivate var _number: Int32? = nil
  fileprivate var _options: Google_Protobuf_EnumValueOptions? = nil
}

/// Describes a service.
struct Google_Protobuf_ServiceDescriptorProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  var method: [Google_Protobuf_MethodDescriptorProto] = []

  var options: Google_Protobuf_ServiceOptions {
    get {return _options ?? Google_Protobuf_ServiceOptions()}
    set {_options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  var hasOptions: Bool {return self._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  mutating func clearOptions() {self._options = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _name: String? = nil
  fileprivate var _options: Google_Protobuf_ServiceOptions? = nil
}

/// Describes a method of a service.
struct Google_Protobuf_MethodDescriptorProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  /// Input and output type names.  These are resolved in the same way as
  /// FieldDescriptorProto.type_name, but must refer to a message type.
  var inputType: String {
    get {return _inputType ?? String()}
    set {_inputType = newValue}
  }
  /// Returns true if `inputType` has been explicitly set.
  var hasInputType: Bool {return self._inputType != nil}
  /// Clears the value of `inputType`. Subsequent reads from it will return its default value.
  mutating func clearInputType() {self._inputType = nil}

  var outputType: String {
    get {return _outputType ?? String()}
    set {_outputType = newValue}
  }
  /// Returns true if `outputType` has been explicitly set.
  var hasOutputType: Bool {return self._outputType != nil}
  /// Clears the value of `outputType`. Subsequent reads from it will return its default value.
  mutating func clearOutputType() {self._outputType = nil}

  var options: Google_Protobuf_MethodOptions {
    get {return _options ?? Google_Protobuf_MethodOptions()}
    set {_options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  var hasOptions: Bool {return self._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  mutating func clearOptions() {self._options = nil}

  /// Identifies if client streams multiple client messages
  var clientStreaming: Bool {
    get {return _clientStreaming ?? false}
    set {_clientStreaming = newValue}
  }
  /// Returns true if `clientStreaming` has been explicitly set.
  var hasClientStreaming: Bool {return self._clientStreaming != nil}
  /// Clears the value of `clientStreaming`. Subsequent reads from it will return its default value.
  mutating func clearClientStreaming() {self._clientStreaming = nil}

  /// Identifies if server streams multiple server messages
  var serverStreaming: Bool {
    get {return _serverStreaming ?? false}
    set {_serverStreaming = newValue}
  }
  /// Returns true if `serverStreaming` has been explicitly set.
  var hasServerStreaming: Bool {return self._serverStreaming != nil}
  /// Clears the value of `serverStreaming`. Subsequent reads from it will return its default value.
  mutating func clearServerStreaming() {self._serverStreaming = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _name: String? = nil
  fileprivate var _inputType: String? = nil
  fileprivate var _outputType: String? = nil
  fileprivate var _options: Google_Protobuf_MethodOptions? = nil
  fileprivate var _clientStreaming: Bool? = nil
  fileprivate var _serverStreaming: Bool? = nil
}

struct Google_Protobuf_FileOptions: SwiftProtobuf.ExtensibleMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sets the Java package where classes generated from this .proto will be
  /// placed.  By default, the proto package is used, but this is often
  /// inappropriate because proto packages do not normally start with backwards
  /// domain names.
  var javaPackage: String {
    get {return _storage._javaPackage ?? String()}
    set {_uniqueStorage()._javaPackage = newValue}
  }
  /// Returns true if `javaPackage` has been explicitly set.
  var hasJavaPackage: Bool {return _storage._javaPackage != nil}
  /// Clears the value of `javaPackage`. Subsequent reads from it will return its default value.
  mutating func clearJavaPackage() {_uniqueStorage()._javaPackage = nil}

  /// If set, all the classes from the .proto file are wrapped in a single
  /// outer class with the given name.  This applies to both Proto1
  /// (equivalent to the old "--one_java_file" option) and Proto2 (where
  /// a .proto always translates to a single class, but you may want to
  /// explicitly choose the class name).
  var javaOuterClassname: String {
    get {return _storage._javaOuterClassname ?? String()}
    set {_uniqueStorage()._javaOuterClassname = newValue}
  }
  /// Returns true if `javaOuterClassname` has been explicitly set.
  var hasJavaOuterClassname: Bool {return _storage._javaOuterClassname != nil}
  /// Clears the value of `javaOuterClassname`. Subsequent reads from it will return its default value.
  mutating func clearJavaOuterClassname() {_uniqueStorage()._javaOuterClassname = nil}

  /// If set true, then the Java code generator will generate a separate .java
  /// file for each top-level message, enum, and service defined in the .proto
  /// file.  Thus, these types will *not* be nested inside the outer class
  /// named by java_outer_classname.  However, the outer class will still be
  /// generated to contain the file's getDescriptor() method as well as any
  /// top-level extensions defined in the file.
  var javaMultipleFiles: Bool {
    get {return _storage._javaMultipleFiles ?? false}
    set {_uniqueStorage()._javaMultipleFiles = newValue}
  }
  /// Returns true if `javaMultipleFiles` has been explicitly set.
  var hasJavaMultipleFiles: Bool {return _storage._javaMultipleFiles != nil}
  /// Clears the value of `javaMultipleFiles`. Subsequent reads from it will return its default value.
  mutating func clearJavaMultipleFiles() {_uniqueStorage()._javaMultipleFiles = nil}

  /// This option does nothing.
  var javaGenerateEqualsAndHash: Bool {
    get {return _storage._javaGenerateEqualsAndHash ?? false}
    set {_uniqueStorage()._javaGenerateEqualsAndHash = newValue}
  }
  /// Returns true if `javaGenerateEqualsAndHash` has been explicitly set.
  var hasJavaGenerateEqualsAndHash: Bool {return _storage._javaGenerateEqualsAndHash != nil}
  /// Clears the value of `javaGenerateEqualsAndHash`. Subsequent reads from it will return its default value.
  mutating func clearJavaGenerateEqualsAndHash() {_uniqueStorage()._javaGenerateEqualsAndHash = nil}

  /// If set true, then the Java2 code generator will generate code that
  /// throws an exception whenever an attempt is made to assign a non-UTF-8
  /// byte sequence to a string field.
  /// Message reflection will do the same.
  /// However, an extension field still accepts non-UTF-8 byte sequences.
  /// This option has no effect on when used with the lite runtime.
  var javaStringCheckUtf8: Bool {
    get {return _storage._javaStringCheckUtf8 ?? false}
    set {_uniqueStorage()._javaStringCheckUtf8 = newValue}
  }
  /// Returns true if `javaStringCheckUtf8` has been explicitly set.
  var hasJavaStringCheckUtf8: Bool {return _storage._javaStringCheckUtf8 != nil}
  /// Clears the value of `javaStringCheckUtf8`. Subsequent reads from it will return its default value.
  mutating func clearJavaStringCheckUtf8() {_uniqueStorage()._javaStringCheckUtf8 = nil}

  var optimizeFor: Google_Protobuf_FileOptions.OptimizeMode {
    get {return _storage._optimizeFor ?? .speed}
    set {_uniqueStorage()._optimizeFor = newValue}
  }
  /// Returns true if `optimizeFor` has been explicitly set.
  var hasOptimizeFor: Bool {return _storage._optimizeFor != nil}
  /// Clears the value of `optimizeFor`. Subsequent reads from it will return its default value.
  mutating func clearOptimizeFor() {_uniqueStorage()._optimizeFor = nil}

  /// Sets the Go package where structs generated from this .proto will be
  /// placed. If omitted, the Go package will be derived from the following:
  ///   - The basename of the package import path, if provided.
  ///   - Otherwise, the package statement in the .proto file, if present.
  ///   - Otherwise, the basename of the .proto file, without extension.
  var goPackage: String {
    get {return _storage._goPackage ?? String()}
    set {_uniqueStorage()._goPackage = newValue}
  }
  /// Returns true if `goPackage` has been explicitly set.
  var hasGoPackage: Bool {return _storage._goPackage != nil}
  /// Clears the value of `goPackage`. Subsequent reads from it will return its default value.
  mutating func clearGoPackage() {_uniqueStorage()._goPackage = nil}

  /// Should generic services be generated in each language?  "Generic" services
  /// are not specific to any particular RPC system.  They are generated by the
  /// main code generators in each language (without additional plugins).
  /// Generic services were the only kind of service generation supported by
  /// early versions of google.protobuf.
  ///
  /// Generic services are now considered deprecated in favor of using plugins
  /// that generate code specific to your particular RPC system.  Therefore,
  /// these default to false.  Old code which depends on generic services should
  /// explicitly set them to true.
  var ccGenericServices: Bool {
    get {return _storage._ccGenericServices ?? false}
    set {_uniqueStorage()._ccGenericServices = newValue}
  }
  /// Returns true if `ccGenericServices` has been explicitly set.
  var hasCcGenericServices: Bool {return _storage._ccGenericServices != nil}
  /// Clears the value of `ccGenericServices`. Subsequent reads from it will return its default value.
  mutating func clearCcGenericServices() {_uniqueStorage()._ccGenericServices = nil}

  var javaGenericServices: Bool {
    get {return _storage._javaGenericServices ?? false}
    set {_uniqueStorage()._javaGenericServices = newValue}
  }
  /// Returns true if `javaGenericServices` has been explicitly set.
  var hasJavaGenericServices: Bool {return _storage._javaGenericServices != nil}
  /// Clears the value of `javaGenericServices`. Subsequent reads from it will return its default value.
  mutating func clearJavaGenericServices() {_uniqueStorage()._javaGenericServices = nil}

  var pyGenericServices: Bool {
    get {return _storage._pyGenericServices ?? false}
    set {_uniqueStorage()._pyGenericServices = newValue}
  }
  /// Returns true if `pyGenericServices` has been explicitly set.
  var hasPyGenericServices: Bool {return _storage._pyGenericServices != nil}
  /// Clears the value of `pyGenericServices`. Subsequent reads from it will return its default value.
  mutating func clearPyGenericServices() {_uniqueStorage()._pyGenericServices = nil}

  var phpGenericServices: Bool {
    get {return _storage._phpGenericServices ?? false}
    set {_uniqueStorage()._phpGenericServices = newValue}
  }
  /// Returns true if `phpGenericServices` has been explicitly set.
  var hasPhpGenericServices: Bool {return _storage._phpGenericServices != nil}
  /// Clears the value of `phpGenericServices`. Subsequent reads from it will return its default value.
  mutating func clearPhpGenericServices() {_uniqueStorage()._phpGenericServices = nil}

  /// Is this file deprecated?
  /// Depending on the target platform, this can emit Deprecated annotations
  /// for everything in the file, or it will be completely ignored; in the very
  /// least, this is a formalization for deprecating files.
  var deprecated: Bool {
    get {return _storage._deprecated ?? false}
    set {_uniqueStorage()._deprecated = newValue}
  }
  /// Returns true if `deprecated` has been explicitly set.
  var hasDeprecated: Bool {return _storage._deprecated != nil}
  /// Clears the value of `deprecated`. Subsequent reads from it will return its default value.
  mutating func clearDeprecated() {_uniqueStorage()._deprecated = nil}

  /// Enables the use of arenas for the proto messages in this file. This applies
  /// only to generated classes for C++.
  var ccEnableArenas: Bool {
    get {return _storage._ccEnableArenas ?? true}
    set {_uniqueStorage()._ccEnableArenas = newValue}
  }
  /// Returns true if `ccEnableArenas` has been explicitly set.
  var hasCcEnableArenas: Bool {return _storage._ccEnableArenas != nil}
  /// Clears the value of `ccEnableArenas`. Subsequent reads from it will return its default value.
  mutating func clearCcEnableArenas() {_uniqueStorage()._ccEnableArenas = nil}

  /// Sets the objective c class prefix which is prepended to all objective c
  /// generated classes from this .proto. There is no default.
  var objcClassPrefix: String {
    get {return _storage._objcClassPrefix ?? String()}
    set {_uniqueStorage()._objcClassPrefix = newValue}
  }
  /// Returns true if `objcClassPrefix` has been explicitly set.
  var hasObjcClassPrefix: Bool {return _storage._objcClassPrefix != nil}
  /// Clears the value of `objcClassPrefix`. Subsequent reads from it will return its default value.
  mutating func clearObjcClassPrefix() {_uniqueStorage()._objcClassPrefix = nil}

  /// Namespace for generated classes; defaults to the package.
  var csharpNamespace: String {
    get {return _storage._csharpNamespace ?? String()}
    set {_uniqueStorage()._csharpNamespace = newValue}
  }
  /// Returns true if `csharpNamespace` has been explicitly set.
  var hasCsharpNamespace: Bool {return _storage._csharpNamespace != nil}
  /// Clears the value of `csharpNamespace`. Subsequent reads from it will return its default value.
  mutating func clearCsharpNamespace() {_uniqueStorage()._csharpNamespace = nil}

  /// By default Swift generators will take the proto package and CamelCase it
  /// replacing '.' with underscore and use that to prefix the types/symbols
  /// defined. When this options is provided, they will use this value instead
  /// to prefix the types/symbols defined.
  var swiftPrefix: String {
    get {return _storage._swiftPrefix ?? String()}
    set {_uniqueStorage()._swiftPrefix = newValue}
  }
  /// Returns true if `swiftPrefix` has been explicitly set.
  var hasSwiftPrefix: Bool {return _storage._swiftPrefix != nil}
  /// Clears the value of `swiftPrefix`. Subsequent reads from it will return its default value.
  mutating func clearSwiftPrefix() {_uniqueStorage()._swiftPrefix = nil}

  /// Sets the php class prefix which is prepended to all php generated classes
  /// from this .proto. Default is empty.
  var phpClassPrefix: String {
    get {return _storage._phpClassPrefix ?? String()}
    set {_uniqueStorage()._phpClassPrefix = newValue}
  }
  /// Returns true if `phpClassPrefix` has been explicitly set.
  var hasPhpClassPrefix: Bool {return _storage._phpClassPrefix != nil}
  /// Clears the value of `phpClassPrefix`. Subsequent reads from it will return its default value.
  mutating func clearPhpClassPrefix() {_uniqueStorage()._phpClassPrefix = nil}

  /// Use this option to change the namespace of php generated classes. Default
  /// is empty. When this option is empty, the package name will be used for
  /// determining the namespace.
  var phpNamespace: String {
    get {return _storage._phpNamespace ?? String()}
    set {_uniqueStorage()._phpNamespace = newValue}
  }
  /// Returns true if `phpNamespace` has been explicitly set.
  var hasPhpNamespace: Bool {return _storage._phpNamespace != nil}
  /// Clears the value of `phpNamespace`. Subsequent reads from it will return its default value.
  mutating func clearPhpNamespace() {_uniqueStorage()._phpNamespace = nil}

  /// Use this option to change the namespace of php generated metadata classes.
  /// Default is empty. When this option is empty, the proto file name will be
  /// used for determining the namespace.
  var phpMetadataNamespace: String {
    get {return _storage._phpMetadataNamespace ?? String()}
    set {_uniqueStorage()._phpMetadataNamespace = newValue}
  }
  /// Returns true if `phpMetadataNamespace` has been explicitly set.
  var hasPhpMetadataNamespace: Bool {return _storage._phpMetadataNamespace != nil}
  /// Clears the value of `phpMetadataNamespace`. Subsequent reads from it will return its default value.
  mutating func clearPhpMetadataNamespace() {_uniqueStorage()._phpMetadataNamespace = nil}

  /// Use this option to change the package of ruby generated classes. Default
  /// is empty. When this option is not set, the package name will be used for
  /// determining the ruby package.
  var rubyPackage: String {
    get {return _storage._rubyPackage ?? String()}
    set {_uniqueStorage()._rubyPackage = newValue}
  }
  /// Returns true if `rubyPackage` has been explicitly set.
  var hasRubyPackage: Bool {return _storage._rubyPackage != nil}
  /// Clears the value of `rubyPackage`. Subsequent reads from it will return its default value.
  mutating func clearRubyPackage() {_uniqueStorage()._rubyPackage = nil}

  /// The parser stores options it doesn't recognize here.
  /// See the documentation for the "Options" section above.
  var uninterpretedOption: [Google_Protobuf_UninterpretedOption] {
    get {return _storage._uninterpretedOption}
    set {_uniqueStorage()._uninterpretedOption = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Generated classes can be optimized for speed or code size.
  enum OptimizeMode: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Generate complete code for parsing, serialization,
    case speed // = 1

    /// etc.
    case codeSize // = 2

    /// Generate code using MessageLite and the lite runtime.
    case liteRuntime // = 3

    init() {
      self = .speed
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .speed
      case 2: self = .codeSize
      case 3: self = .liteRuntime
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .speed: return 1
      case .codeSize: return 2
      case .liteRuntime: return 3
      }
    }

  }

  init() {}

  var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Google_Protobuf_FileOptions.OptimizeMode: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Google_Protobuf_MessageOptions: SwiftProtobuf.ExtensibleMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Set true to use the old proto1 MessageSet wire format for extensions.
  /// This is provided for backwards-compatibility with the MessageSet wire
  /// format.  You should not use this for any other reason:  It's less
  /// efficient, has fewer features, and is more complicated.
  ///
  /// The message must be defined exactly as follows:
  ///   message Foo {
  ///     option message_set_wire_format = true;
  ///     extensions 4 to max;
  ///   }
  /// Note that the message cannot have any defined fields; MessageSets only
  /// have extensions.
  ///
  /// All extensions of your type must be singular messages; e.g. they cannot
  /// be int32s, enums, or repeated messages.
  ///
  /// Because this is an option, the above two restrictions are not enforced by
  /// the protocol compiler.
  var messageSetWireFormat: Bool {
    get {return _messageSetWireFormat ?? false}
    set {_messageSetWireFormat = newValue}
  }
  /// Returns true if `messageSetWireFormat` has been explicitly set.
  var hasMessageSetWireFormat: Bool {return self._messageSetWireFormat != nil}
  /// Clears the value of `messageSetWireFormat`. Subsequent reads from it will return its default value.
  mutating func clearMessageSetWireFormat() {self._messageSetWireFormat = nil}

  /// Disables the generation of the standard "descriptor()" accessor, which can
  /// conflict with a field of the same name.  This is meant to make migration
  /// from proto1 easier; new code should avoid fields named "descriptor".
  var noStandardDescriptorAccessor: Bool {
    get {return _noStandardDescriptorAccessor ?? false}
    set {_noStandardDescriptorAccessor = newValue}
  }
  /// Returns true if `noStandardDescriptorAccessor` has been explicitly set.
  var hasNoStandardDescriptorAccessor: Bool {return self._noStandardDescriptorAccessor != nil}
  /// Clears the value of `noStandardDescriptorAccessor`. Subsequent reads from it will return its default value.
  mutating func clearNoStandardDescriptorAccessor() {self._noStandardDescriptorAccessor = nil}

  /// Is this message deprecated?
  /// Depending on the target platform, this can emit Deprecated annotations
  /// for the message, or it will be completely ignored; in the very least,
  /// this is a formalization for deprecating messages.
  var deprecated: Bool {
    get {return _deprecated ?? false}
    set {_deprecated = newValue}
  }
  /// Returns true if `deprecated` has been explicitly set.
  var hasDeprecated: Bool {return self._deprecated != nil}
  /// Clears the value of `deprecated`. Subsequent reads from it will return its default value.
  mutating func clearDeprecated() {self._deprecated = nil}

  /// Whether the message is an automatically generated map entry type for the
  /// maps field.
  ///
  /// For maps fields:
  ///     map<KeyType, ValueType> map_field = 1;
  /// The parsed descriptor looks like:
  ///     message MapFieldEntry {
  ///         option map_entry = true;
  ///         optional KeyType key = 1;
  ///         optional ValueType value = 2;
  ///     }
  ///     repeated MapFieldEntry map_field = 1;
  ///
  /// Implementations may choose not to generate the map_entry=true message, but
  /// use a native map in the target language to hold the keys and values.
  /// The reflection APIs in such implementations still need to work as
  /// if the field is a repeated message field.
  ///
  /// NOTE: Do not set the option in .proto files. Always use the maps syntax
  /// instead. The option should only be implicitly set by the proto compiler
  /// parser.
  var mapEntry: Bool {
    get {return _mapEntry ?? false}
    set {_mapEntry = newValue}
  }
  /// Returns true if `mapEntry` has been explicitly set.
  var hasMapEntry: Bool {return self._mapEntry != nil}
  /// Clears the value of `mapEntry`. Subsequent reads from it will return its default value.
  mutating func clearMapEntry() {self._mapEntry = nil}

  /// The parser stores options it doesn't recognize here. See above.
  var uninterpretedOption: [Google_Protobuf_UninterpretedOption] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _messageSetWireFormat: Bool? = nil
  fileprivate var _noStandardDescriptorAccessor: Bool? = nil
  fileprivate var _deprecated: Bool? = nil
  fileprivate var _mapEntry: Bool? = nil
}

struct Google_Protobuf_FieldOptions: SwiftProtobuf.ExtensibleMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ctype option instructs the C++ code generator to use a different
  /// representation of the field than it normally would.  See the specific
  /// options below.  This option is not yet implemented in the open source
  /// release -- sorry, we'll try to include it in a future version!
  var ctype: Google_Protobuf_FieldOptions.CType {
    get {return _ctype ?? .string}
    set {_ctype = newValue}
  }
  /// Returns true if `ctype` has been explicitly set.
  var hasCtype: Bool {return self._ctype != nil}
  /// Clears the value of `ctype`. Subsequent reads from it will return its default value.
  mutating func clearCtype() {self._ctype = nil}

  /// The packed option can be enabled for repeated primitive fields to enable
  /// a more efficient representation on the wire. Rather than repeatedly
  /// writing the tag and type for each element, the entire array is encoded as
  /// a single length-delimited blob. In proto3, only explicit setting it to
  /// false will avoid using packed encoding.
  var packed: Bool {
    get {return _packed ?? false}
    set {_packed = newValue}
  }
  /// Returns true if `packed` has been explicitly set.
  var hasPacked: Bool {return self._packed != nil}
  /// Clears the value of `packed`. Subsequent reads from it will return its default value.
  mutating func clearPacked() {self._packed = nil}

  /// The jstype option determines the JavaScript type used for values of the
  /// field.  The option is permitted only for 64 bit integral and fixed types
  /// (int64, uint64, sint64, fixed64, sfixed64).  A field with jstype JS_STRING
  /// is represented as JavaScript string, which avoids loss of precision that
  /// can happen when a large value is converted to a floating point JavaScript.
  /// Specifying JS_NUMBER for the jstype causes the generated JavaScript code to
  /// use the JavaScript "number" type.  The behavior of the default option
  /// JS_NORMAL is implementation dependent.
  ///
  /// This option is an enum to permit additional types to be added, e.g.
  /// goog.math.Integer.
  var jstype: Google_Protobuf_FieldOptions.JSType {
    get {return _jstype ?? .jsNormal}
    set {_jstype = newValue}
  }
  /// Returns true if `jstype` has been explicitly set.
  var hasJstype: Bool {return self._jstype != nil}
  /// Clears the value of `jstype`. Subsequent reads from it will return its default value.
  mutating func clearJstype() {self._jstype = nil}

  /// Should this field be parsed lazily?  Lazy applies only to message-type
  /// fields.  It means that when the outer message is initially parsed, the
  /// inner message's contents will not be parsed but instead stored in encoded
  /// form.  The inner message will actually be parsed when it is first accessed.
  ///
  /// This is only a hint.  Implementations are free to choose whether to use
  /// eager or lazy parsing regardless of the value of this option.  However,
  /// setting this option true suggests that the protocol author believes that
  /// using lazy parsing on this field is worth the additional bookkeeping
  /// overhead typically needed to implement it.
  ///
  /// This option does not affect the public interface of any generated code;
  /// all method signatures remain the same.  Furthermore, thread-safety of the
  /// interface is not affected by this option; const methods remain safe to
  /// call from multiple threads concurrently, while non-const methods continue
  /// to require exclusive access.
  ///
  ///
  /// Note that implementations may choose not to check required fields within
  /// a lazy sub-message.  That is, calling IsInitialized() on the outer message
  /// may return true even if the inner message has missing required fields.
  /// This is necessary because otherwise the inner message would have to be
  /// parsed in order to perform the check, defeating the purpose of lazy
  /// parsing.  An implementation which chooses not to check required fields
  /// must be consistent about it.  That is, for any particular sub-message, the
  /// implementation must either *always* check its required fields, or *never*
  /// check its required fields, regardless of whether or not the message has
  /// been parsed.
  var lazy: Bool {
    get {return _lazy ?? false}
    set {_lazy = newValue}
  }
  /// Returns true if `lazy` has been explicitly set.
  var hasLazy: Bool {return self._lazy != nil}
  /// Clears the value of `lazy`. Subsequent reads from it will return its default value.
  mutating func clearLazy() {self._lazy = nil}

  /// Is this field deprecated?
  /// Depending on the target platform, this can emit Deprecated annotations
  /// for accessors, or it will be completely ignored; in the very least, this
  /// is a formalization for deprecating fields.
  var deprecated: Bool {
    get {return _deprecated ?? false}
    set {_deprecated = newValue}
  }
  /// Returns true if `deprecated` has been explicitly set.
  var hasDeprecated: Bool {return self._deprecated != nil}
  /// Clears the value of `deprecated`. Subsequent reads from it will return its default value.
  mutating func clearDeprecated() {self._deprecated = nil}

  /// For Google-internal migration only. Do not use.
  var weak: Bool {
    get {return _weak ?? false}
    set {_weak = newValue}
  }
  /// Returns true if `weak` has been explicitly set.
  var hasWeak: Bool {return self._weak != nil}
  /// Clears the value of `weak`. Subsequent reads from it will return its default value.
  mutating func clearWeak() {self._weak = nil}

  /// The parser stores options it doesn't recognize here. See above.
  var uninterpretedOption: [Google_Protobuf_UninterpretedOption] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum CType: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Default mode.
    case string // = 0
    case cord // = 1
    case stringPiece // = 2

    init() {
      self = .string
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .string
      case 1: self = .cord
      case 2: self = .stringPiece
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .string: return 0
      case .cord: return 1
      case .stringPiece: return 2
      }
    }

  }

  enum JSType: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Use the default type.
    case jsNormal // = 0

    /// Use JavaScript strings.
    case jsString // = 1

    /// Use JavaScript numbers.
    case jsNumber // = 2

    init() {
      self = .jsNormal
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .jsNormal
      case 1: self = .jsString
      case 2: self = .jsNumber
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .jsNormal: return 0
      case .jsString: return 1
      case .jsNumber: return 2
      }
    }

  }

  init() {}

  var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _ctype: Google_Protobuf_FieldOptions.CType? = nil
  fileprivate var _packed: Bool? = nil
  fileprivate var _jstype: Google_Protobuf_FieldOptions.JSType? = nil
  fileprivate var _lazy: Bool? = nil
  fileprivate var _deprecated: Bool? = nil
  fileprivate var _weak: Bool? = nil
}

#if swift(>=4.2)

extension Google_Protobuf_FieldOptions.CType: CaseIterable {
  // Support synthesized by the compiler.
}

extension Google_Protobuf_FieldOptions.JSType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Google_Protobuf_OneofOptions: SwiftProtobuf.ExtensibleMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The parser stores options it doesn't recognize here. See above.
  var uninterpretedOption: [Google_Protobuf_UninterpretedOption] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
}

struct Google_Protobuf_EnumOptions: SwiftProtobuf.ExtensibleMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Set this option to true to allow mapping different tag names to the same
  /// value.
  var allowAlias: Bool {
    get {return _allowAlias ?? false}
    set {_allowAlias = newValue}
  }
  /// Returns true if `allowAlias` has been explicitly set.
  var hasAllowAlias: Bool {return self._allowAlias != nil}
  /// Clears the value of `allowAlias`. Subsequent reads from it will return its default value.
  mutating func clearAllowAlias() {self._allowAlias = nil}

  /// Is this enum deprecated?
  /// Depending on the target platform, this can emit Deprecated annotations
  /// for the enum, or it will be completely ignored; in the very least, this
  /// is a formalization for deprecating enums.
  var deprecated: Bool {
    get {return _deprecated ?? false}
    set {_deprecated = newValue}
  }
  /// Returns true if `deprecated` has been explicitly set.
  var hasDeprecated: Bool {return self._deprecated != nil}
  /// Clears the value of `deprecated`. Subsequent reads from it will return its default value.
  mutating func clearDeprecated() {self._deprecated = nil}

  /// The parser stores options it doesn't recognize here. See above.
  var uninterpretedOption: [Google_Protobuf_UninterpretedOption] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _allowAlias: Bool? = nil
  fileprivate var _deprecated: Bool? = nil
}

struct Google_Protobuf_EnumValueOptions: SwiftProtobuf.ExtensibleMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Is this enum value deprecated?
  /// Depending on the target platform, this can emit Deprecated annotations
  /// for the enum value, or it will be completely ignored; in the very least,
  /// this is a formalization for deprecating enum values.
  var deprecated: Bool {
    get {return _deprecated ?? false}
    set {_deprecated = newValue}
  }
  /// Returns true if `deprecated` has been explicitly set.
  var hasDeprecated: Bool {return self._deprecated != nil}
  /// Clears the value of `deprecated`. Subsequent reads from it will return its default value.
  mutating func clearDeprecated() {self._deprecated = nil}

  /// The parser stores options it doesn't recognize here. See above.
  var uninterpretedOption: [Google_Protobuf_UninterpretedOption] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _deprecated: Bool? = nil
}

struct Google_Protobuf_ServiceOptions: SwiftProtobuf.ExtensibleMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Is this service deprecated?
  /// Depending on the target platform, this can emit Deprecated annotations
  /// for the service, or it will be completely ignored; in the very least,
  /// this is a formalization for deprecating services.
  var deprecated: Bool {
    get {return _deprecated ?? false}
    set {_deprecated = newValue}
  }
  /// Returns true if `deprecated` has been explicitly set.
  var hasDeprecated: Bool {return self._deprecated != nil}
  /// Clears the value of `deprecated`. Subsequent reads from it will return its default value.
  mutating func clearDeprecated() {self._deprecated = nil}

  /// The parser stores options it doesn't recognize here. See above.
  var uninterpretedOption: [Google_Protobuf_UninterpretedOption] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _deprecated: Bool? = nil
}

struct Google_Protobuf_MethodOptions: SwiftProtobuf.ExtensibleMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Is this method deprecated?
  /// Depending on the target platform, this can emit Deprecated annotations
  /// for the method, or it will be completely ignored; in the very least,
  /// this is a formalization for deprecating methods.
  var deprecated: Bool {
    get {return _deprecated ?? false}
    set {_deprecated = newValue}
  }
  /// Returns true if `deprecated` has been explicitly set.
  var hasDeprecated: Bool {return self._deprecated != nil}
  /// Clears the value of `deprecated`. Subsequent reads from it will return its default value.
  mutating func clearDeprecated() {self._deprecated = nil}

  var idempotencyLevel: Google_Protobuf_MethodOptions.IdempotencyLevel {
    get {return _idempotencyLevel ?? .idempotencyUnknown}
    set {_idempotencyLevel = newValue}
  }
  /// Returns true if `idempotencyLevel` has been explicitly set.
  var hasIdempotencyLevel: Bool {return self._idempotencyLevel != nil}
  /// Clears the value of `idempotencyLevel`. Subsequent reads from it will return its default value.
  mutating func clearIdempotencyLevel() {self._idempotencyLevel = nil}

  /// The parser stores options it doesn't recognize here. See above.
  var uninterpretedOption: [Google_Protobuf_UninterpretedOption] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Is this method side-effect-free (or safe in HTTP parlance), or idempotent,
  /// or neither? HTTP based RPC implementation may choose GET verb for safe
  /// methods, and PUT verb for idempotent methods instead of the default POST.
  enum IdempotencyLevel: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case idempotencyUnknown // = 0

    /// implies idempotent
    case noSideEffects // = 1

    /// idempotent, but may have side effects
    case idempotent // = 2

    init() {
      self = .idempotencyUnknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .idempotencyUnknown
      case 1: self = .noSideEffects
      case 2: self = .idempotent
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .idempotencyUnknown: return 0
      case .noSideEffects: return 1
      case .idempotent: return 2
      }
    }

  }

  init() {}

  var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _deprecated: Bool? = nil
  fileprivate var _idempotencyLevel: Google_Protobuf_MethodOptions.IdempotencyLevel? = nil
}

#if swift(>=4.2)

extension Google_Protobuf_MethodOptions.IdempotencyLevel: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// A message representing a option the parser does not recognize. This only
/// appears in options protos created by the compiler::Parser class.
/// DescriptorPool resolves these when building Descriptor objects. Therefore,
/// options protos in descriptor objects (e.g. returned by Descriptor::options(),
/// or produced by Descriptor::CopyTo()) will never have UninterpretedOptions
/// in them.
struct Google_Protobuf_UninterpretedOption {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: [Google_Protobuf_UninterpretedOption.NamePart] = []

  /// The value of the uninterpreted option, in whatever type the tokenizer
  /// identified it as during parsing. Exactly one of these should be set.
  var identifierValue: String {
    get {return _identifierValue ?? String()}
    set {_identifierValue = newValue}
  }
  /// Returns true if `identifierValue` has been explicitly set.
  var hasIdentifierValue: Bool {return self._identifierValue != nil}
  /// Clears the value of `identifierValue`. Subsequent reads from it will return its default value.
  mutating func clearIdentifierValue() {self._identifierValue = nil}

  var positiveIntValue: UInt64 {
    get {return _positiveIntValue ?? 0}
    set {_positiveIntValue = newValue}
  }
  /// Returns true if `positiveIntValue` has been explicitly set.
  var hasPositiveIntValue: Bool {return self._positiveIntValue != nil}
  /// Clears the value of `positiveIntValue`. Subsequent reads from it will return its default value.
  mutating func clearPositiveIntValue() {self._positiveIntValue = nil}

  var negativeIntValue: Int64 {
    get {return _negativeIntValue ?? 0}
    set {_negativeIntValue = newValue}
  }
  /// Returns true if `negativeIntValue` has been explicitly set.
  var hasNegativeIntValue: Bool {return self._negativeIntValue != nil}
  /// Clears the value of `negativeIntValue`. Subsequent reads from it will return its default value.
  mutating func clearNegativeIntValue() {self._negativeIntValue = nil}

  var doubleValue: Double {
    get {return _doubleValue ?? 0}
    set {_doubleValue = newValue}
  }
  /// Returns true if `doubleValue` has been explicitly set.
  var hasDoubleValue: Bool {return self._doubleValue != nil}
  /// Clears the value of `doubleValue`. Subsequent reads from it will return its default value.
  mutating func clearDoubleValue() {self._doubleValue = nil}

  var stringValue: Data {
    get {return _stringValue ?? Data()}
    set {_stringValue = newValue}
  }
  /// Returns true if `stringValue` has been explicitly set.
  var hasStringValue: Bool {return self._stringValue != nil}
  /// Clears the value of `stringValue`. Subsequent reads from it will return its default value.
  mutating func clearStringValue() {self._stringValue = nil}

  var aggregateValue: String {
    get {return _aggregateValue ?? String()}
    set {_aggregateValue = newValue}
  }
  /// Returns true if `aggregateValue` has been explicitly set.
  var hasAggregateValue: Bool {return self._aggregateValue != nil}
  /// Clears the value of `aggregateValue`. Subsequent reads from it will return its default value.
  mutating func clearAggregateValue() {self._aggregateValue = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The name of the uninterpreted option.  Each string represents a segment in
  /// a dot-separated name.  is_extension is true iff a segment represents an
  /// extension (denoted with parentheses in options specs in .proto files).
  /// E.g.,{ ["foo", false], ["bar.baz", true], ["qux", false] } represents
  /// "foo.(bar.baz).qux".
  struct NamePart {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var namePart: String {
      get {return _namePart ?? String()}
      set {_namePart = newValue}
    }
    /// Returns true if `namePart` has been explicitly set.
    var hasNamePart: Bool {return self._namePart != nil}
    /// Clears the value of `namePart`. Subsequent reads from it will return its default value.
    mutating func clearNamePart() {self._namePart = nil}

    var isExtension: Bool {
      get {return _isExtension ?? false}
      set {_isExtension = newValue}
    }
    /// Returns true if `isExtension` has been explicitly set.
    var hasIsExtension: Bool {return self._isExtension != nil}
    /// Clears the value of `isExtension`. Subsequent reads from it will return its default value.
    mutating func clearIsExtension() {self._isExtension = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _namePart: String? = nil
    fileprivate var _isExtension: Bool? = nil
  }

  init() {}

  fileprivate var _identifierValue: String? = nil
  fileprivate var _positiveIntValue: UInt64? = nil
  fileprivate var _negativeIntValue: Int64? = nil
  fileprivate var _doubleValue: Double? = nil
  fileprivate var _stringValue: Data? = nil
  fileprivate var _aggregateValue: String? = nil
}

/// Encapsulates information about the original source file from which a
/// FileDescriptorProto was generated.
struct Google_Protobuf_SourceCodeInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A Location identifies a piece of source code in a .proto file which
  /// corresponds to a particular definition.  This information is intended
  /// to be useful to IDEs, code indexers, documentation generators, and similar
  /// tools.
  ///
  /// For example, say we have a file like:
  ///   message Foo {
  ///     optional string foo = 1;
  ///   }
  /// Let's look at just the field definition:
  ///   optional string foo = 1;
  ///   ^       ^^     ^^  ^  ^^^
  ///   a       bc     de  f  ghi
  /// We have the following locations:
  ///   span   path               represents
  ///   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
  ///   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
  ///   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
  ///   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
  ///   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
  ///
  /// Notes:
  /// - A location may refer to a repeated field itself (i.e. not to any
  ///   particular index within it).  This is used whenever a set of elements are
  ///   logically enclosed in a single code segment.  For example, an entire
  ///   extend block (possibly containing multiple extension definitions) will
  ///   have an outer location whose path refers to the "extensions" repeated
  ///   field without an index.
  /// - Multiple locations may have the same path.  This happens when a single
  ///   logical declaration is spread out across multiple places.  The most
  ///   obvious example is the "extend" block again -- there may be multiple
  ///   extend blocks in the same scope, each of which will have the same path.
  /// - A location's span is not always a subset of its parent's span.  For
  ///   example, the "extendee" of an extension declaration appears at the
  ///   beginning of the "extend" block and is shared by all extensions within
  ///   the block.
  /// - Just because a location's span is a subset of some other location's span
  ///   does not mean that it is a descendant.  For example, a "group" defines
  ///   both a type and a field in a single declaration.  Thus, the locations
  ///   corresponding to the type and field and their components will overlap.
  /// - Code which tries to interpret locations should probably be designed to
  ///   ignore those that it doesn't understand, as more types of locations could
  ///   be recorded in the future.
  var location: [Google_Protobuf_SourceCodeInfo.Location] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Location {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Identifies which part of the FileDescriptorProto was defined at this
    /// location.
    ///
    /// Each element is a field number or an index.  They form a path from
    /// the root FileDescriptorProto to the place where the definition.  For
    /// example, this path:
    ///   [ 4, 3, 2, 7, 1 ]
    /// refers to:
    ///   file.message_type(3)  // 4, 3
    ///       .field(7)         // 2, 7
    ///       .name()           // 1
    /// This is because FileDescriptorProto.message_type has field number 4:
    ///   repeated DescriptorProto message_type = 4;
    /// and DescriptorProto.field has field number 2:
    ///   repeated FieldDescriptorProto field = 2;
    /// and FieldDescriptorProto.name has field number 1:
    ///   optional string name = 1;
    ///
    /// Thus, the above path gives the location of a field name.  If we removed
    /// the last element:
    ///   [ 4, 3, 2, 7 ]
    /// this path refers to the whole field declaration (from the beginning
    /// of the label to the terminating semicolon).
    var path: [Int32] = []

    /// Always has exactly three or four elements: start line, start column,
    /// end line (optional, otherwise assumed same as start line), end column.
    /// These are packed into a single field for efficiency.  Note that line
    /// and column numbers are zero-based -- typically you will want to add
    /// 1 to each before displaying to a user.
    var span: [Int32] = []

    /// If this SourceCodeInfo represents a complete declaration, these are any
    /// comments appearing before and after the declaration which appear to be
    /// attached to the declaration.
    ///
    /// A series of line comments appearing on consecutive lines, with no other
    /// tokens appearing on those lines, will be treated as a single comment.
    ///
    /// leading_detached_comments will keep paragraphs of comments that appear
    /// before (but not connected to) the current element. Each paragraph,
    /// separated by empty lines, will be one comment element in the repeated
    /// field.
    ///
    /// Only the comment content is provided; comment markers (e.g. //) are
    /// stripped out.  For block comments, leading whitespace and an asterisk
    /// will be stripped from the beginning of each line other than the first.
    /// Newlines are included in the output.
    ///
    /// Examples:
    ///
    ///   optional int32 foo = 1;  // Comment attached to foo.
    ///   // Comment attached to bar.
    ///   optional int32 bar = 2;
    ///
    ///   optional string baz = 3;
    ///   // Comment attached to baz.
    ///   // Another line attached to baz.
    ///
    ///   // Comment attached to qux.
    ///   //
    ///   // Another line attached to qux.
    ///   optional double qux = 4;
    ///
    ///   // Detached comment for corge. This is not leading or trailing comments
    ///   // to qux or corge because there are blank lines separating it from
    ///   // both.
    ///
    ///   // Detached comment for corge paragraph 2.
    ///
    ///   optional string corge = 5;
    ///   /* Block comment attached
    ///    * to corge.  Leading asterisks
    ///    * will be removed. */
    ///   /* Block comment attached to
    ///    * grault. */
    ///   optional int32 grault = 6;
    ///
    ///   // ignored detached comments.
    var leadingComments: String {
      get {return _leadingComments ?? String()}
      set {_leadingComments = newValue}
    }
    /// Returns true if `leadingComments` has been explicitly set.
    var hasLeadingComments: Bool {return self._leadingComments != nil}
    /// Clears the value of `leadingComments`. Subsequent reads from it will return its default value.
    mutating func clearLeadingComments() {self._leadingComments = nil}

    var trailingComments: String {
      get {return _trailingComments ?? String()}
      set {_trailingComments = newValue}
    }
    /// Returns true if `trailingComments` has been explicitly set.
    var hasTrailingComments: Bool {return self._trailingComments != nil}
    /// Clears the value of `trailingComments`. Subsequent reads from it will return its default value.
    mutating func clearTrailingComments() {self._trailingComments = nil}

    var leadingDetachedComments: [String] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _leadingComments: String? = nil
    fileprivate var _trailingComments: String? = nil
  }

  init() {}
}

/// Describes the relationship between generated code and its original source
/// file. A GeneratedCodeInfo message is associated with only one generated
/// source file, but may contain references to different source .proto files.
struct Google_Protobuf_GeneratedCodeInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An Annotation connects some span of text in generated code to an element
  /// of its generating .proto file.
  var annotation: [Google_Protobuf_GeneratedCodeInfo.Annotation] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Annotation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Identifies the element in the original source .proto file. This field
    /// is formatted the same as SourceCodeInfo.Location.path.
    var path: [Int32] = []

    /// Identifies the filesystem path to the original source .proto.
    var sourceFile: String {
      get {return _sourceFile ?? String()}
      set {_sourceFile = newValue}
    }
    /// Returns true if `sourceFile` has been explicitly set.
    var hasSourceFile: Bool {return self._sourceFile != nil}
    /// Clears the value of `sourceFile`. Subsequent reads from it will return its default value.
    mutating func clearSourceFile() {self._sourceFile = nil}

    /// Identifies the starting offset in bytes in the generated code
    /// that relates to the identified object.
    var begin: Int32 {
      get {return _begin ?? 0}
      set {_begin = newValue}
    }
    /// Returns true if `begin` has been explicitly set.
    var hasBegin: Bool {return self._begin != nil}
    /// Clears the value of `begin`. Subsequent reads from it will return its default value.
    mutating func clearBegin() {self._begin = nil}

    /// Identifies the ending offset in bytes in the generated code that
    /// relates to the identified offset. The end offset should be one past
    /// the last relevant byte (so the length of the text = end - begin).
    var end: Int32 {
      get {return _end ?? 0}
      set {_end = newValue}
    }
    /// Returns true if `end` has been explicitly set.
    var hasEnd: Bool {return self._end != nil}
    /// Clears the value of `end`. Subsequent reads from it will return its default value.
    mutating func clearEnd() {self._end = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _sourceFile: String? = nil
    fileprivate var _begin: Int32? = nil
    fileprivate var _end: Int32? = nil
  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.protobuf"

extension Google_Protobuf_FileDescriptorSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FileDescriptorSet"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "file"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.file) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.file) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.file.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.file, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Protobuf_FileDescriptorSet, rhs: Google_Protobuf_FileDescriptorSet) -> Bool {
    if lhs.file != rhs.file {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Protobuf_FileDescriptorProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FileDescriptorProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "package"),
    3: .same(proto: "dependency"),
    10: .standard(proto: "public_dependency"),
    11: .standard(proto: "weak_dependency"),
    4: .standard(proto: "message_type"),
    5: .standard(proto: "enum_type"),
    6: .same(proto: "service"),
    7: .same(proto: "extension"),
    8: .same(proto: "options"),
    9: .standard(proto: "source_code_info"),
    12: .same(proto: "syntax"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.messageType) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.enumType) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.service) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.`extension`) {return false}
    if let v = self._options, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._package) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.dependency) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.messageType) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.enumType) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.service) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.`extension`) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._options) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._sourceCodeInfo) }()
      case 10: try { try decoder.decodeRepeatedInt32Field(value: &self.publicDependency) }()
      case 11: try { try decoder.decodeRepeatedInt32Field(value: &self.weakDependency) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self._syntax) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._package {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if !self.dependency.isEmpty {
      try visitor.visitRepeatedStringField(value: self.dependency, fieldNumber: 3)
    }
    if !self.messageType.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messageType, fieldNumber: 4)
    }
    if !self.enumType.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.enumType, fieldNumber: 5)
    }
    if !self.service.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.service, fieldNumber: 6)
    }
    if !self.`extension`.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.`extension`, fieldNumber: 7)
    }
    if let v = self._options {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    if let v = self._sourceCodeInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    if !self.publicDependency.isEmpty {
      try visitor.visitRepeatedInt32Field(value: self.publicDependency, fieldNumber: 10)
    }
    if !self.weakDependency.isEmpty {
      try visitor.visitRepeatedInt32Field(value: self.weakDependency, fieldNumber: 11)
    }
    if let v = self._syntax {
      try visitor.visitSingularStringField(value: v, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Protobuf_FileDescriptorProto, rhs: Google_Protobuf_FileDescriptorProto) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._package != rhs._package {return false}
    if lhs.dependency != rhs.dependency {return false}
    if lhs.publicDependency != rhs.publicDependency {return false}
    if lhs.weakDependency != rhs.weakDependency {return false}
    if lhs.messageType != rhs.messageType {return false}
    if lhs.enumType != rhs.enumType {return false}
    if lhs.service != rhs.service {return false}
    if lhs.`extension` != rhs.`extension` {return false}
    if lhs._options != rhs._options {return false}
    if lhs._sourceCodeInfo != rhs._sourceCodeInfo {return false}
    if lhs._syntax != rhs._syntax {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Protobuf_DescriptorProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DescriptorProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "field"),
    6: .same(proto: "extension"),
    3: .standard(proto: "nested_type"),
    4: .standard(proto: "enum_type"),
    5: .standard(proto: "extension_range"),
    8: .standard(proto: "oneof_decl"),
    7: .same(proto: "options"),
    9: .standard(proto: "reserved_range"),
    10: .standard(proto: "reserved_name"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.field) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.`extension`) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.nestedType) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.enumType) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.extensionRange) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.oneofDecl) {return false}
    if let v = self._options, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.field) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.nestedType) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.enumType) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.extensionRange) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.`extension`) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._options) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.oneofDecl) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.reservedRange) }()
      case 10: try { try decoder.decodeRepeatedStringField(value: &self.reservedName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if !self.field.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.field, fieldNumber: 2)
    }
    if !self.nestedType.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nestedType, fieldNumber: 3)
    }
    if !self.enumType.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.enumType, fieldNumber: 4)
    }
    if !self.extensionRange.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.extensionRange, fieldNumber: 5)
    }
    if !self.`extension`.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.`extension`, fieldNumber: 6)
    }
    if let v = self._options {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if !self.oneofDecl.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.oneofDecl, fieldNumber: 8)
    }
    if !self.reservedRange.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.reservedRange, fieldNumber: 9)
    }
    if !self.reservedName.isEmpty {
      try visitor.visitRepeatedStringField(value: self.reservedName, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Protobuf_DescriptorProto, rhs: Google_Protobuf_DescriptorProto) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs.field != rhs.field {return false}
    if lhs.`extension` != rhs.`extension` {return false}
    if lhs.nestedType != rhs.nestedType {return false}
    if lhs.enumType != rhs.enumType {return false}
    if lhs.extensionRange != rhs.extensionRange {return false}
    if lhs.oneofDecl != rhs.oneofDecl {return false}
    if lhs._options != rhs._options {return false}
    if lhs.reservedRange != rhs.reservedRange {return false}
    if lhs.reservedName != rhs.reservedName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Protobuf_DescriptorProto.ExtensionRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Google_Protobuf_DescriptorProto.protoMessageName + ".ExtensionRange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "end"),
    3: .same(proto: "options"),
  ]

  public var isInitialized: Bool {
    if let v = self._options, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._start) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._end) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._options) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._start {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._end {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._options {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Protobuf_DescriptorProto.ExtensionRange, rhs: Google_Protobuf_DescriptorProto.ExtensionRange) -> Bool {
    if lhs._start != rhs._start {return false}
    if lhs._end != rhs._end {return false}
    if lhs._options != rhs._options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Protobuf_DescriptorProto.ReservedRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Google_Protobuf_DescriptorProto.protoMessageName + ".ReservedRange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "end"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._start) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._end) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._start {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._end {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Protobuf_DescriptorProto.ReservedRange, rhs: Google_Protobuf_DescriptorProto.ReservedRange) -> Bool {
    if lhs._start != rhs._start {return false}
    if lhs._end != rhs._end {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Protobuf_ExtensionRangeOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExtensionRangeOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    999: .standard(proto: "uninterpreted_option"),
  ]

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.uninterpretedOption) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 999: try { try decoder.decodeRepeatedMessageField(value: &self.uninterpretedOption) }()
      case 1000..<536870912:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: Google_Protobuf_ExtensionRangeOptions.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uninterpretedOption.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.uninterpretedOption, fieldNumber: 999)
    }
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 536870912)
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Protobuf_ExtensionRangeOptions, rhs: Google_Protobuf_ExtensionRangeOptions) -> Bool {
    if lhs.uninterpretedOption != rhs.uninterpretedOption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension Google_Protobuf_FieldDescriptorProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FieldDescriptorProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    3: .same(proto: "number"),
    4: .same(proto: "label"),
    5: .same(proto: "type"),
    6: .standard(proto: "type_name"),
    2: .same(proto: "extendee"),
    7: .standard(proto: "default_value"),
    9: .standard(proto: "oneof_index"),
    10: .standard(proto: "json_name"),
    8: .same(proto: "options"),
    17: .standard(proto: "proto3_optional"),
  ]

  fileprivate class _StorageClass {
    var _name: String? = nil
    var _number: Int32? = nil
    var _label: Google_Protobuf_FieldDescriptorProto.Label? = nil
    var _type: Google_Protobuf_FieldDescriptorProto.TypeEnum? = nil
    var _typeName: String? = nil
    var _extendee: String? = nil
    var _defaultValue: String? = nil
    var _oneofIndex: Int32? = nil
    var _jsonName: String? = nil
    var _options: Google_Protobuf_FieldOptions? = nil
    var _proto3Optional: Bool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _number = source._number
      _label = source._label
      _type = source._type
      _typeName = source._typeName
      _extendee = source._extendee
      _defaultValue = source._defaultValue
      _oneofIndex = source._oneofIndex
      _jsonName = source._jsonName
      _options = source._options
      _proto3Optional = source._proto3Optional
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._options, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._extendee) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._number) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._label) }()
        case 5: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._typeName) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._defaultValue) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._options) }()
        case 9: try { try decoder.decodeSingularInt32Field(value: &_storage._oneofIndex) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._jsonName) }()
        case 17: try { try decoder.decodeSingularBoolField(value: &_storage._proto3Optional) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._name {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._extendee {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if let v = _storage._number {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
      }
      if let v = _storage._label {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
      }
      if let v = _storage._type {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
      }
      if let v = _storage._typeName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      }
      if let v = _storage._defaultValue {
        try visitor.visitSingularStringField(value: v, fieldNumber: 7)
      }
      if let v = _storage._options {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._oneofIndex {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 9)
      }
      if let v = _storage._jsonName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 10)
      }
      if let v = _storage._proto3Optional {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 17)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Protobuf_FieldDescriptorProto, rhs: Google_Protobuf_FieldDescriptorProto) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._number != rhs_storage._number {return false}
        if _storage._label != rhs_storage._label {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._typeName != rhs_storage._typeName {return false}
        if _storage._extendee != rhs_storage._extendee {return false}
        if _storage._defaultValue != rhs_storage._defaultValue {return false}
        if _storage._oneofIndex != rhs_storage._oneofIndex {return false}
        if _storage._jsonName != rhs_storage._jsonName {return false}
        if _storage._options != rhs_storage._options {return false}
        if _storage._proto3Optional != rhs_storage._proto3Optional {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Protobuf_FieldDescriptorProto.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "TYPE_DOUBLE"),
    2: .same(proto: "TYPE_FLOAT"),
    3: .same(proto: "TYPE_INT64"),
    4: .same(proto: "TYPE_UINT64"),
    5: .same(proto: "TYPE_INT32"),
    6: .same(proto: "TYPE_FIXED64"),
    7: .same(proto: "TYPE_FIXED32"),
    8: .same(proto: "TYPE_BOOL"),
    9: .same(proto: "TYPE_STRING"),
    10: .same(proto: "TYPE_GROUP"),
    11: .same(proto: "TYPE_MESSAGE"),
    12: .same(proto: "TYPE_BYTES"),
    13: .same(proto: "TYPE_UINT32"),
    14: .same(proto: "TYPE_ENUM"),
    15: .same(proto: "TYPE_SFIXED32"),
    16: .same(proto: "TYPE_SFIXED64"),
    17: .same(proto: "TYPE_SINT32"),
    18: .same(proto: "TYPE_SINT64"),
  ]
}

extension Google_Protobuf_FieldDescriptorProto.Label: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "LABEL_OPTIONAL"),
    2: .same(proto: "LABEL_REQUIRED"),
    3: .same(proto: "LABEL_REPEATED"),
  ]
}

extension Google_Protobuf_OneofDescriptorProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OneofDescriptorProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "options"),
  ]

  public var isInitialized: Bool {
    if let v = self._options, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._options) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._options {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Protobuf_OneofDescriptorProto, rhs: Google_Protobuf_OneofDescriptorProto) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._options != rhs._options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Protobuf_EnumDescriptorProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EnumDescriptorProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
    3: .same(proto: "options"),
    4: .standard(proto: "reserved_range"),
    5: .standard(proto: "reserved_name"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.value) {return false}
    if let v = self._options, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.value) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._options) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.reservedRange) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.reservedName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.value, fieldNumber: 2)
    }
    if let v = self._options {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.reservedRange.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.reservedRange, fieldNumber: 4)
    }
    if !self.reservedName.isEmpty {
      try visitor.visitRepeatedStringField(value: self.reservedName, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Protobuf_EnumDescriptorProto, rhs: Google_Protobuf_EnumDescriptorProto) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs.value != rhs.value {return false}
    if lhs._options != rhs._options {return false}
    if lhs.reservedRange != rhs.reservedRange {return false}
    if lhs.reservedName != rhs.reservedName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Protobuf_EnumDescriptorProto.EnumReservedRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Google_Protobuf_EnumDescriptorProto.protoMessageName + ".EnumReservedRange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "end"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._start) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._end) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._start {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._end {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Protobuf_EnumDescriptorProto.EnumReservedRange, rhs: Google_Protobuf_EnumDescriptorProto.EnumReservedRange) -> Bool {
    if lhs._start != rhs._start {return false}
    if lhs._end != rhs._end {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Protobuf_EnumValueDescriptorProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EnumValueDescriptorProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "number"),
    3: .same(proto: "options"),
  ]

  public var isInitialized: Bool {
    if let v = self._options, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._number) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._options) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._number {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._options {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Protobuf_EnumValueDescriptorProto, rhs: Google_Protobuf_EnumValueDescriptorProto) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._number != rhs._number {return false}
    if lhs._options != rhs._options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Protobuf_ServiceDescriptorProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ServiceDescriptorProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "method"),
    3: .same(proto: "options"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.method) {return false}
    if let v = self._options, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.method) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._options) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if !self.method.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.method, fieldNumber: 2)
    }
    if let v = self._options {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Protobuf_ServiceDescriptorProto, rhs: Google_Protobuf_ServiceDescriptorProto) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs.method != rhs.method {return false}
    if lhs._options != rhs._options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Protobuf_MethodDescriptorProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MethodDescriptorProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "input_type"),
    3: .standard(proto: "output_type"),
    4: .same(proto: "options"),
    5: .standard(proto: "client_streaming"),
    6: .standard(proto: "server_streaming"),
  ]

  public var isInitialized: Bool {
    if let v = self._options, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._inputType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._outputType) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._options) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._clientStreaming) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._serverStreaming) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._inputType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._outputType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._options {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._clientStreaming {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    }
    if let v = self._serverStreaming {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Protobuf_MethodDescriptorProto, rhs: Google_Protobuf_MethodDescriptorProto) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._inputType != rhs._inputType {return false}
    if lhs._outputType != rhs._outputType {return false}
    if lhs._options != rhs._options {return false}
    if lhs._clientStreaming != rhs._clientStreaming {return false}
    if lhs._serverStreaming != rhs._serverStreaming {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Protobuf_FileOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FileOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "java_package"),
    8: .standard(proto: "java_outer_classname"),
    10: .standard(proto: "java_multiple_files"),
    20: .standard(proto: "java_generate_equals_and_hash"),
    27: .standard(proto: "java_string_check_utf8"),
    9: .standard(proto: "optimize_for"),
    11: .standard(proto: "go_package"),
    16: .standard(proto: "cc_generic_services"),
    17: .standard(proto: "java_generic_services"),
    18: .standard(proto: "py_generic_services"),
    42: .standard(proto: "php_generic_services"),
    23: .same(proto: "deprecated"),
    31: .standard(proto: "cc_enable_arenas"),
    36: .standard(proto: "objc_class_prefix"),
    37: .standard(proto: "csharp_namespace"),
    39: .standard(proto: "swift_prefix"),
    40: .standard(proto: "php_class_prefix"),
    41: .standard(proto: "php_namespace"),
    44: .standard(proto: "php_metadata_namespace"),
    45: .standard(proto: "ruby_package"),
    999: .standard(proto: "uninterpreted_option"),
  ]

  fileprivate class _StorageClass {
    var _javaPackage: String? = nil
    var _javaOuterClassname: String? = nil
    var _javaMultipleFiles: Bool? = nil
    var _javaGenerateEqualsAndHash: Bool? = nil
    var _javaStringCheckUtf8: Bool? = nil
    var _optimizeFor: Google_Protobuf_FileOptions.OptimizeMode? = nil
    var _goPackage: String? = nil
    var _ccGenericServices: Bool? = nil
    var _javaGenericServices: Bool? = nil
    var _pyGenericServices: Bool? = nil
    var _phpGenericServices: Bool? = nil
    var _deprecated: Bool? = nil
    var _ccEnableArenas: Bool? = nil
    var _objcClassPrefix: String? = nil
    var _csharpNamespace: String? = nil
    var _swiftPrefix: String? = nil
    var _phpClassPrefix: String? = nil
    var _phpNamespace: String? = nil
    var _phpMetadataNamespace: String? = nil
    var _rubyPackage: String? = nil
    var _uninterpretedOption: [Google_Protobuf_UninterpretedOption] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _javaPackage = source._javaPackage
      _javaOuterClassname = source._javaOuterClassname
      _javaMultipleFiles = source._javaMultipleFiles
      _javaGenerateEqualsAndHash = source._javaGenerateEqualsAndHash
      _javaStringCheckUtf8 = source._javaStringCheckUtf8
      _optimizeFor = source._optimizeFor
      _goPackage = source._goPackage
      _ccGenericServices = source._ccGenericServices
      _javaGenericServices = source._javaGenericServices
      _pyGenericServices = source._pyGenericServices
      _phpGenericServices = source._phpGenericServices
      _deprecated = source._deprecated
      _ccEnableArenas = source._ccEnableArenas
      _objcClassPrefix = source._objcClassPrefix
      _csharpNamespace = source._csharpNamespace
      _swiftPrefix = source._swiftPrefix
      _phpClassPrefix = source._phpClassPrefix
      _phpNamespace = source._phpNamespace
      _phpMetadataNamespace = source._phpMetadataNamespace
      _rubyPackage = source._rubyPackage
      _uninterpretedOption = source._uninterpretedOption
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._uninterpretedOption) {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._javaPackage) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._javaOuterClassname) }()
        case 9: try { try decoder.decodeSingularEnumField(value: &_storage._optimizeFor) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._javaMultipleFiles) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._goPackage) }()
        case 16: try { try decoder.decodeSingularBoolField(value: &_storage._ccGenericServices) }()
        case 17: try { try decoder.decodeSingularBoolField(value: &_storage._javaGenericServices) }()
        case 18: try { try decoder.decodeSingularBoolField(value: &_storage._pyGenericServices) }()
        case 20: try { try decoder.decodeSingularBoolField(value: &_storage._javaGenerateEqualsAndHash) }()
        case 23: try { try decoder.decodeSingularBoolField(value: &_storage._deprecated) }()
        case 27: try { try decoder.decodeSingularBoolField(value: &_storage._javaStringCheckUtf8) }()
        case 31: try { try decoder.decodeSingularBoolField(value: &_storage._ccEnableArenas) }()
        case 36: try { try decoder.decodeSingularStringField(value: &_storage._objcClassPrefix) }()
        case 37: try { try decoder.decodeSingularStringField(value: &_storage._csharpNamespace) }()
        case 39: try { try decoder.decodeSingularStringField(value: &_storage._swiftPrefix) }()
        case 40: try { try decoder.decodeSingularStringField(value: &_storage._phpClassPrefix) }()
        case 41: try { try decoder.decodeSingularStringField(value: &_storage._phpNamespace) }()
        case 42: try { try decoder.decodeSingularBoolField(value: &_storage._phpGenericServices) }()
        case 44: try { try decoder.decodeSingularStringField(value: &_storage._phpMetadataNamespace) }()
        case 45: try { try decoder.decodeSingularStringField(value: &_storage._rubyPackage) }()
        case 999: try { try decoder.decodeRepeatedMessageField(value: &_storage._uninterpretedOption) }()
        case 1000..<536870912:
          try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: Google_Protobuf_FileOptions.self, fieldNumber: fieldNumber) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._javaPackage {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._javaOuterClassname {
        try visitor.visitSingularStringField(value: v, fieldNumber: 8)
      }
      if let v = _storage._optimizeFor {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 9)
      }
      if let v = _storage._javaMultipleFiles {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
      }
      if let v = _storage._goPackage {
        try visitor.visitSingularStringField(value: v, fieldNumber: 11)
      }
      if let v = _storage._ccGenericServices {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 16)
      }
      if let v = _storage._javaGenericServices {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 17)
      }
      if let v = _storage._pyGenericServices {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 18)
      }
      if let v = _storage._javaGenerateEqualsAndHash {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 20)
      }
      if let v = _storage._deprecated {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 23)
      }
      if let v = _storage._javaStringCheckUtf8 {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 27)
      }
      if let v = _storage._ccEnableArenas {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 31)
      }
      if let v = _storage._objcClassPrefix {
        try visitor.visitSingularStringField(value: v, fieldNumber: 36)
      }
      if let v = _storage._csharpNamespace {
        try visitor.visitSingularStringField(value: v, fieldNumber: 37)
      }
      if let v = _storage._swiftPrefix {
        try visitor.visitSingularStringField(value: v, fieldNumber: 39)
      }
      if let v = _storage._phpClassPrefix {
        try visitor.visitSingularStringField(value: v, fieldNumber: 40)
      }
      if let v = _storage._phpNamespace {
        try visitor.visitSingularStringField(value: v, fieldNumber: 41)
      }
      if let v = _storage._phpGenericServices {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 42)
      }
      if let v = _storage._phpMetadataNamespace {
        try visitor.visitSingularStringField(value: v, fieldNumber: 44)
      }
      if let v = _storage._rubyPackage {
        try visitor.visitSingularStringField(value: v, fieldNumber: 45)
      }
      if !_storage._uninterpretedOption.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._uninterpretedOption, fieldNumber: 999)
      }
      try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 536870912)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Protobuf_FileOptions, rhs: Google_Protobuf_FileOptions) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._javaPackage != rhs_storage._javaPackage {return false}
        if _storage._javaOuterClassname != rhs_storage._javaOuterClassname {return false}
        if _storage._javaMultipleFiles != rhs_storage._javaMultipleFiles {return false}
        if _storage._javaGenerateEqualsAndHash != rhs_storage._javaGenerateEqualsAndHash {return false}
        if _storage._javaStringCheckUtf8 != rhs_storage._javaStringCheckUtf8 {return false}
        if _storage._optimizeFor != rhs_storage._optimizeFor {return false}
        if _storage._goPackage != rhs_storage._goPackage {return false}
        if _storage._ccGenericServices != rhs_storage._ccGenericServices {return false}
        if _storage._javaGenericServices != rhs_storage._javaGenericServices {return false}
        if _storage._pyGenericServices != rhs_storage._pyGenericServices {return false}
        if _storage._phpGenericServices != rhs_storage._phpGenericServices {return false}
        if _storage._deprecated != rhs_storage._deprecated {return false}
        if _storage._ccEnableArenas != rhs_storage._ccEnableArenas {return false}
        if _storage._objcClassPrefix != rhs_storage._objcClassPrefix {return false}
        if _storage._csharpNamespace != rhs_storage._csharpNamespace {return false}
        if _storage._swiftPrefix != rhs_storage._swiftPrefix {return false}
        if _storage._phpClassPrefix != rhs_storage._phpClassPrefix {return false}
        if _storage._phpNamespace != rhs_storage._phpNamespace {return false}
        if _storage._phpMetadataNamespace != rhs_storage._phpMetadataNamespace {return false}
        if _storage._rubyPackage != rhs_storage._rubyPackage {return false}
        if _storage._uninterpretedOption != rhs_storage._uninterpretedOption {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension Google_Protobuf_FileOptions.OptimizeMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "SPEED"),
    2: .same(proto: "CODE_SIZE"),
    3: .same(proto: "LITE_RUNTIME"),
  ]
}

extension Google_Protobuf_MessageOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MessageOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_set_wire_format"),
    2: .standard(proto: "no_standard_descriptor_accessor"),
    3: .same(proto: "deprecated"),
    7: .standard(proto: "map_entry"),
    999: .standard(proto: "uninterpreted_option"),
  ]

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.uninterpretedOption) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._messageSetWireFormat) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._noStandardDescriptorAccessor) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._deprecated) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self._mapEntry) }()
      case 999: try { try decoder.decodeRepeatedMessageField(value: &self.uninterpretedOption) }()
      case 1000..<536870912:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: Google_Protobuf_MessageOptions.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._messageSetWireFormat {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }
    if let v = self._noStandardDescriptorAccessor {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }
    if let v = self._deprecated {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }
    if let v = self._mapEntry {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    }
    if !self.uninterpretedOption.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.uninterpretedOption, fieldNumber: 999)
    }
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 536870912)
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Protobuf_MessageOptions, rhs: Google_Protobuf_MessageOptions) -> Bool {
    if lhs._messageSetWireFormat != rhs._messageSetWireFormat {return false}
    if lhs._noStandardDescriptorAccessor != rhs._noStandardDescriptorAccessor {return false}
    if lhs._deprecated != rhs._deprecated {return false}
    if lhs._mapEntry != rhs._mapEntry {return false}
    if lhs.uninterpretedOption != rhs.uninterpretedOption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension Google_Protobuf_FieldOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FieldOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ctype"),
    2: .same(proto: "packed"),
    6: .same(proto: "jstype"),
    5: .same(proto: "lazy"),
    3: .same(proto: "deprecated"),
    10: .same(proto: "weak"),
    999: .standard(proto: "uninterpreted_option"),
  ]

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.uninterpretedOption) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._ctype) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._packed) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._deprecated) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._lazy) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self._jstype) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self._weak) }()
      case 999: try { try decoder.decodeRepeatedMessageField(value: &self.uninterpretedOption) }()
      case 1000..<536870912:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: Google_Protobuf_FieldOptions.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._ctype {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    if let v = self._packed {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }
    if let v = self._deprecated {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }
    if let v = self._lazy {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    }
    if let v = self._jstype {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 6)
    }
    if let v = self._weak {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
    }
    if !self.uninterpretedOption.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.uninterpretedOption, fieldNumber: 999)
    }
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 536870912)
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Protobuf_FieldOptions, rhs: Google_Protobuf_FieldOptions) -> Bool {
    if lhs._ctype != rhs._ctype {return false}
    if lhs._packed != rhs._packed {return false}
    if lhs._jstype != rhs._jstype {return false}
    if lhs._lazy != rhs._lazy {return false}
    if lhs._deprecated != rhs._deprecated {return false}
    if lhs._weak != rhs._weak {return false}
    if lhs.uninterpretedOption != rhs.uninterpretedOption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension Google_Protobuf_FieldOptions.CType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STRING"),
    1: .same(proto: "CORD"),
    2: .same(proto: "STRING_PIECE"),
  ]
}

extension Google_Protobuf_FieldOptions.JSType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "JS_NORMAL"),
    1: .same(proto: "JS_STRING"),
    2: .same(proto: "JS_NUMBER"),
  ]
}

extension Google_Protobuf_OneofOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OneofOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    999: .standard(proto: "uninterpreted_option"),
  ]

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.uninterpretedOption) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 999: try { try decoder.decodeRepeatedMessageField(value: &self.uninterpretedOption) }()
      case 1000..<536870912:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: Google_Protobuf_OneofOptions.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uninterpretedOption.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.uninterpretedOption, fieldNumber: 999)
    }
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 536870912)
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Protobuf_OneofOptions, rhs: Google_Protobuf_OneofOptions) -> Bool {
    if lhs.uninterpretedOption != rhs.uninterpretedOption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension Google_Protobuf_EnumOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EnumOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "allow_alias"),
    3: .same(proto: "deprecated"),
    999: .standard(proto: "uninterpreted_option"),
  ]

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.uninterpretedOption) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularBoolField(value: &self._allowAlias) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._deprecated) }()
      case 999: try { try decoder.decodeRepeatedMessageField(value: &self.uninterpretedOption) }()
      case 1000..<536870912:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: Google_Protobuf_EnumOptions.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._allowAlias {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }
    if let v = self._deprecated {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }
    if !self.uninterpretedOption.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.uninterpretedOption, fieldNumber: 999)
    }
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 536870912)
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Protobuf_EnumOptions, rhs: Google_Protobuf_EnumOptions) -> Bool {
    if lhs._allowAlias != rhs._allowAlias {return false}
    if lhs._deprecated != rhs._deprecated {return false}
    if lhs.uninterpretedOption != rhs.uninterpretedOption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension Google_Protobuf_EnumValueOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EnumValueOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deprecated"),
    999: .standard(proto: "uninterpreted_option"),
  ]

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.uninterpretedOption) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._deprecated) }()
      case 999: try { try decoder.decodeRepeatedMessageField(value: &self.uninterpretedOption) }()
      case 1000..<536870912:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: Google_Protobuf_EnumValueOptions.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._deprecated {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }
    if !self.uninterpretedOption.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.uninterpretedOption, fieldNumber: 999)
    }
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 536870912)
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Protobuf_EnumValueOptions, rhs: Google_Protobuf_EnumValueOptions) -> Bool {
    if lhs._deprecated != rhs._deprecated {return false}
    if lhs.uninterpretedOption != rhs.uninterpretedOption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension Google_Protobuf_ServiceOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ServiceOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    33: .same(proto: "deprecated"),
    999: .standard(proto: "uninterpreted_option"),
  ]

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.uninterpretedOption) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 33: try { try decoder.decodeSingularBoolField(value: &self._deprecated) }()
      case 999: try { try decoder.decodeRepeatedMessageField(value: &self.uninterpretedOption) }()
      case 1000..<536870912:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: Google_Protobuf_ServiceOptions.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._deprecated {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 33)
    }
    if !self.uninterpretedOption.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.uninterpretedOption, fieldNumber: 999)
    }
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 536870912)
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Protobuf_ServiceOptions, rhs: Google_Protobuf_ServiceOptions) -> Bool {
    if lhs._deprecated != rhs._deprecated {return false}
    if lhs.uninterpretedOption != rhs.uninterpretedOption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension Google_Protobuf_MethodOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MethodOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    33: .same(proto: "deprecated"),
    34: .standard(proto: "idempotency_level"),
    999: .standard(proto: "uninterpreted_option"),
  ]

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.uninterpretedOption) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 33: try { try decoder.decodeSingularBoolField(value: &self._deprecated) }()
      case 34: try { try decoder.decodeSingularEnumField(value: &self._idempotencyLevel) }()
      case 999: try { try decoder.decodeRepeatedMessageField(value: &self.uninterpretedOption) }()
      case 1000..<536870912:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: Google_Protobuf_MethodOptions.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._deprecated {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 33)
    }
    if let v = self._idempotencyLevel {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 34)
    }
    if !self.uninterpretedOption.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.uninterpretedOption, fieldNumber: 999)
    }
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 536870912)
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Protobuf_MethodOptions, rhs: Google_Protobuf_MethodOptions) -> Bool {
    if lhs._deprecated != rhs._deprecated {return false}
    if lhs._idempotencyLevel != rhs._idempotencyLevel {return false}
    if lhs.uninterpretedOption != rhs.uninterpretedOption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension Google_Protobuf_MethodOptions.IdempotencyLevel: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "IDEMPOTENCY_UNKNOWN"),
    1: .same(proto: "NO_SIDE_EFFECTS"),
    2: .same(proto: "IDEMPOTENT"),
  ]
}

extension Google_Protobuf_UninterpretedOption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UninterpretedOption"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "name"),
    3: .standard(proto: "identifier_value"),
    4: .standard(proto: "positive_int_value"),
    5: .standard(proto: "negative_int_value"),
    6: .standard(proto: "double_value"),
    7: .standard(proto: "string_value"),
    8: .standard(proto: "aggregate_value"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.name) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._identifierValue) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._positiveIntValue) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self._negativeIntValue) }()
      case 6: try { try decoder.decodeSingularDoubleField(value: &self._doubleValue) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self._stringValue) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._aggregateValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.name, fieldNumber: 2)
    }
    if let v = self._identifierValue {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._positiveIntValue {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    }
    if let v = self._negativeIntValue {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 5)
    }
    if let v = self._doubleValue {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 6)
    }
    if let v = self._stringValue {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 7)
    }
    if let v = self._aggregateValue {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Protobuf_UninterpretedOption, rhs: Google_Protobuf_UninterpretedOption) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._identifierValue != rhs._identifierValue {return false}
    if lhs._positiveIntValue != rhs._positiveIntValue {return false}
    if lhs._negativeIntValue != rhs._negativeIntValue {return false}
    if lhs._doubleValue != rhs._doubleValue {return false}
    if lhs._stringValue != rhs._stringValue {return false}
    if lhs._aggregateValue != rhs._aggregateValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Protobuf_UninterpretedOption.NamePart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Google_Protobuf_UninterpretedOption.protoMessageName + ".NamePart"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "name_part"),
    2: .standard(proto: "is_extension"),
  ]

  public var isInitialized: Bool {
    if self._namePart == nil {return false}
    if self._isExtension == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._namePart) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._isExtension) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._namePart {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._isExtension {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Protobuf_UninterpretedOption.NamePart, rhs: Google_Protobuf_UninterpretedOption.NamePart) -> Bool {
    if lhs._namePart != rhs._namePart {return false}
    if lhs._isExtension != rhs._isExtension {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Protobuf_SourceCodeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SourceCodeInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "location"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.location) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.location.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.location, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Protobuf_SourceCodeInfo, rhs: Google_Protobuf_SourceCodeInfo) -> Bool {
    if lhs.location != rhs.location {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Protobuf_SourceCodeInfo.Location: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Google_Protobuf_SourceCodeInfo.protoMessageName + ".Location"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .same(proto: "span"),
    3: .standard(proto: "leading_comments"),
    4: .standard(proto: "trailing_comments"),
    6: .standard(proto: "leading_detached_comments"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt32Field(value: &self.path) }()
      case 2: try { try decoder.decodeRepeatedInt32Field(value: &self.span) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._leadingComments) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._trailingComments) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.leadingDetachedComments) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitPackedInt32Field(value: self.path, fieldNumber: 1)
    }
    if !self.span.isEmpty {
      try visitor.visitPackedInt32Field(value: self.span, fieldNumber: 2)
    }
    if let v = self._leadingComments {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._trailingComments {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    if !self.leadingDetachedComments.isEmpty {
      try visitor.visitRepeatedStringField(value: self.leadingDetachedComments, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Protobuf_SourceCodeInfo.Location, rhs: Google_Protobuf_SourceCodeInfo.Location) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs.span != rhs.span {return false}
    if lhs._leadingComments != rhs._leadingComments {return false}
    if lhs._trailingComments != rhs._trailingComments {return false}
    if lhs.leadingDetachedComments != rhs.leadingDetachedComments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Protobuf_GeneratedCodeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GeneratedCodeInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "annotation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.annotation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.annotation.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.annotation, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Protobuf_GeneratedCodeInfo, rhs: Google_Protobuf_GeneratedCodeInfo) -> Bool {
    if lhs.annotation != rhs.annotation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Protobuf_GeneratedCodeInfo.Annotation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Google_Protobuf_GeneratedCodeInfo.protoMessageName + ".Annotation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .standard(proto: "source_file"),
    3: .same(proto: "begin"),
    4: .same(proto: "end"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt32Field(value: &self.path) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._sourceFile) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._begin) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._end) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitPackedInt32Field(value: self.path, fieldNumber: 1)
    }
    if let v = self._sourceFile {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._begin {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._end {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Protobuf_GeneratedCodeInfo.Annotation, rhs: Google_Protobuf_GeneratedCodeInfo.Annotation) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs._sourceFile != rhs._sourceFile {return false}
    if lhs._begin != rhs._begin {return false}
    if lhs._end != rhs._end {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
