// Protos/unittest_swift_reserved.proto - test proto
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
// -----------------------------------------------------------------------------
///
/// Test Swift reserved words used as enum or message names
///
// -----------------------------------------------------------------------------

syntax = "proto3";
package swift_unittest.names;

// TODO: Build a MessageNames message with a submessage of every name below
// TODO: Create tests that access every field, enum, message to verify the name is generated correctly

message FieldNames {
    int32 String = 1;
    int32 Int = 2;
    int32 Double = 3;
    int32 Float = 4;
    int32 UInt = 5;
    int32 hashValue = 6;
    int32 description = 7;
    int32 debugDescription = 8;
    int32 Swift = 9;
    int32 UNRECOGNIZED = 10;
    int32 class = 11;
    int32 deinit = 12;
    int32 enum = 13;
    int32 extension = 14;
    int32 func = 15;
    int32 import = 16;
    int32 init = 17;
    int32 inout = 18;
    int32 internal = 19;
    int32 let = 20;
    int32 operator = 21;
    int32 private = 22;
    int32 protocol = 23;
    int32 public = 24;
    int32 static = 25;
    int32 struct = 26;
    int32 subscript = 27;
    int32 typealias = 28;
    int32 var = 29;
    int32 break = 30;
    int32 case = 31;
    int32 continue = 32;
    int32 default = 33;
    int32 defer = 34;
    int32 do = 35;
    int32 else = 36;
    int32 fallthrough = 37;
    int32 for = 38;
    int32 guard = 39;
    int32 if = 40;
    int32 in = 41;
    int32 repeat = 42;
    int32 return = 43;
    int32 switch = 44;
    int32 where = 45;
    int32 while = 46;
    int32 as = 47;
    int32 catch = 48;
    int32 dynamicType = 49;
    int32 false = 50;
    int32 is = 51;
    int32 nil = 52;
    int32 rethrows = 53;
    int32 super = 54;
    int32 self = 55;
    int32 throw = 57;
    int32 throws = 58;
    int32 true = 59;
    int32 try = 60;
    int32 __COLUMN__ = 61;
    int32 __FILE__ = 62;
    int32 __FUNCTION__ = 63;
    int32 __LINE__ = 64;
    int32 _ = 65;
    int32 associativity = 66;
    int32 convenience = 67;
    int32 dynamic = 68;
    int32 didSet = 69;
    int32 final = 70;
    int32 get = 71;
    int32 infix = 72;
    int32 indirect = 73;
    int32 lazy = 74;
    int32 left = 75;
    int32 mutating = 76;
    int32 none = 77;
    int32 nonmutating = 78;
    int32 optional = 79;
    int32 override = 80;
    int32 postfix = 81;
    int32 precedence = 82;
    int32 prefix = 83;
    int32 required = 85;
    int32 right = 86;
    int32 set = 87;
    int32 Type = 88;
    int32 unowned = 89;
    int32 weak = 90;
    int32 willSet = 91;
    int32 id = 92;
    int32 _cmd = 93;
    int32 out = 96;
    int32 bycopy = 98;
    int32 byref = 99;
    int32 oneway = 100;
    int32 and = 102;
    int32 and_eq = 103;
    int32 alignas = 104;
    int32 alignof = 105;
    int32 asm = 106;
    int32 auto = 107;
    int32 bitand = 108;
    int32 bitor = 109;
    int32 bool = 110;
    int32 char = 114;
    int32 char16_t = 115;
    int32 char32_t = 116;
    int32 compl = 118;
    int32 const = 119;
    int32 constexpr = 120;
    int32 const_cast = 121;
    int32 decltype = 123;
    int32 delete = 125;
    int32 dynamic_cast = 127;
    int32 explicit = 130;
    int32 export = 131;
    int32 extern  = 132;
    int32 friend = 136;
    int32 goto = 137;
    int32 inline = 139;
    int32 long = 141;
    int32 mutable = 142;
    int32 namespace = 143;
    int32 new = 144;
    int32 noexcept = 145;
    int32 not = 146;
    int32 not_eq = 147;
    int32 nullptr = 148;
    int32 or = 150;
    int32 or_eq = 151;
    int32 protected = 153;
    int32 register = 155;
    int32 reinterpret_cast = 156;
    int32 short = 158;
    int32 signed = 159;
    int32 sizeof = 160;
    int32 static_assert = 162;
    int32 static_cast = 163;
    int32 template = 166;
    int32 this = 167;
    int32 thread_local = 168;
    int32 typedef = 172;
    int32 typeid = 173;
    int32 typename = 174;
    int32 union = 175;
    int32 unsigned = 176;
    int32 using = 177;
    int32 virtual = 178;
    int32 void = 179;
    int32 volatile = 180;
    int32 wchar_t = 181;
    int32 xor = 183;
    int32 xor_eq = 184;
    int32 restrict = 185;
    int32 Category = 186;
    int32 Ivar = 187;
    int32 Method = 188;
    int32 finalize = 192;
    int32 hash = 193;
    int32 dealloc = 194;
    int32 superclass = 197;
    int32 retain = 198;
    int32 release = 199;
    int32 autorelease = 200;
    int32 retainCount = 201;
    int32 zone = 202;
    int32 isProxy = 203;
    int32 copy = 204;
    int32 mutableCopy = 205;
    int32 classForCoder = 206;
    int32 clear = 207;
    int32 data = 208;
    int32 delimitedData = 209;
    int32 descriptor = 210;
    int32 extensionRegistry = 211;
    int32 extensionsCurrentlySet = 212;
    int32 isInitialized = 213;
    int32 serializedSize = 214;
    int32 sortedExtensionsInUse = 215;
    int32 unknownFields = 216;
    int32 Fixed = 217;
    int32 Fract = 218;
    int32 Size = 219;
    int32 LogicalAddress = 220;
    int32 PhysicalAddress = 221;
    int32 ByteCount = 222;
    int32 ByteOffset = 223;
    int32 Duration = 224;
    int32 AbsoluteTime = 225;
    int32 OptionBits = 226;
    int32 ItemCount = 227;
    int32 PBVersion = 228;
    int32 ScriptCode = 229;
    int32 LangCode = 230;
    int32 RegionCode = 231;
    int32 OSType = 232;
    int32 ProcessSerialNumber = 233;
    int32 Point = 234;
    int32 Rect = 235;
    int32 FixedPoint = 236;
    int32 FixedRect = 237;
    int32 Style = 238;
    int32 StyleParameter = 239;
    int32 StyleField = 240;
    int32 TimeScale = 241;
    int32 TimeBase = 242;
    int32 TimeRecord = 243;
    int32 json_should_be_overriden = 244 [json_name = "json_was_overridden"];
}

message MessageNames {
    message String { int32 a = 1; }
    message Protocol { int32 a = 1; }
    message Int { int32 a = 1; }
    message Double { int32 a = 1; }
    message Float { int32 a = 1; }
    message UInt { int32 a = 1; }
    message hashValue { int32 a = 1; }
    message description { int32 a = 1; }
    message debugDescription { int32 a = 1; }
    message Swift { int32 a = 1; }
    message UNRECOGNIZED { int32 a = 1; }
    message class { int32 a = 1; }
    message deinit { int32 a = 1; }
    message enum { int32 a = 1; }
    message extension { int32 a = 1; }
    message func { int32 a = 1; }
    message import { int32 a = 1; }
    message init { int32 a = 1; }
    message inout { int32 a = 1; }
    message internal { int32 a = 1; }
    message let { int32 a = 1; }
    message operator { int32 a = 1; }
    message private { int32 a = 1; }
    message protocol { int32 a = 1; }
    message public { int32 a = 1; }
    message static { int32 a = 1; }
    message struct { int32 a = 1; }
    message subscript { int32 a = 1; }
    message typealias { int32 a = 1; }
    message var { int32 a = 1; }
    message break { int32 a = 1; }
    message case { int32 a = 1; }
    message continue { int32 a = 1; }
    message default { int32 a = 1; }
    message defer { int32 a = 1; }
    message do { int32 a = 1; }
    message else { int32 a = 1; }
    message fallthrough { int32 a = 1; }
    message for { int32 a = 1; }
    message guard { int32 a = 1; }
    message if { int32 a = 1; }
    message in { int32 a = 1; }
    message repeat { int32 a = 1; }
    message return { int32 a = 1; }
    message switch { int32 a = 1; }
    message where { int32 a = 1; }
    message while { int32 a = 1; }
    message as { int32 a = 1; }
    message catch { int32 a = 1; }
    message dynamicType { int32 a = 1; }
    message false { int32 a = 1; }
    message is { int32 a = 1; }
    message nil { int32 a = 1; }
    message rethrows { int32 a = 1; }
    message super { int32 a = 1; }
    message self { int32 a = 1; }
    message throw { int32 a = 1; }
    message throws { int32 a = 1; }
    message true { int32 a = 1; }
    message try { int32 a = 1; }
    message __COLUMN__ { int32 a = 1; }
    message __FILE__ { int32 a = 1; }
    message __FUNCTION__ { int32 a = 1; }
    message __LINE__ { int32 a = 1; }
    message _ { int32 a = 1; }
    message __ { int32 a = 1; }
    message associativity { int32 a = 1; }
    message convenience { int32 a = 1; }
    message dynamic { int32 a = 1; }
    message didSet { int32 a = 1; }
    message final { int32 a = 1; }
    message get { int32 a = 1; }
    message infix { int32 a = 1; }
    message indirect { int32 a = 1; }
    message lazy { int32 a = 1; }
    message left { int32 a = 1; }
    message mutating { int32 a = 1; }
    message none { int32 a = 1; }
    message nonmutating { int32 a = 1; }
    message optional { int32 a = 1; }
    message override { int32 a = 1; }
    message postfix { int32 a = 1; }
    message precedence { int32 a = 1; }
    message prefix { int32 a = 1; }
    message required { int32 a = 1; }
    message right { int32 a = 1; }
    message set { int32 a = 1; }
    message Type { int32 a = 1; }
    message unowned { int32 a = 1; }
    message weak { int32 a = 1; }
    message willSet { int32 a = 1; }
    message id { int32 a = 1; }
    message _cmd { int32 a = 1; }
    message out { int32 a = 1; }
    message bycopy { int32 a = 1; }
    message byref { int32 a = 1; }
    message oneway { int32 a = 1; }
    message and { int32 a = 1; }
    message and_eq { int32 a = 1; }
    message alignas { int32 a = 1; }
    message alignof { int32 a = 1; }
    message asm { int32 a = 1; }
    message auto { int32 a = 1; }
    message bitand { int32 a = 1; }
    message bitor { int32 a = 1; }
    message bool { int32 a = 1; }
    message char { int32 a = 1; }
    message char16_t { int32 a = 1; }
    message char32_t { int32 a = 1; }
    message compl { int32 a = 1; }
    message const { int32 a = 1; }
    message constexpr { int32 a = 1; }
    message const_cast { int32 a = 1; }
    message decltype { int32 a = 1; }
    message delete { int32 a = 1; }
    message dynamic_cast { int32 a = 1; }
    message explicit { int32 a = 1; }
    message export { int32 a = 1; }
    message extern  { int32 a = 1; }
    message friend { int32 a = 1; }
    message goto { int32 a = 1; }
    message inline { int32 a = 1; }
    message long { int32 a = 1; }
    message mutable { int32 a = 1; }
    message namespace { int32 a = 1; }
    message new { int32 a = 1; }
    message noexcept { int32 a = 1; }
    message not { int32 a = 1; }
    message not_eq { int32 a = 1; }
    message nullptr { int32 a = 1; }
    message or { int32 a = 1; }
    message or_eq { int32 a = 1; }
    message protected { int32 a = 1; }
    message register { int32 a = 1; }
    message reinterpret_cast { int32 a = 1; }
    message short { int32 a = 1; }
    message signed { int32 a = 1; }
    message sizeof { int32 a = 1; }
    message static_assert { int32 a = 1; }
    message static_cast { int32 a = 1; }
    message template { int32 a = 1; }
    message this { int32 a = 1; }
    message thread_local { int32 a = 1; }
    message typedef { int32 a = 1; }
    message typeid { int32 a = 1; }
    message typename { int32 a = 1; }
    message union { int32 a = 1; }
    message unsigned { int32 a = 1; }
    message using { int32 a = 1; }
    message virtual { int32 a = 1; }
    message void { int32 a = 1; }
    message volatile { int32 a = 1; }
    message wchar_t { int32 a = 1; }
    message xor { int32 a = 1; }
    message xor_eq { int32 a = 1; }
    message restrict { int32 a = 1; }
    message Category { int32 a = 1; }
    message Ivar { int32 a = 1; }
    message Method { int32 a = 1; }
    message finalize { int32 a = 1; }
    message hash { int32 a = 1; }
    message dealloc { int32 a = 1; }
    message superclass { int32 a = 1; }
    message retain { int32 a = 1; }
    message release { int32 a = 1; }
    message autorelease { int32 a = 1; }
    message retainCount { int32 a = 1; }
    message zone { int32 a = 1; }
    message isProxy { int32 a = 1; }
    message copy { int32 a = 1; }
    message mutableCopy { int32 a = 1; }
    message classForCoder { int32 a = 1; }
    message clear { int32 a = 1; }
    message data { int32 a = 1; }
    message delimitedData { int32 a = 1; }
    message descriptor { int32 a = 1; }
    message extensionRegistry { int32 a = 1; }
    message extensionsCurrentlySet { int32 a = 1; }
    message isInitialized { int32 a = 1; }
    message serializedSize { int32 a = 1; }
    message sortedExtensionsInUse { int32 a = 1; }
    message unknownFields { int32 a = 1; }
    message Fixed { int32 a = 1; }
    message Fract { int32 a = 1; }
    message Size { int32 a = 1; }
    message LogicalAddress { int32 a = 1; }
    message PhysicalAddress { int32 a = 1; }
    message ByteCount { int32 a = 1; }
    message ByteOffset { int32 a = 1; }
    message Duration { int32 a = 1; }
    message AbsoluteTime { int32 a = 1; }
    message OptionBits { int32 a = 1; }
    message ItemCount { int32 a = 1; }
    message PBVersion { int32 a = 1; }
    message ScriptCode { int32 a = 1; }
    message LangCode { int32 a = 1; }
    message RegionCode { int32 a = 1; }
    message OSType { int32 a = 1; }
    message ProcessSerialNumber { int32 a = 1; }
    message Point { int32 a = 1; }
    message Rect { int32 a = 1; }
    message FixedPoint { int32 a = 1; }
    message FixedRect { int32 a = 1; }
    message Style { int32 a = 1; }
    message StyleParameter { int32 a = 1; }
    message StyleField { int32 a = 1; }
    message TimeScale { int32 a = 1; }
    message TimeBase { int32 a = 1; }
    message TimeRecord { int32 a = 1; }
}

message EnumNames {
    enum String { aString = 0; }
    enum Protocol { aProtocol = 0; }
    enum Int { aInt = 0; }
    enum Double { aDouble = 0; }
    enum Float { aFloat = 0; }
    enum UInt { aUInt = 0; }
    enum hashValue { ahashValue = 0; }
    enum description { adescription = 0; }
    enum debugDescription { adebugDescription = 0; }
    enum Swift { aSwift = 0; }
    enum UNRECOGNIZED { aUNRECOGNIZED = 0; }
    enum class { aclass = 0; }
    enum deinit { adeinit = 0; }
    enum enum { aenum = 0; }
    enum extension { aextension = 0; }
    enum func { afunc = 0; }
    enum import { aimport = 0; }
    enum init { ainit = 0; }
    enum inout { ainout = 0; }
    enum internal { ainternal = 0; }
    enum let { alet = 0; }
    enum operator { aoperator = 0; }
    enum private { aprivate = 0; }
    enum protocol { aprotocol = 0; }
    enum public { apublic = 0; }
    enum static { astatic = 0; }
    enum struct { astruct = 0; }
    enum subscript { asubscript = 0; }
    enum typealias { atypealias = 0; }
    enum var { avar = 0; }
    enum break { abreak = 0; }
    enum case { acase = 0; }
    enum continue { acontinue = 0; }
    enum default { adefault = 0; }
    enum defer { adefer = 0; }
    enum do { ado = 0; }
    enum else { aelse = 0; }
    enum fallthrough { afallthrough = 0; }
    enum for { afor = 0; }
    enum guard { aguard = 0; }
    enum if { aif = 0; }
    enum in { ain = 0; }
    enum repeat { arepeat = 0; }
    enum return { areturn = 0; }
    enum switch { aswitch = 0; }
    enum where { awhere = 0; }
    enum while { awhile = 0; }
    enum as { aas = 0; }
    enum catch { acatch = 0; }
    enum dynamicType { adynamicType = 0; }
    enum false { afalse = 0; }
    enum is { ais = 0; }
    enum nil { anil = 0; }
    enum rethrows { arethrows = 0; }
    enum super { asuper = 0; }
    enum self { aself = 0; }
    enum throw { athrow = 0; }
    enum throws { athrows = 0; }
    enum true { atrue = 0; }
    enum try { atry = 0; }
    enum __COLUMN__ { a__COLUMN__ = 0; }
    enum __FILE__ { a__FILE__ = 0; }
    enum __FUNCTION__ { a__FUNCTION__ = 0; }
    enum __LINE__ { a__LINE__ = 0; }
    enum _ { a_ = 0; }
    enum __ { a__ = 0; }
    enum associativity { aassociativity = 0; }
    enum convenience { aconvenience = 0; }
    enum dynamic { adynamic = 0; }
    enum didSet { adidSet = 0; }
    enum final { afinal = 0; }
    enum get { aget = 0; }
    enum infix { ainfix = 0; }
    enum indirect { aindirect = 0; }
    enum lazy { alazy = 0; }
    enum left { aleft = 0; }
    enum mutating { amutating = 0; }
    enum none { anone = 0; }
    enum nonmutating { anonmutating = 0; }
    enum optional { aoptional = 0; }
    enum override { aoverride = 0; }
    enum postfix { apostfix = 0; }
    enum precedence { aprecedence = 0; }
    enum prefix { aprefix = 0; }
    enum required { arequired = 0; }
    enum right { aright = 0; }
    enum set { aset = 0; }
    enum Type { aType = 0; }
    enum unowned { aunowned = 0; }
    enum weak { aweak = 0; }
    enum willSet { awillSet = 0; }
    enum id { aid = 0; }
    enum _cmd { a_cmd = 0; }
    enum out { aout = 0; }
    enum bycopy { abycopy = 0; }
    enum byref { abyref = 0; }
    enum oneway { aoneway = 0; }
    enum and { aand = 0; }
    enum and_eq { aand_eq = 0; }
    enum alignas { aalignas = 0; }
    enum alignof { aalignof = 0; }
    enum asm { aasm = 0; }
    enum auto { aauto = 0; }
    enum bitand { abitand = 0; }
    enum bitor { abitor = 0; }
    enum bool { abool = 0; }
    enum char { achar = 0; }
    enum char16_t { achar16_t = 0; }
    enum char32_t { achar32_t = 0; }
    enum compl { acompl = 0; }
    enum const { aconst = 0; }
    enum constexpr { aconstexpr = 0; }
    enum const_cast { aconst_cast = 0; }
    enum decltype { adecltype = 0; }
    enum delete { adelete = 0; }
    enum dynamic_cast { adynamic_cast = 0; }
    enum explicit { aexplicit = 0; }
    enum export { aexport = 0; }
    enum extern  { aextern  = 0; }
    enum friend { afriend = 0; }
    enum goto { agoto = 0; }
    enum inline { ainline = 0; }
    enum long { along = 0; }
    enum mutable { amutable = 0; }
    enum namespace { anamespace = 0; }
    enum new { anew = 0; }
    enum noexcept { anoexcept = 0; }
    enum not { anot = 0; }
    enum not_eq { anot_eq = 0; }
    enum nullptr { anullptr = 0; }
    enum or { aor = 0; }
    enum or_eq { aor_eq = 0; }
    enum protected { aprotected = 0; }
    enum register { aregister = 0; }
    enum reinterpret_cast { areinterpret_cast = 0; }
    enum short { ashort = 0; }
    enum signed { asigned = 0; }
    enum sizeof { asizeof = 0; }
    enum static_assert { astatic_assert = 0; }
    enum static_cast { astatic_cast = 0; }
    enum template { atemplate = 0; }
    enum this { athis = 0; }
    enum thread_local { athread_local = 0; }
    enum typedef { atypedef = 0; }
    enum typeid { atypeid = 0; }
    enum typename { atypename = 0; }
    enum union { aunion = 0; }
    enum unsigned { aunsigned = 0; }
    enum using { ausing = 0; }
    enum virtual { avirtual = 0; }
    enum void { avoid = 0; }
    enum volatile { avolatile = 0; }
    enum wchar_t { awchar_t = 0; }
    enum xor { axor = 0; }
    enum xor_eq { axor_eq = 0; }
    enum restrict { arestrict = 0; }
    enum Category { aCategory = 0; }
    enum Ivar { aIvar = 0; }
    enum Method { aMethod = 0; }
    enum finalize { afinalize = 0; }
    enum hash { ahash = 0; }
    enum dealloc { adealloc = 0; }
    enum superclass { asuperclass = 0; }
    enum retain { aretain = 0; }
    enum release { arelease = 0; }
    enum autorelease { aautorelease = 0; }
    enum retainCount { aretainCount = 0; }
    enum zone { azone = 0; }
    enum isProxy { aisProxy = 0; }
    enum copy { acopy = 0; }
    enum mutableCopy { amutableCopy = 0; }
    enum classForCoder { aclassForCoder = 0; }
    enum clear { aclear = 0; }
    enum data { adata = 0; }
    enum delimitedData { adelimitedData = 0; }
    enum descriptor { adescriptor = 0; }
    enum extensionRegistry { aextensionRegistry = 0; }
    enum extensionsCurrentlySet { aextensionsCurrentlySet = 0; }
    enum isInitialized { aisInitialized = 0; }
    enum serializedSize { aserializedSize = 0; }
    enum sortedExtensionsInUse { asortedExtensionsInUse = 0; }
    enum unknownFields { aunknownFields = 0; }
    enum Fixed { aFixed = 0; }
    enum Fract { aFract = 0; }
    enum Size { aSize = 0; }
    enum LogicalAddress { aLogicalAddress = 0; }
    enum PhysicalAddress { aPhysicalAddress = 0; }
    enum ByteCount { aByteCount = 0; }
    enum ByteOffset { aByteOffset = 0; }
    enum Duration { aDuration = 0; }
    enum AbsoluteTime { aAbsoluteTime = 0; }
    enum OptionBits { aOptionBits = 0; }
    enum ItemCount { aItemCount = 0; }
    enum PBVersion { aPBVersion = 0; }
    enum ScriptCode { aScriptCode = 0; }
    enum LangCode { aLangCode = 0; }
    enum RegionCode { aRegionCode = 0; }
    enum OSType { aOSType = 0; }
    enum ProcessSerialNumber { aProcessSerialNumber = 0; }
    enum Point { aPoint = 0; }
    enum Rect { aRect = 0; }
    enum FixedPoint { aFixedPoint = 0; }
    enum FixedRect { aFixedRect = 0; }
    enum Style { aStyle = 0; }
    enum StyleParameter { aStyleParameter = 0; }
    enum StyleField { aStyleField = 0; }
    enum TimeScale { aTimeScale = 0; }
    enum TimeBase { aTimeBase = 0; }
    enum TimeRecord { aTimeRecord = 0; }
}

enum EnumFieldNames {
    A = 0;
    String = 1;
    Int = 2;
    Double = 3;
    Float = 4;
    UInt = 5;
    hashValue = 6;
    description = 7;
    debugDescription = 8;
    Swift = 9;
    UNRECOGNIZED = 10;
    class = 11;
    deinit = 12;
    enum = 13;
    extension = 14;
    func = 15;
    import = 16;
    init = 17;
    inout = 18;
    internal = 19;
    let = 20;
    operator = 21;
    private = 22;
    protocol = 23;
    public = 24;
    static = 25;
    struct = 26;
    subscript = 27;
    typealias = 28;
    var = 29;
    break = 30;
    case = 31;
    continue = 32;
    default = 33;
    defer = 34;
    do = 35;
    else = 36;
    fallthrough = 37;
    for = 38;
    guard = 39;
    if = 40;
    in = 41;
    repeat = 42;
    return = 43;
    switch = 44;
    where = 45;
    while = 46;
    as = 47;
    catch = 48;
    dynamicType = 49;
    false = 50;
    is = 51;
    nil = 52;
    rethrows = 53;
    super = 54;
    self = 55;
    throw = 57;
    throws = 58;
    true = 59;
    try = 60;
    __COLUMN__ = 61;
    __FILE__ = 62;
    __FUNCTION__ = 63;
    __LINE__ = 64;
    _ = 65;
    associativity = 66;
    convenience = 67;
    dynamic = 68;
    didSet = 69;
    final = 70;
    get = 71;
    infix = 72;
    indirect = 73;
    lazy = 74;
    left = 75;
    mutating = 76;
    none = 77;
    nonmutating = 78;
    optional = 79;
    override = 80;
    postfix = 81;
    precedence = 82;
    prefix = 83;
    required = 85;
    right = 86;
    set = 87;
    Type = 88;
    unowned = 89;
    weak = 90;
    willSet = 91;
    id = 92;
    _cmd = 93;
    out = 96;
    bycopy = 98;
    byref = 99;
    oneway = 100;
    and = 102;
    and_eq = 103;
    alignas = 104;
    alignof = 105;
    asm = 106;
    auto = 107;
    bitand = 108;
    bitor = 109;
    bool = 110;
    char = 114;
    char16_t = 115;
    char32_t = 116;
    compl = 118;
    const = 119;
    constexpr = 120;
    const_cast = 121;
    decltype = 123;
    delete = 125;
    dynamic_cast = 127;
    explicit = 130;
    export = 131;
    extern  = 132;
    friend = 136;
    goto = 137;
    inline = 139;
    long = 141;
    mutable = 142;
    namespace = 143;
    new = 144;
    noexcept = 145;
    not = 146;
    not_eq = 147;
    nullptr = 148;
    or = 150;
    or_eq = 151;
    protected = 153;
    register = 155;
    reinterpret_cast = 156;
    short = 158;
    signed = 159;
    sizeof = 160;
    static_assert = 162;
    static_cast = 163;
    template = 166;
    this = 167;
    thread_local = 168;
    typedef = 172;
    typeid = 173;
    typename = 174;
    union = 175;
    unsigned = 176;
    using = 177;
    virtual = 178;
    void = 179;
    volatile = 180;
    wchar_t = 181;
    xor = 183;
    xor_eq = 184;
    restrict = 185;
    Category = 186;
    Ivar = 187;
    Method = 188;
    finalize = 192;
    hash = 193;
    dealloc = 194;
    superclass = 197;
    retain = 198;
    release = 199;
    autorelease = 200;
    retainCount = 201;
    zone = 202;
    isProxy = 203;
    copy = 204;
    mutableCopy = 205;
    classForCoder = 206;
    clear = 207;
    data = 208;
    delimitedData = 209;
    descriptor = 210;
    extensionRegistry = 211;
    extensionsCurrentlySet = 212;
    isInitialized = 213;
    serializedSize = 214;
    sortedExtensionsInUse = 215;
    unknownFields = 216;
    Fixed = 217;
    Fract = 218;
    Size = 219;
    LogicalAddress = 220;
    PhysicalAddress = 221;
    ByteCount = 222;
    ByteOffset = 223;
    Duration = 224;
    AbsoluteTime = 225;
    OptionBits = 226;
    ItemCount = 227;
    PBVersion = 228;
    ScriptCode = 229;
    LangCode = 230;
    RegionCode = 231;
    OSType = 232;
    ProcessSerialNumber = 233;
    Point = 234;
    Rect = 235;
    FixedPoint = 236;
    FixedRect = 237;
    Style = 238;
    StyleParameter = 239;
    StyleField = 240;
    TimeScale = 241;
    TimeBase = 242;
    TimeRecord = 243;
}

enum EnumFieldNames2 {
    AA = 0;

    // protoc no longer allows enum naming that would differ only in underscores.
    // Initial commit:
    //   https://github.com/google/protobuf/commit/cc8ca5b6a5478b40546d4206392eb1471454460d
    // Change keep proto3 as error, but proto2 to just a warning:
    //   https://github.com/google/protobuf/pull/2204
    // So this is in a second enum so it won't cause issues with the '_' one;
    // but still ensure things generator correctly.
    __ = 1065;
}
