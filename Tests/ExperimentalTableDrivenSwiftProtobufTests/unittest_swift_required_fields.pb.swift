// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: unittest_swift_required_fields.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Protos/unittest_swift_required_fields.proto - test proto for required fields
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2025 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
// -----------------------------------------------------------------------------
///
/// Test how required field has-bits are checked.
///
// -----------------------------------------------------------------------------

@_spi(ForGeneratedCodeOnly) import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Just a single reserved field.
struct SwiftProtoTesting_Required1: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var req1: Int64 {
    get { return _storage.value(at: 8, default: 0, hasBit: (0, 1)) }
    set { _uniqueStorage().updateValue(at: 8, to: newValue, willBeSet: true, hasBit: (0, 1)) }
  }
  /// Returns true if `req1` has been explicitly set.
  var hasReq1: Bool { return _storage.isPresent(hasBit: (0, 1)) }
  /// Clears the value of `req1`. Subsequent reads from it will return its default value.
  mutating func clearReq1() { _uniqueStorage().clearValue(at: 8, type: Int64.self, hasBit: (0, 1)) }

  var opt2: Int64 {
    get { return _storage.value(at: 16, default: 0, hasBit: (0, 2)) }
    set { _uniqueStorage().updateValue(at: 16, to: newValue, willBeSet: true, hasBit: (0, 2)) }
  }
  /// Returns true if `opt2` has been explicitly set.
  var hasOpt2: Bool { return _storage.isPresent(hasBit: (0, 2)) }
  /// Clears the value of `opt2`. Subsequent reads from it will return its default value.
  mutating func clearOpt2() { _uniqueStorage().clearValue(at: 16, type: Int64.self, hasBit: (0, 2)) }

  var opt3: Int64 {
    get { return _storage.value(at: 24, default: 0, hasBit: (0, 4)) }
    set { _uniqueStorage().updateValue(at: 24, to: newValue, willBeSet: true, hasBit: (0, 4)) }
  }
  /// Returns true if `opt3` has been explicitly set.
  var hasOpt3: Bool { return _storage.isPresent(hasBit: (0, 4)) }
  /// Clears the value of `opt3`. Subsequent reads from it will return its default value.
  mutating func clearOpt3() { _uniqueStorage().clearValue(at: 24, type: Int64.self, hasBit: (0, 4)) }

  var opt4: Int64 {
    get { return _storage.value(at: 32, default: 0, hasBit: (0, 8)) }
    set { _uniqueStorage().updateValue(at: 32, to: newValue, willBeSet: true, hasBit: (0, 8)) }
  }
  /// Returns true if `opt4` has been explicitly set.
  var hasOpt4: Bool { return _storage.isPresent(hasBit: (0, 8)) }
  /// Clears the value of `opt4`. Subsequent reads from it will return its default value.
  mutating func clearOpt4() { _uniqueStorage().clearValue(at: 32, type: Int64.self, hasBit: (0, 8)) }

  var unknownFields: SwiftProtobuf.UnknownStorage {
    get { _storage.unknownFields }
    _modify {
      _ = _uniqueStorage()
      yield &_storage.unknownFields
    }
  }

  init() {}

  private var _storage = SwiftProtobuf._MessageStorage(layout: Self._protobuf_messageLayout)

  private mutating func _uniqueStorage() -> SwiftProtobuf._MessageStorage {
    if !isKnownUniquelyReferenced(&_storage) { _storage = _storage.copy() }
    return _storage
  }
}

/// A full byte's worth of reserved fields.
struct SwiftProtoTesting_Required8: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var req1: Int64 {
    get { return _storage.value(at: 8, default: 0, hasBit: (0, 1)) }
    set { _uniqueStorage().updateValue(at: 8, to: newValue, willBeSet: true, hasBit: (0, 1)) }
  }
  /// Returns true if `req1` has been explicitly set.
  var hasReq1: Bool { return _storage.isPresent(hasBit: (0, 1)) }
  /// Clears the value of `req1`. Subsequent reads from it will return its default value.
  mutating func clearReq1() { _uniqueStorage().clearValue(at: 8, type: Int64.self, hasBit: (0, 1)) }

  var req2: Int64 {
    get { return _storage.value(at: 16, default: 0, hasBit: (0, 2)) }
    set { _uniqueStorage().updateValue(at: 16, to: newValue, willBeSet: true, hasBit: (0, 2)) }
  }
  /// Returns true if `req2` has been explicitly set.
  var hasReq2: Bool { return _storage.isPresent(hasBit: (0, 2)) }
  /// Clears the value of `req2`. Subsequent reads from it will return its default value.
  mutating func clearReq2() { _uniqueStorage().clearValue(at: 16, type: Int64.self, hasBit: (0, 2)) }

  var req3: Int64 {
    get { return _storage.value(at: 24, default: 0, hasBit: (0, 4)) }
    set { _uniqueStorage().updateValue(at: 24, to: newValue, willBeSet: true, hasBit: (0, 4)) }
  }
  /// Returns true if `req3` has been explicitly set.
  var hasReq3: Bool { return _storage.isPresent(hasBit: (0, 4)) }
  /// Clears the value of `req3`. Subsequent reads from it will return its default value.
  mutating func clearReq3() { _uniqueStorage().clearValue(at: 24, type: Int64.self, hasBit: (0, 4)) }

  var req4: Int64 {
    get { return _storage.value(at: 32, default: 0, hasBit: (0, 8)) }
    set { _uniqueStorage().updateValue(at: 32, to: newValue, willBeSet: true, hasBit: (0, 8)) }
  }
  /// Returns true if `req4` has been explicitly set.
  var hasReq4: Bool { return _storage.isPresent(hasBit: (0, 8)) }
  /// Clears the value of `req4`. Subsequent reads from it will return its default value.
  mutating func clearReq4() { _uniqueStorage().clearValue(at: 32, type: Int64.self, hasBit: (0, 8)) }

  var req5: Int64 {
    get { return _storage.value(at: 40, default: 0, hasBit: (0, 16)) }
    set { _uniqueStorage().updateValue(at: 40, to: newValue, willBeSet: true, hasBit: (0, 16)) }
  }
  /// Returns true if `req5` has been explicitly set.
  var hasReq5: Bool { return _storage.isPresent(hasBit: (0, 16)) }
  /// Clears the value of `req5`. Subsequent reads from it will return its default value.
  mutating func clearReq5() { _uniqueStorage().clearValue(at: 40, type: Int64.self, hasBit: (0, 16)) }

  var req6: Int64 {
    get { return _storage.value(at: 48, default: 0, hasBit: (0, 32)) }
    set { _uniqueStorage().updateValue(at: 48, to: newValue, willBeSet: true, hasBit: (0, 32)) }
  }
  /// Returns true if `req6` has been explicitly set.
  var hasReq6: Bool { return _storage.isPresent(hasBit: (0, 32)) }
  /// Clears the value of `req6`. Subsequent reads from it will return its default value.
  mutating func clearReq6() { _uniqueStorage().clearValue(at: 48, type: Int64.self, hasBit: (0, 32)) }

  var req7: Int64 {
    get { return _storage.value(at: 56, default: 0, hasBit: (0, 64)) }
    set { _uniqueStorage().updateValue(at: 56, to: newValue, willBeSet: true, hasBit: (0, 64)) }
  }
  /// Returns true if `req7` has been explicitly set.
  var hasReq7: Bool { return _storage.isPresent(hasBit: (0, 64)) }
  /// Clears the value of `req7`. Subsequent reads from it will return its default value.
  mutating func clearReq7() { _uniqueStorage().clearValue(at: 56, type: Int64.self, hasBit: (0, 64)) }

  var req8: Int64 {
    get { return _storage.value(at: 64, default: 0, hasBit: (0, 128)) }
    set { _uniqueStorage().updateValue(at: 64, to: newValue, willBeSet: true, hasBit: (0, 128)) }
  }
  /// Returns true if `req8` has been explicitly set.
  var hasReq8: Bool { return _storage.isPresent(hasBit: (0, 128)) }
  /// Clears the value of `req8`. Subsequent reads from it will return its default value.
  mutating func clearReq8() { _uniqueStorage().clearValue(at: 64, type: Int64.self, hasBit: (0, 128)) }

  var req9: Int64 {
    get { return _storage.value(at: 72, default: 0, hasBit: (1, 1)) }
    set { _uniqueStorage().updateValue(at: 72, to: newValue, willBeSet: true, hasBit: (1, 1)) }
  }
  /// Returns true if `req9` has been explicitly set.
  var hasReq9: Bool { return _storage.isPresent(hasBit: (1, 1)) }
  /// Clears the value of `req9`. Subsequent reads from it will return its default value.
  mutating func clearReq9() { _uniqueStorage().clearValue(at: 72, type: Int64.self, hasBit: (1, 1)) }

  var req10: Int64 {
    get { return _storage.value(at: 80, default: 0, hasBit: (1, 2)) }
    set { _uniqueStorage().updateValue(at: 80, to: newValue, willBeSet: true, hasBit: (1, 2)) }
  }
  /// Returns true if `req10` has been explicitly set.
  var hasReq10: Bool { return _storage.isPresent(hasBit: (1, 2)) }
  /// Clears the value of `req10`. Subsequent reads from it will return its default value.
  mutating func clearReq10() { _uniqueStorage().clearValue(at: 80, type: Int64.self, hasBit: (1, 2)) }

  var unknownFields: SwiftProtobuf.UnknownStorage {
    get { _storage.unknownFields }
    _modify {
      _ = _uniqueStorage()
      yield &_storage.unknownFields
    }
  }

  init() {}

  private var _storage = SwiftProtobuf._MessageStorage(layout: Self._protobuf_messageLayout)

  private mutating func _uniqueStorage() -> SwiftProtobuf._MessageStorage {
    if !isKnownUniquelyReferenced(&_storage) { _storage = _storage.copy() }
    return _storage
  }
}

/// A full byte's worth of reserved fields, plus some overflow.
struct SwiftProtoTesting_Required9: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var req1: Int64 {
    get { return _storage.value(at: 8, default: 0, hasBit: (0, 1)) }
    set { _uniqueStorage().updateValue(at: 8, to: newValue, willBeSet: true, hasBit: (0, 1)) }
  }
  /// Returns true if `req1` has been explicitly set.
  var hasReq1: Bool { return _storage.isPresent(hasBit: (0, 1)) }
  /// Clears the value of `req1`. Subsequent reads from it will return its default value.
  mutating func clearReq1() { _uniqueStorage().clearValue(at: 8, type: Int64.self, hasBit: (0, 1)) }

  var req2: Int64 {
    get { return _storage.value(at: 16, default: 0, hasBit: (0, 2)) }
    set { _uniqueStorage().updateValue(at: 16, to: newValue, willBeSet: true, hasBit: (0, 2)) }
  }
  /// Returns true if `req2` has been explicitly set.
  var hasReq2: Bool { return _storage.isPresent(hasBit: (0, 2)) }
  /// Clears the value of `req2`. Subsequent reads from it will return its default value.
  mutating func clearReq2() { _uniqueStorage().clearValue(at: 16, type: Int64.self, hasBit: (0, 2)) }

  var req3: Int64 {
    get { return _storage.value(at: 24, default: 0, hasBit: (0, 4)) }
    set { _uniqueStorage().updateValue(at: 24, to: newValue, willBeSet: true, hasBit: (0, 4)) }
  }
  /// Returns true if `req3` has been explicitly set.
  var hasReq3: Bool { return _storage.isPresent(hasBit: (0, 4)) }
  /// Clears the value of `req3`. Subsequent reads from it will return its default value.
  mutating func clearReq3() { _uniqueStorage().clearValue(at: 24, type: Int64.self, hasBit: (0, 4)) }

  var req4: Int64 {
    get { return _storage.value(at: 32, default: 0, hasBit: (0, 8)) }
    set { _uniqueStorage().updateValue(at: 32, to: newValue, willBeSet: true, hasBit: (0, 8)) }
  }
  /// Returns true if `req4` has been explicitly set.
  var hasReq4: Bool { return _storage.isPresent(hasBit: (0, 8)) }
  /// Clears the value of `req4`. Subsequent reads from it will return its default value.
  mutating func clearReq4() { _uniqueStorage().clearValue(at: 32, type: Int64.self, hasBit: (0, 8)) }

  var req5: Int64 {
    get { return _storage.value(at: 40, default: 0, hasBit: (0, 16)) }
    set { _uniqueStorage().updateValue(at: 40, to: newValue, willBeSet: true, hasBit: (0, 16)) }
  }
  /// Returns true if `req5` has been explicitly set.
  var hasReq5: Bool { return _storage.isPresent(hasBit: (0, 16)) }
  /// Clears the value of `req5`. Subsequent reads from it will return its default value.
  mutating func clearReq5() { _uniqueStorage().clearValue(at: 40, type: Int64.self, hasBit: (0, 16)) }

  var req6: Int64 {
    get { return _storage.value(at: 48, default: 0, hasBit: (0, 32)) }
    set { _uniqueStorage().updateValue(at: 48, to: newValue, willBeSet: true, hasBit: (0, 32)) }
  }
  /// Returns true if `req6` has been explicitly set.
  var hasReq6: Bool { return _storage.isPresent(hasBit: (0, 32)) }
  /// Clears the value of `req6`. Subsequent reads from it will return its default value.
  mutating func clearReq6() { _uniqueStorage().clearValue(at: 48, type: Int64.self, hasBit: (0, 32)) }

  var req7: Int64 {
    get { return _storage.value(at: 56, default: 0, hasBit: (0, 64)) }
    set { _uniqueStorage().updateValue(at: 56, to: newValue, willBeSet: true, hasBit: (0, 64)) }
  }
  /// Returns true if `req7` has been explicitly set.
  var hasReq7: Bool { return _storage.isPresent(hasBit: (0, 64)) }
  /// Clears the value of `req7`. Subsequent reads from it will return its default value.
  mutating func clearReq7() { _uniqueStorage().clearValue(at: 56, type: Int64.self, hasBit: (0, 64)) }

  var req8: Int64 {
    get { return _storage.value(at: 64, default: 0, hasBit: (0, 128)) }
    set { _uniqueStorage().updateValue(at: 64, to: newValue, willBeSet: true, hasBit: (0, 128)) }
  }
  /// Returns true if `req8` has been explicitly set.
  var hasReq8: Bool { return _storage.isPresent(hasBit: (0, 128)) }
  /// Clears the value of `req8`. Subsequent reads from it will return its default value.
  mutating func clearReq8() { _uniqueStorage().clearValue(at: 64, type: Int64.self, hasBit: (0, 128)) }

  var req9: Int64 {
    get { return _storage.value(at: 72, default: 0, hasBit: (1, 1)) }
    set { _uniqueStorage().updateValue(at: 72, to: newValue, willBeSet: true, hasBit: (1, 1)) }
  }
  /// Returns true if `req9` has been explicitly set.
  var hasReq9: Bool { return _storage.isPresent(hasBit: (1, 1)) }
  /// Clears the value of `req9`. Subsequent reads from it will return its default value.
  mutating func clearReq9() { _uniqueStorage().clearValue(at: 72, type: Int64.self, hasBit: (1, 1)) }

  var req10: Int64 {
    get { return _storage.value(at: 80, default: 0, hasBit: (1, 2)) }
    set { _uniqueStorage().updateValue(at: 80, to: newValue, willBeSet: true, hasBit: (1, 2)) }
  }
  /// Returns true if `req10` has been explicitly set.
  var hasReq10: Bool { return _storage.isPresent(hasBit: (1, 2)) }
  /// Clears the value of `req10`. Subsequent reads from it will return its default value.
  mutating func clearReq10() { _uniqueStorage().clearValue(at: 80, type: Int64.self, hasBit: (1, 2)) }

  var req11: Int64 {
    get { return _storage.value(at: 88, default: 0, hasBit: (1, 4)) }
    set { _uniqueStorage().updateValue(at: 88, to: newValue, willBeSet: true, hasBit: (1, 4)) }
  }
  /// Returns true if `req11` has been explicitly set.
  var hasReq11: Bool { return _storage.isPresent(hasBit: (1, 4)) }
  /// Clears the value of `req11`. Subsequent reads from it will return its default value.
  mutating func clearReq11() { _uniqueStorage().clearValue(at: 88, type: Int64.self, hasBit: (1, 4)) }

  var unknownFields: SwiftProtobuf.UnknownStorage {
    get { _storage.unknownFields }
    _modify {
      _ = _uniqueStorage()
      yield &_storage.unknownFields
    }
  }

  init() {}

  private var _storage = SwiftProtobuf._MessageStorage(layout: Self._protobuf_messageLayout)

  private mutating func _uniqueStorage() -> SwiftProtobuf._MessageStorage {
    if !isKnownUniquelyReferenced(&_storage) { _storage = _storage.copy() }
    return _storage
  }
}

/// Reserved fields intermixed with optional fields.
struct SwiftProtoTesting_RequiredMixedOrder: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var req1: Int64 {
    get { return _storage.value(at: 8, default: 0, hasBit: (0, 1)) }
    set { _uniqueStorage().updateValue(at: 8, to: newValue, willBeSet: true, hasBit: (0, 1)) }
  }
  /// Returns true if `req1` has been explicitly set.
  var hasReq1: Bool { return _storage.isPresent(hasBit: (0, 1)) }
  /// Clears the value of `req1`. Subsequent reads from it will return its default value.
  mutating func clearReq1() { _uniqueStorage().clearValue(at: 8, type: Int64.self, hasBit: (0, 1)) }

  var opt2: Int64 {
    get { return _storage.value(at: 16, default: 0, hasBit: (0, 16)) }
    set { _uniqueStorage().updateValue(at: 16, to: newValue, willBeSet: true, hasBit: (0, 16)) }
  }
  /// Returns true if `opt2` has been explicitly set.
  var hasOpt2: Bool { return _storage.isPresent(hasBit: (0, 16)) }
  /// Clears the value of `opt2`. Subsequent reads from it will return its default value.
  mutating func clearOpt2() { _uniqueStorage().clearValue(at: 16, type: Int64.self, hasBit: (0, 16)) }

  var req3: Int64 {
    get { return _storage.value(at: 24, default: 0, hasBit: (0, 2)) }
    set { _uniqueStorage().updateValue(at: 24, to: newValue, willBeSet: true, hasBit: (0, 2)) }
  }
  /// Returns true if `req3` has been explicitly set.
  var hasReq3: Bool { return _storage.isPresent(hasBit: (0, 2)) }
  /// Clears the value of `req3`. Subsequent reads from it will return its default value.
  mutating func clearReq3() { _uniqueStorage().clearValue(at: 24, type: Int64.self, hasBit: (0, 2)) }

  var opt4: Int64 {
    get { return _storage.value(at: 32, default: 0, hasBit: (0, 32)) }
    set { _uniqueStorage().updateValue(at: 32, to: newValue, willBeSet: true, hasBit: (0, 32)) }
  }
  /// Returns true if `opt4` has been explicitly set.
  var hasOpt4: Bool { return _storage.isPresent(hasBit: (0, 32)) }
  /// Clears the value of `opt4`. Subsequent reads from it will return its default value.
  mutating func clearOpt4() { _uniqueStorage().clearValue(at: 32, type: Int64.self, hasBit: (0, 32)) }

  var req5: Int64 {
    get { return _storage.value(at: 40, default: 0, hasBit: (0, 4)) }
    set { _uniqueStorage().updateValue(at: 40, to: newValue, willBeSet: true, hasBit: (0, 4)) }
  }
  /// Returns true if `req5` has been explicitly set.
  var hasReq5: Bool { return _storage.isPresent(hasBit: (0, 4)) }
  /// Clears the value of `req5`. Subsequent reads from it will return its default value.
  mutating func clearReq5() { _uniqueStorage().clearValue(at: 40, type: Int64.self, hasBit: (0, 4)) }

  var opt6: Int64 {
    get { return _storage.value(at: 48, default: 0, hasBit: (0, 64)) }
    set { _uniqueStorage().updateValue(at: 48, to: newValue, willBeSet: true, hasBit: (0, 64)) }
  }
  /// Returns true if `opt6` has been explicitly set.
  var hasOpt6: Bool { return _storage.isPresent(hasBit: (0, 64)) }
  /// Clears the value of `opt6`. Subsequent reads from it will return its default value.
  mutating func clearOpt6() { _uniqueStorage().clearValue(at: 48, type: Int64.self, hasBit: (0, 64)) }

  var req7: Int64 {
    get { return _storage.value(at: 56, default: 0, hasBit: (0, 8)) }
    set { _uniqueStorage().updateValue(at: 56, to: newValue, willBeSet: true, hasBit: (0, 8)) }
  }
  /// Returns true if `req7` has been explicitly set.
  var hasReq7: Bool { return _storage.isPresent(hasBit: (0, 8)) }
  /// Clears the value of `req7`. Subsequent reads from it will return its default value.
  mutating func clearReq7() { _uniqueStorage().clearValue(at: 56, type: Int64.self, hasBit: (0, 8)) }

  var opt8: Int64 {
    get { return _storage.value(at: 64, default: 0, hasBit: (0, 128)) }
    set { _uniqueStorage().updateValue(at: 64, to: newValue, willBeSet: true, hasBit: (0, 128)) }
  }
  /// Returns true if `opt8` has been explicitly set.
  var hasOpt8: Bool { return _storage.isPresent(hasBit: (0, 128)) }
  /// Clears the value of `opt8`. Subsequent reads from it will return its default value.
  mutating func clearOpt8() { _uniqueStorage().clearValue(at: 64, type: Int64.self, hasBit: (0, 128)) }

  var unknownFields: SwiftProtobuf.UnknownStorage {
    get { _storage.unknownFields }
    _modify {
      _ = _uniqueStorage()
      yield &_storage.unknownFields
    }
  }

  init() {}

  private var _storage = SwiftProtobuf._MessageStorage(layout: Self._protobuf_messageLayout)

  private mutating func _uniqueStorage() -> SwiftProtobuf._MessageStorage {
    if !isKnownUniquelyReferenced(&_storage) { _storage = _storage.copy() }
    return _storage
  }
}

/// A required submessage field that has required fields.
struct SwiftProtoTesting_RequiredWithNested: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nested: SwiftProtoTesting_NestedRequired {
    get { return _storage.value(at: SwiftProtobuf._fieldOffset(8, 4), default: SwiftProtoTesting_NestedRequired(), hasBit: (0, 1)) }
    set { _uniqueStorage().updateValue(at: SwiftProtobuf._fieldOffset(8, 4), to: newValue, willBeSet: true, hasBit: (0, 1)) }
  }
  /// Returns true if `nested` has been explicitly set.
  var hasNested: Bool { return _storage.isPresent(hasBit: (0, 1)) }
  /// Clears the value of `nested`. Subsequent reads from it will return its default value.
  mutating func clearNested() { _uniqueStorage().clearValue(at: SwiftProtobuf._fieldOffset(8, 4), type: SwiftProtoTesting_NestedRequired.self, hasBit: (0, 1)) }

  var unknownFields: SwiftProtobuf.UnknownStorage {
    get { _storage.unknownFields }
    _modify {
      _ = _uniqueStorage()
      yield &_storage.unknownFields
    }
  }

  init() {}

  private var _storage = SwiftProtobuf._MessageStorage(layout: Self._protobuf_messageLayout)

  private mutating func _uniqueStorage() -> SwiftProtobuf._MessageStorage {
    if !isKnownUniquelyReferenced(&_storage) { _storage = _storage.copy() }
    return _storage
  }
}

/// A repeated submessage field that has required fields.
struct SwiftProtoTesting_RequiredWithRepeatedNested: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nested: [SwiftProtoTesting_NestedRequired] {
    get { return _storage.value(at: SwiftProtobuf._fieldOffset(8, 4), hasBit: (0, 1)) }
    set { _uniqueStorage().updateValue(at: SwiftProtobuf._fieldOffset(8, 4), to: newValue, willBeSet: !newValue.isEmpty, hasBit: (0, 1)) }
  }

  var unknownFields: SwiftProtobuf.UnknownStorage {
    get { _storage.unknownFields }
    _modify {
      _ = _uniqueStorage()
      yield &_storage.unknownFields
    }
  }

  init() {}

  private var _storage = SwiftProtobuf._MessageStorage(layout: Self._protobuf_messageLayout)

  private mutating func _uniqueStorage() -> SwiftProtobuf._MessageStorage {
    if !isKnownUniquelyReferenced(&_storage) { _storage = _storage.copy() }
    return _storage
  }
}

struct SwiftProtoTesting_NestedRequired: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var req1: Int64 {
    get { return _storage.value(at: 8, default: 0, hasBit: (0, 1)) }
    set { _uniqueStorage().updateValue(at: 8, to: newValue, willBeSet: true, hasBit: (0, 1)) }
  }
  /// Returns true if `req1` has been explicitly set.
  var hasReq1: Bool { return _storage.isPresent(hasBit: (0, 1)) }
  /// Clears the value of `req1`. Subsequent reads from it will return its default value.
  mutating func clearReq1() { _uniqueStorage().clearValue(at: 8, type: Int64.self, hasBit: (0, 1)) }

  var unknownFields: SwiftProtobuf.UnknownStorage {
    get { _storage.unknownFields }
    _modify {
      _ = _uniqueStorage()
      yield &_storage.unknownFields
    }
  }

  init() {}

  private var _storage = SwiftProtobuf._MessageStorage(layout: Self._protobuf_messageLayout)

  private mutating func _uniqueStorage() -> SwiftProtobuf._MessageStorage {
    if !isKnownUniquelyReferenced(&_storage) { _storage = _storage.copy() }
    return _storage
  }
}

struct SwiftProtoTesting_NoneRequired: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var opt1: Int64 {
    get { return _storage.value(at: 8, default: 0, hasBit: (0, 1)) }
    set { _uniqueStorage().updateValue(at: 8, to: newValue, willBeSet: true, hasBit: (0, 1)) }
  }
  /// Returns true if `opt1` has been explicitly set.
  var hasOpt1: Bool { return _storage.isPresent(hasBit: (0, 1)) }
  /// Clears the value of `opt1`. Subsequent reads from it will return its default value.
  mutating func clearOpt1() { _uniqueStorage().clearValue(at: 8, type: Int64.self, hasBit: (0, 1)) }

  var opt2: SwiftProtoTesting_NestedNoneRequired {
    get { return _storage.value(at: 16, default: SwiftProtoTesting_NestedNoneRequired(), hasBit: (0, 2)) }
    set { _uniqueStorage().updateValue(at: 16, to: newValue, willBeSet: true, hasBit: (0, 2)) }
  }
  /// Returns true if `opt2` has been explicitly set.
  var hasOpt2: Bool { return _storage.isPresent(hasBit: (0, 2)) }
  /// Clears the value of `opt2`. Subsequent reads from it will return its default value.
  mutating func clearOpt2() { _uniqueStorage().clearValue(at: 16, type: SwiftProtoTesting_NestedNoneRequired.self, hasBit: (0, 2)) }

  var unknownFields: SwiftProtobuf.UnknownStorage {
    get { _storage.unknownFields }
    _modify {
      _ = _uniqueStorage()
      yield &_storage.unknownFields
    }
  }

  init() {}

  private var _storage = SwiftProtobuf._MessageStorage(layout: Self._protobuf_messageLayout)

  private mutating func _uniqueStorage() -> SwiftProtobuf._MessageStorage {
    if !isKnownUniquelyReferenced(&_storage) { _storage = _storage.copy() }
    return _storage
  }
}

struct SwiftProtoTesting_NestedNoneRequired: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var opt1: Int64 {
    get { return _storage.value(at: 8, default: 0, hasBit: (0, 1)) }
    set { _uniqueStorage().updateValue(at: 8, to: newValue, willBeSet: true, hasBit: (0, 1)) }
  }
  /// Returns true if `opt1` has been explicitly set.
  var hasOpt1: Bool { return _storage.isPresent(hasBit: (0, 1)) }
  /// Clears the value of `opt1`. Subsequent reads from it will return its default value.
  mutating func clearOpt1() { _uniqueStorage().clearValue(at: 8, type: Int64.self, hasBit: (0, 1)) }

  var unknownFields: SwiftProtobuf.UnknownStorage {
    get { _storage.unknownFields }
    _modify {
      _ = _uniqueStorage()
      yield &_storage.unknownFields
    }
  }

  init() {}

  private var _storage = SwiftProtobuf._MessageStorage(layout: Self._protobuf_messageLayout)

  private mutating func _uniqueStorage() -> SwiftProtobuf._MessageStorage {
    if !isKnownUniquelyReferenced(&_storage) { _storage = _storage.copy() }
    return _storage
  }
}

struct SwiftProtoTesting_NoneRequiredButNestedRequired: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var opt1: Int64 {
    get { return _storage.value(at: 8, default: 0, hasBit: (0, 1)) }
    set { _uniqueStorage().updateValue(at: 8, to: newValue, willBeSet: true, hasBit: (0, 1)) }
  }
  /// Returns true if `opt1` has been explicitly set.
  var hasOpt1: Bool { return _storage.isPresent(hasBit: (0, 1)) }
  /// Clears the value of `opt1`. Subsequent reads from it will return its default value.
  mutating func clearOpt1() { _uniqueStorage().clearValue(at: 8, type: Int64.self, hasBit: (0, 1)) }

  var opt2: SwiftProtoTesting_NestedRequired {
    get { return _storage.value(at: 16, default: SwiftProtoTesting_NestedRequired(), hasBit: (0, 2)) }
    set { _uniqueStorage().updateValue(at: 16, to: newValue, willBeSet: true, hasBit: (0, 2)) }
  }
  /// Returns true if `opt2` has been explicitly set.
  var hasOpt2: Bool { return _storage.isPresent(hasBit: (0, 2)) }
  /// Clears the value of `opt2`. Subsequent reads from it will return its default value.
  mutating func clearOpt2() { _uniqueStorage().clearValue(at: 16, type: SwiftProtoTesting_NestedRequired.self, hasBit: (0, 2)) }

  var unknownFields: SwiftProtobuf.UnknownStorage {
    get { _storage.unknownFields }
    _modify {
      _ = _uniqueStorage()
      yield &_storage.unknownFields
    }
  }

  init() {}

  private var _storage = SwiftProtobuf._MessageStorage(layout: Self._protobuf_messageLayout)

  private mutating func _uniqueStorage() -> SwiftProtobuf._MessageStorage {
    if !isKnownUniquelyReferenced(&_storage) { _storage = _storage.copy() }
    return _storage
  }
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "swift_proto_testing"

extension SwiftProtoTesting_Required1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Required1"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}req_1\0\u{3}opt_2\0\u{3}opt_3\0\u{3}opt_4\0")
  #if _pointerBitWidth(_64)
    @_alwaysEmitIntoClient @inline(__always)
    private static var _protobuf_messageLayoutString: StaticString { "\0(\0\0\u{4}\0\0\u{1}\0\0\u{5}\0\0\u{1}\0\0\0\0\u{8}\0\0\0\0\0\0\u{3}\u{2}\0\0\0\0\u{10}\0\0\u{1}\0\0\0\u{3}\u{3}\0\0\0\0\u{18}\0\0\u{2}\0\0\0\u{3}\u{4}\0\0\0\0 \0\0\u{3}\0\0\0\u{3}" }
  #elseif _pointerBitWidth(_32)
    @_alwaysEmitIntoClient @inline(__always)
    private static var _protobuf_messageLayoutString: StaticString { "\0(\0\0\u{4}\0\0\u{1}\0\0\u{5}\0\0\u{1}\0\0\0\0\u{8}\0\0\0\0\0\0\u{3}\u{2}\0\0\0\0\u{10}\0\0\u{1}\0\0\0\u{3}\u{3}\0\0\0\0\u{18}\0\0\u{2}\0\0\0\u{3}\u{4}\0\0\0\0 \0\0\u{3}\0\0\0\u{3}" }
  #else
    #error("Unsupported platform")
  #endif

  private static let _protobuf_messageLayout = SwiftProtobuf._MessageLayout(layout: _protobuf_messageLayoutString)

  public var isInitialized: Bool {
    return _storage.isInitialized
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    fatalError("table-driven decodeMessage not yet implemented")
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    fatalError("table-driven traverse not yet implemented")
  }

  static func ==(lhs: SwiftProtoTesting_Required1, rhs: SwiftProtoTesting_Required1) -> Bool {
    return lhs._storage.isEqual(to: rhs._storage)
  }
}

extension SwiftProtoTesting_Required8: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Required8"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}req_1\0\u{3}req_2\0\u{3}req_3\0\u{3}req_4\0\u{3}req_5\0\u{3}req_6\0\u{3}req_7\0\u{3}req_8\0\u{3}req_9\0\u{3}req_10\0")
  #if _pointerBitWidth(_64)
    @_alwaysEmitIntoClient @inline(__always)
    private static var _protobuf_messageLayoutString: StaticString { "\0X\0\0\u{a}\0\0\u{8}\0\0\u{b}\0\0\u{1}\0\0\0\0\u{8}\0\0\0\0\0\0\u{3}\u{2}\0\0\0\0\u{10}\0\0\u{1}\0\0\0\u{3}\u{3}\0\0\0\0\u{18}\0\0\u{2}\0\0\0\u{3}\u{4}\0\0\0\0 \0\0\u{3}\0\0\0\u{3}\u{5}\0\0\0\0(\0\0\u{4}\0\0\0\u{3}\u{6}\0\0\0\00\0\0\u{5}\0\0\0\u{3}\u{7}\0\0\0\08\0\0\u{6}\0\0\0\u{3}\u{8}\0\0\0\0@\0\0\u{7}\0\0\0\u{3}\u{9}\0\0\0\0H\0\0\u{8}\0\0\0\u{3}\u{a}\0\0\0\0P\0\0\u{9}\0\0\0\u{3}" }
  #elseif _pointerBitWidth(_32)
    @_alwaysEmitIntoClient @inline(__always)
    private static var _protobuf_messageLayoutString: StaticString { "\0X\0\0\u{a}\0\0\u{8}\0\0\u{b}\0\0\u{1}\0\0\0\0\u{8}\0\0\0\0\0\0\u{3}\u{2}\0\0\0\0\u{10}\0\0\u{1}\0\0\0\u{3}\u{3}\0\0\0\0\u{18}\0\0\u{2}\0\0\0\u{3}\u{4}\0\0\0\0 \0\0\u{3}\0\0\0\u{3}\u{5}\0\0\0\0(\0\0\u{4}\0\0\0\u{3}\u{6}\0\0\0\00\0\0\u{5}\0\0\0\u{3}\u{7}\0\0\0\08\0\0\u{6}\0\0\0\u{3}\u{8}\0\0\0\0@\0\0\u{7}\0\0\0\u{3}\u{9}\0\0\0\0H\0\0\u{8}\0\0\0\u{3}\u{a}\0\0\0\0P\0\0\u{9}\0\0\0\u{3}" }
  #else
    #error("Unsupported platform")
  #endif

  private static let _protobuf_messageLayout = SwiftProtobuf._MessageLayout(layout: _protobuf_messageLayoutString)

  public var isInitialized: Bool {
    return _storage.isInitialized
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    fatalError("table-driven decodeMessage not yet implemented")
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    fatalError("table-driven traverse not yet implemented")
  }

  static func ==(lhs: SwiftProtoTesting_Required8, rhs: SwiftProtoTesting_Required8) -> Bool {
    return lhs._storage.isEqual(to: rhs._storage)
  }
}

extension SwiftProtoTesting_Required9: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Required9"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}req_1\0\u{3}req_2\0\u{3}req_3\0\u{3}req_4\0\u{3}req_5\0\u{3}req_6\0\u{3}req_7\0\u{3}req_8\0\u{3}req_9\0\u{3}req_10\0\u{3}req_11\0")
  #if _pointerBitWidth(_64)
    @_alwaysEmitIntoClient @inline(__always)
    private static var _protobuf_messageLayoutString: StaticString { "\0`\0\0\u{b}\0\0\u{9}\0\0\u{c}\0\0\u{1}\0\0\0\0\u{8}\0\0\0\0\0\0\u{3}\u{2}\0\0\0\0\u{10}\0\0\u{1}\0\0\0\u{3}\u{3}\0\0\0\0\u{18}\0\0\u{2}\0\0\0\u{3}\u{4}\0\0\0\0 \0\0\u{3}\0\0\0\u{3}\u{5}\0\0\0\0(\0\0\u{4}\0\0\0\u{3}\u{6}\0\0\0\00\0\0\u{5}\0\0\0\u{3}\u{7}\0\0\0\08\0\0\u{6}\0\0\0\u{3}\u{8}\0\0\0\0@\0\0\u{7}\0\0\0\u{3}\u{9}\0\0\0\0H\0\0\u{8}\0\0\0\u{3}\u{a}\0\0\0\0P\0\0\u{9}\0\0\0\u{3}\u{b}\0\0\0\0X\0\0\u{a}\0\0\0\u{3}" }
  #elseif _pointerBitWidth(_32)
    @_alwaysEmitIntoClient @inline(__always)
    private static var _protobuf_messageLayoutString: StaticString { "\0`\0\0\u{b}\0\0\u{9}\0\0\u{c}\0\0\u{1}\0\0\0\0\u{8}\0\0\0\0\0\0\u{3}\u{2}\0\0\0\0\u{10}\0\0\u{1}\0\0\0\u{3}\u{3}\0\0\0\0\u{18}\0\0\u{2}\0\0\0\u{3}\u{4}\0\0\0\0 \0\0\u{3}\0\0\0\u{3}\u{5}\0\0\0\0(\0\0\u{4}\0\0\0\u{3}\u{6}\0\0\0\00\0\0\u{5}\0\0\0\u{3}\u{7}\0\0\0\08\0\0\u{6}\0\0\0\u{3}\u{8}\0\0\0\0@\0\0\u{7}\0\0\0\u{3}\u{9}\0\0\0\0H\0\0\u{8}\0\0\0\u{3}\u{a}\0\0\0\0P\0\0\u{9}\0\0\0\u{3}\u{b}\0\0\0\0X\0\0\u{a}\0\0\0\u{3}" }
  #else
    #error("Unsupported platform")
  #endif

  private static let _protobuf_messageLayout = SwiftProtobuf._MessageLayout(layout: _protobuf_messageLayoutString)

  public var isInitialized: Bool {
    return _storage.isInitialized
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    fatalError("table-driven decodeMessage not yet implemented")
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    fatalError("table-driven traverse not yet implemented")
  }

  static func ==(lhs: SwiftProtoTesting_Required9, rhs: SwiftProtoTesting_Required9) -> Bool {
    return lhs._storage.isEqual(to: rhs._storage)
  }
}

extension SwiftProtoTesting_RequiredMixedOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequiredMixedOrder"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}req_1\0\u{3}opt_2\0\u{3}req_3\0\u{3}opt_4\0\u{3}req_5\0\u{3}opt_6\0\u{3}req_7\0\u{3}opt_8\0")
  #if _pointerBitWidth(_64)
    @_alwaysEmitIntoClient @inline(__always)
    private static var _protobuf_messageLayoutString: StaticString { "\0H\0\0\u{8}\0\0\u{4}\0\0\u{9}\0\0\u{1}\0\0\0\0\u{8}\0\0\0\0\0\0\u{3}\u{2}\0\0\0\0\u{10}\0\0\u{4}\0\0\0\u{3}\u{3}\0\0\0\0\u{18}\0\0\u{1}\0\0\0\u{3}\u{4}\0\0\0\0 \0\0\u{5}\0\0\0\u{3}\u{5}\0\0\0\0(\0\0\u{2}\0\0\0\u{3}\u{6}\0\0\0\00\0\0\u{6}\0\0\0\u{3}\u{7}\0\0\0\08\0\0\u{3}\0\0\0\u{3}\u{8}\0\0\0\0@\0\0\u{7}\0\0\0\u{3}" }
  #elseif _pointerBitWidth(_32)
    @_alwaysEmitIntoClient @inline(__always)
    private static var _protobuf_messageLayoutString: StaticString { "\0H\0\0\u{8}\0\0\u{4}\0\0\u{9}\0\0\u{1}\0\0\0\0\u{8}\0\0\0\0\0\0\u{3}\u{2}\0\0\0\0\u{10}\0\0\u{4}\0\0\0\u{3}\u{3}\0\0\0\0\u{18}\0\0\u{1}\0\0\0\u{3}\u{4}\0\0\0\0 \0\0\u{5}\0\0\0\u{3}\u{5}\0\0\0\0(\0\0\u{2}\0\0\0\u{3}\u{6}\0\0\0\00\0\0\u{6}\0\0\0\u{3}\u{7}\0\0\0\08\0\0\u{3}\0\0\0\u{3}\u{8}\0\0\0\0@\0\0\u{7}\0\0\0\u{3}" }
  #else
    #error("Unsupported platform")
  #endif

  private static let _protobuf_messageLayout = SwiftProtobuf._MessageLayout(layout: _protobuf_messageLayoutString)

  public var isInitialized: Bool {
    return _storage.isInitialized
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    fatalError("table-driven decodeMessage not yet implemented")
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    fatalError("table-driven traverse not yet implemented")
  }

  static func ==(lhs: SwiftProtoTesting_RequiredMixedOrder, rhs: SwiftProtoTesting_RequiredMixedOrder) -> Bool {
    return lhs._storage.isEqual(to: rhs._storage)
  }
}

extension SwiftProtoTesting_RequiredWithNested: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequiredWithNested"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}nested\0")
  #if _pointerBitWidth(_64)
    @_alwaysEmitIntoClient @inline(__always)
    private static var _protobuf_messageLayoutString: StaticString { "\0\u{10}\0\0\u{1}\0\0\u{1}\0\0\u{2}\0\0\u{1}\0\0\0\0\u{8}\0\0\0\0\u{1}\0\u{b}" }
  #elseif _pointerBitWidth(_32)
    @_alwaysEmitIntoClient @inline(__always)
    private static var _protobuf_messageLayoutString: StaticString { "\0\u{8}\0\0\u{1}\0\0\u{1}\0\0\u{2}\0\0\u{1}\0\0\0\0\u{4}\0\0\0\0\u{1}\0\u{b}" }
  #else
    #error("Unsupported platform")
  #endif

  private static let _protobuf_messageLayout = SwiftProtobuf._MessageLayout(layout: _protobuf_messageLayoutString, deinitializeSubmessage: _protobuf_deinitializeSubmessage, copySubmessage: _protobuf_copySubmessage, areSubmessagesEqual: _protobuf_areSubmessagesEqual, isSubmessageInitialized: _protobuf_isSubmessageInitialized)

  private static func _protobuf_deinitializeSubmessage(for token: SwiftProtobuf._MessageLayout.SubmessageToken, field: SwiftProtobuf.FieldLayout, storage: SwiftProtobuf._MessageStorage) {
    switch token.index {
    case 1: storage.deinitializeField(field, type: SwiftProtoTesting_NestedRequired.self)
    default: preconditionFailure("invalid submessage token; this is a generator bug")
    }
  }

  private static func _protobuf_copySubmessage(for token: SwiftProtobuf._MessageLayout.SubmessageToken, field: SwiftProtobuf.FieldLayout, from source: SwiftProtobuf._MessageStorage, to destination: SwiftProtobuf._MessageStorage) {
    switch token.index {
    case 1: source.copyField(field, to: destination, type: SwiftProtoTesting_NestedRequired.self)
    default: preconditionFailure("invalid submessage token; this is a generator bug")
    }
  }

  private static func _protobuf_areSubmessagesEqual(for token: SwiftProtobuf._MessageLayout.SubmessageToken, field: SwiftProtobuf.FieldLayout, lhs: SwiftProtobuf._MessageStorage, rhs: SwiftProtobuf._MessageStorage) -> Bool {
    switch token.index {
    case 1: return lhs.isField(field, equalToSameFieldIn: rhs, type: SwiftProtoTesting_NestedRequired.self)
    default: preconditionFailure("invalid submessage token; this is a generator bug")
    }
  }

  private static func _protobuf_isSubmessageInitialized(for token: SwiftProtobuf._MessageLayout.SubmessageToken, field: SwiftProtobuf.FieldLayout, storage: SwiftProtobuf._MessageStorage) -> Bool {
    switch token.index {
    case 1: return storage.isFieldInitialized(field, type: SwiftProtoTesting_NestedRequired.self)
    default: preconditionFailure("invalid submessage token; this is a generator bug")
    }
  }

  public var isInitialized: Bool {
    return _storage.isInitialized
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    fatalError("table-driven decodeMessage not yet implemented")
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    fatalError("table-driven traverse not yet implemented")
  }

  static func ==(lhs: SwiftProtoTesting_RequiredWithNested, rhs: SwiftProtoTesting_RequiredWithNested) -> Bool {
    return lhs._storage.isEqual(to: rhs._storage)
  }
}

extension SwiftProtoTesting_RequiredWithRepeatedNested: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequiredWithRepeatedNested"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}nested\0")
  #if _pointerBitWidth(_64)
    @_alwaysEmitIntoClient @inline(__always)
    private static var _protobuf_messageLayoutString: StaticString { "\0\u{10}\0\0\u{1}\0\0\0\0\0\u{2}\0\0\u{1}\0\0\0\u{2}\u{8}\0\0\0\0\u{1}\0\u{b}" }
  #elseif _pointerBitWidth(_32)
    @_alwaysEmitIntoClient @inline(__always)
    private static var _protobuf_messageLayoutString: StaticString { "\0\u{8}\0\0\u{1}\0\0\0\0\0\u{2}\0\0\u{1}\0\0\0\u{2}\u{4}\0\0\0\0\u{1}\0\u{b}" }
  #else
    #error("Unsupported platform")
  #endif

  private static let _protobuf_messageLayout = SwiftProtobuf._MessageLayout(layout: _protobuf_messageLayoutString, deinitializeSubmessage: _protobuf_deinitializeSubmessage, copySubmessage: _protobuf_copySubmessage, areSubmessagesEqual: _protobuf_areSubmessagesEqual, isSubmessageInitialized: _protobuf_isSubmessageInitialized)

  private static func _protobuf_deinitializeSubmessage(for token: SwiftProtobuf._MessageLayout.SubmessageToken, field: SwiftProtobuf.FieldLayout, storage: SwiftProtobuf._MessageStorage) {
    switch token.index {
    case 1: storage.deinitializeField(field, type: [SwiftProtoTesting_NestedRequired].self)
    default: preconditionFailure("invalid submessage token; this is a generator bug")
    }
  }

  private static func _protobuf_copySubmessage(for token: SwiftProtobuf._MessageLayout.SubmessageToken, field: SwiftProtobuf.FieldLayout, from source: SwiftProtobuf._MessageStorage, to destination: SwiftProtobuf._MessageStorage) {
    switch token.index {
    case 1: source.copyField(field, to: destination, type: [SwiftProtoTesting_NestedRequired].self)
    default: preconditionFailure("invalid submessage token; this is a generator bug")
    }
  }

  private static func _protobuf_areSubmessagesEqual(for token: SwiftProtobuf._MessageLayout.SubmessageToken, field: SwiftProtobuf.FieldLayout, lhs: SwiftProtobuf._MessageStorage, rhs: SwiftProtobuf._MessageStorage) -> Bool {
    switch token.index {
    case 1: return lhs.isField(field, equalToSameFieldIn: rhs, type: [SwiftProtoTesting_NestedRequired].self)
    default: preconditionFailure("invalid submessage token; this is a generator bug")
    }
  }

  private static func _protobuf_isSubmessageInitialized(for token: SwiftProtobuf._MessageLayout.SubmessageToken, field: SwiftProtobuf.FieldLayout, storage: SwiftProtobuf._MessageStorage) -> Bool {
    switch token.index {
    case 1: return storage.isFieldInitialized(field, type: [SwiftProtoTesting_NestedRequired].self)
    default: preconditionFailure("invalid submessage token; this is a generator bug")
    }
  }

  public var isInitialized: Bool {
    return _storage.isInitialized
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    fatalError("table-driven decodeMessage not yet implemented")
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    fatalError("table-driven traverse not yet implemented")
  }

  static func ==(lhs: SwiftProtoTesting_RequiredWithRepeatedNested, rhs: SwiftProtoTesting_RequiredWithRepeatedNested) -> Bool {
    return lhs._storage.isEqual(to: rhs._storage)
  }
}

extension SwiftProtoTesting_NestedRequired: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NestedRequired"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}req_1\0")
  #if _pointerBitWidth(_64)
    @_alwaysEmitIntoClient @inline(__always)
    private static var _protobuf_messageLayoutString: StaticString { "\0\u{10}\0\0\u{1}\0\0\u{1}\0\0\u{2}\0\0\u{1}\0\0\0\0\u{8}\0\0\0\0\0\0\u{3}" }
  #elseif _pointerBitWidth(_32)
    @_alwaysEmitIntoClient @inline(__always)
    private static var _protobuf_messageLayoutString: StaticString { "\0\u{10}\0\0\u{1}\0\0\u{1}\0\0\u{2}\0\0\u{1}\0\0\0\0\u{8}\0\0\0\0\0\0\u{3}" }
  #else
    #error("Unsupported platform")
  #endif

  private static let _protobuf_messageLayout = SwiftProtobuf._MessageLayout(layout: _protobuf_messageLayoutString)

  public var isInitialized: Bool {
    return _storage.isInitialized
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    fatalError("table-driven decodeMessage not yet implemented")
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    fatalError("table-driven traverse not yet implemented")
  }

  static func ==(lhs: SwiftProtoTesting_NestedRequired, rhs: SwiftProtoTesting_NestedRequired) -> Bool {
    return lhs._storage.isEqual(to: rhs._storage)
  }
}

extension SwiftProtoTesting_NoneRequired: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NoneRequired"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}opt_1\0\u{3}opt_2\0")
  #if _pointerBitWidth(_64)
    @_alwaysEmitIntoClient @inline(__always)
    private static var _protobuf_messageLayoutString: StaticString { "\0\u{18}\0\0\u{2}\0\0\0\0\0\u{3}\0\0\u{1}\0\0\0\0\u{8}\0\0\0\0\0\0\u{3}\u{2}\0\0\0\0\u{10}\0\0\u{1}\0\u{1}\0\u{b}" }
  #elseif _pointerBitWidth(_32)
    @_alwaysEmitIntoClient @inline(__always)
    private static var _protobuf_messageLayoutString: StaticString { "\0\u{14}\0\0\u{2}\0\0\0\0\0\u{3}\0\0\u{1}\0\0\0\0\u{8}\0\0\0\0\0\0\u{3}\u{2}\0\0\0\0\u{10}\0\0\u{1}\0\u{1}\0\u{b}" }
  #else
    #error("Unsupported platform")
  #endif

  private static let _protobuf_messageLayout = SwiftProtobuf._MessageLayout(layout: _protobuf_messageLayoutString, deinitializeSubmessage: _protobuf_deinitializeSubmessage, copySubmessage: _protobuf_copySubmessage, areSubmessagesEqual: _protobuf_areSubmessagesEqual, isSubmessageInitialized: _protobuf_isSubmessageInitialized)

  private static func _protobuf_deinitializeSubmessage(for token: SwiftProtobuf._MessageLayout.SubmessageToken, field: SwiftProtobuf.FieldLayout, storage: SwiftProtobuf._MessageStorage) {
    switch token.index {
    case 1: storage.deinitializeField(field, type: SwiftProtoTesting_NestedNoneRequired.self)
    default: preconditionFailure("invalid submessage token; this is a generator bug")
    }
  }

  private static func _protobuf_copySubmessage(for token: SwiftProtobuf._MessageLayout.SubmessageToken, field: SwiftProtobuf.FieldLayout, from source: SwiftProtobuf._MessageStorage, to destination: SwiftProtobuf._MessageStorage) {
    switch token.index {
    case 1: source.copyField(field, to: destination, type: SwiftProtoTesting_NestedNoneRequired.self)
    default: preconditionFailure("invalid submessage token; this is a generator bug")
    }
  }

  private static func _protobuf_areSubmessagesEqual(for token: SwiftProtobuf._MessageLayout.SubmessageToken, field: SwiftProtobuf.FieldLayout, lhs: SwiftProtobuf._MessageStorage, rhs: SwiftProtobuf._MessageStorage) -> Bool {
    switch token.index {
    case 1: return lhs.isField(field, equalToSameFieldIn: rhs, type: SwiftProtoTesting_NestedNoneRequired.self)
    default: preconditionFailure("invalid submessage token; this is a generator bug")
    }
  }

  private static func _protobuf_isSubmessageInitialized(for token: SwiftProtobuf._MessageLayout.SubmessageToken, field: SwiftProtobuf.FieldLayout, storage: SwiftProtobuf._MessageStorage) -> Bool {
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    fatalError("table-driven decodeMessage not yet implemented")
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    fatalError("table-driven traverse not yet implemented")
  }

  static func ==(lhs: SwiftProtoTesting_NoneRequired, rhs: SwiftProtoTesting_NoneRequired) -> Bool {
    return lhs._storage.isEqual(to: rhs._storage)
  }
}

extension SwiftProtoTesting_NestedNoneRequired: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NestedNoneRequired"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}opt_1\0")
  #if _pointerBitWidth(_64)
    @_alwaysEmitIntoClient @inline(__always)
    private static var _protobuf_messageLayoutString: StaticString { "\0\u{10}\0\0\u{1}\0\0\0\0\0\u{2}\0\0\u{1}\0\0\0\0\u{8}\0\0\0\0\0\0\u{3}" }
  #elseif _pointerBitWidth(_32)
    @_alwaysEmitIntoClient @inline(__always)
    private static var _protobuf_messageLayoutString: StaticString { "\0\u{10}\0\0\u{1}\0\0\0\0\0\u{2}\0\0\u{1}\0\0\0\0\u{8}\0\0\0\0\0\0\u{3}" }
  #else
    #error("Unsupported platform")
  #endif

  private static let _protobuf_messageLayout = SwiftProtobuf._MessageLayout(layout: _protobuf_messageLayoutString)

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    fatalError("table-driven decodeMessage not yet implemented")
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    fatalError("table-driven traverse not yet implemented")
  }

  static func ==(lhs: SwiftProtoTesting_NestedNoneRequired, rhs: SwiftProtoTesting_NestedNoneRequired) -> Bool {
    return lhs._storage.isEqual(to: rhs._storage)
  }
}

extension SwiftProtoTesting_NoneRequiredButNestedRequired: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NoneRequiredButNestedRequired"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}opt_1\0\u{3}opt_2\0")
  #if _pointerBitWidth(_64)
    @_alwaysEmitIntoClient @inline(__always)
    private static var _protobuf_messageLayoutString: StaticString { "\0\u{18}\0\0\u{2}\0\0\0\0\0\u{3}\0\0\u{1}\0\0\0\0\u{8}\0\0\0\0\0\0\u{3}\u{2}\0\0\0\0\u{10}\0\0\u{1}\0\u{1}\0\u{b}" }
  #elseif _pointerBitWidth(_32)
    @_alwaysEmitIntoClient @inline(__always)
    private static var _protobuf_messageLayoutString: StaticString { "\0\u{14}\0\0\u{2}\0\0\0\0\0\u{3}\0\0\u{1}\0\0\0\0\u{8}\0\0\0\0\0\0\u{3}\u{2}\0\0\0\0\u{10}\0\0\u{1}\0\u{1}\0\u{b}" }
  #else
    #error("Unsupported platform")
  #endif

  private static let _protobuf_messageLayout = SwiftProtobuf._MessageLayout(layout: _protobuf_messageLayoutString, deinitializeSubmessage: _protobuf_deinitializeSubmessage, copySubmessage: _protobuf_copySubmessage, areSubmessagesEqual: _protobuf_areSubmessagesEqual, isSubmessageInitialized: _protobuf_isSubmessageInitialized)

  private static func _protobuf_deinitializeSubmessage(for token: SwiftProtobuf._MessageLayout.SubmessageToken, field: SwiftProtobuf.FieldLayout, storage: SwiftProtobuf._MessageStorage) {
    switch token.index {
    case 1: storage.deinitializeField(field, type: SwiftProtoTesting_NestedRequired.self)
    default: preconditionFailure("invalid submessage token; this is a generator bug")
    }
  }

  private static func _protobuf_copySubmessage(for token: SwiftProtobuf._MessageLayout.SubmessageToken, field: SwiftProtobuf.FieldLayout, from source: SwiftProtobuf._MessageStorage, to destination: SwiftProtobuf._MessageStorage) {
    switch token.index {
    case 1: source.copyField(field, to: destination, type: SwiftProtoTesting_NestedRequired.self)
    default: preconditionFailure("invalid submessage token; this is a generator bug")
    }
  }

  private static func _protobuf_areSubmessagesEqual(for token: SwiftProtobuf._MessageLayout.SubmessageToken, field: SwiftProtobuf.FieldLayout, lhs: SwiftProtobuf._MessageStorage, rhs: SwiftProtobuf._MessageStorage) -> Bool {
    switch token.index {
    case 1: return lhs.isField(field, equalToSameFieldIn: rhs, type: SwiftProtoTesting_NestedRequired.self)
    default: preconditionFailure("invalid submessage token; this is a generator bug")
    }
  }

  private static func _protobuf_isSubmessageInitialized(for token: SwiftProtobuf._MessageLayout.SubmessageToken, field: SwiftProtobuf.FieldLayout, storage: SwiftProtobuf._MessageStorage) -> Bool {
    switch token.index {
    case 1: return storage.isFieldInitialized(field, type: SwiftProtoTesting_NestedRequired.self)
    default: preconditionFailure("invalid submessage token; this is a generator bug")
    }
  }

  public var isInitialized: Bool {
    return _storage.isInitialized
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    fatalError("table-driven decodeMessage not yet implemented")
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    fatalError("table-driven traverse not yet implemented")
  }

  static func ==(lhs: SwiftProtoTesting_NoneRequiredButNestedRequired, rhs: SwiftProtoTesting_NoneRequiredButNestedRequired) -> Bool {
    return lhs._storage.isEqual(to: rhs._storage)
  }
}
