// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: unittest_swift_all_required_types.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/// An addition to unittest.proto

import Foundation
@_spi(ForGeneratedCodeOnly) import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct SwiftProtoTesting_TestAllRequiredTypes: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Singular
  var requiredInt32: Int32 {
    get { return _storage.value(at: 28, default: 0, hasBit: (0, 1)) }
    set { _uniqueStorage().updateValue(at: 28, to: newValue, willBeSet: true, hasBit: (0, 1)) }
  }
  /// Returns true if `requiredInt32` has been explicitly set.
  var hasRequiredInt32: Bool { return _storage.isPresent(hasBit: (0, 1)) }
  /// Clears the value of `requiredInt32`. Subsequent reads from it will return its default value.
  mutating func clearRequiredInt32() { _uniqueStorage().clearValue(at: 28, type: Int32.self, hasBit: (0, 1)) }

  var requiredInt64: Int64 {
    get { return _storage.value(at: 104, default: 0, hasBit: (0, 2)) }
    set { _uniqueStorage().updateValue(at: 104, to: newValue, willBeSet: true, hasBit: (0, 2)) }
  }
  /// Returns true if `requiredInt64` has been explicitly set.
  var hasRequiredInt64: Bool { return _storage.isPresent(hasBit: (0, 2)) }
  /// Clears the value of `requiredInt64`. Subsequent reads from it will return its default value.
  mutating func clearRequiredInt64() { _uniqueStorage().clearValue(at: 104, type: Int64.self, hasBit: (0, 2)) }

  var requiredUint32: UInt32 {
    get { return _storage.value(at: 32, default: 0, hasBit: (0, 4)) }
    set { _uniqueStorage().updateValue(at: 32, to: newValue, willBeSet: true, hasBit: (0, 4)) }
  }
  /// Returns true if `requiredUint32` has been explicitly set.
  var hasRequiredUint32: Bool { return _storage.isPresent(hasBit: (0, 4)) }
  /// Clears the value of `requiredUint32`. Subsequent reads from it will return its default value.
  mutating func clearRequiredUint32() { _uniqueStorage().clearValue(at: 32, type: UInt32.self, hasBit: (0, 4)) }

  var requiredUint64: UInt64 {
    get { return _storage.value(at: 112, default: 0, hasBit: (0, 8)) }
    set { _uniqueStorage().updateValue(at: 112, to: newValue, willBeSet: true, hasBit: (0, 8)) }
  }
  /// Returns true if `requiredUint64` has been explicitly set.
  var hasRequiredUint64: Bool { return _storage.isPresent(hasBit: (0, 8)) }
  /// Clears the value of `requiredUint64`. Subsequent reads from it will return its default value.
  mutating func clearRequiredUint64() { _uniqueStorage().clearValue(at: 112, type: UInt64.self, hasBit: (0, 8)) }

  var requiredSint32: Int32 {
    get { return _storage.value(at: 36, default: 0, hasBit: (0, 16)) }
    set { _uniqueStorage().updateValue(at: 36, to: newValue, willBeSet: true, hasBit: (0, 16)) }
  }
  /// Returns true if `requiredSint32` has been explicitly set.
  var hasRequiredSint32: Bool { return _storage.isPresent(hasBit: (0, 16)) }
  /// Clears the value of `requiredSint32`. Subsequent reads from it will return its default value.
  mutating func clearRequiredSint32() { _uniqueStorage().clearValue(at: 36, type: Int32.self, hasBit: (0, 16)) }

  var requiredSint64: Int64 {
    get { return _storage.value(at: 120, default: 0, hasBit: (0, 32)) }
    set { _uniqueStorage().updateValue(at: 120, to: newValue, willBeSet: true, hasBit: (0, 32)) }
  }
  /// Returns true if `requiredSint64` has been explicitly set.
  var hasRequiredSint64: Bool { return _storage.isPresent(hasBit: (0, 32)) }
  /// Clears the value of `requiredSint64`. Subsequent reads from it will return its default value.
  mutating func clearRequiredSint64() { _uniqueStorage().clearValue(at: 120, type: Int64.self, hasBit: (0, 32)) }

  var requiredFixed32: UInt32 {
    get { return _storage.value(at: 40, default: 0, hasBit: (0, 64)) }
    set { _uniqueStorage().updateValue(at: 40, to: newValue, willBeSet: true, hasBit: (0, 64)) }
  }
  /// Returns true if `requiredFixed32` has been explicitly set.
  var hasRequiredFixed32: Bool { return _storage.isPresent(hasBit: (0, 64)) }
  /// Clears the value of `requiredFixed32`. Subsequent reads from it will return its default value.
  mutating func clearRequiredFixed32() { _uniqueStorage().clearValue(at: 40, type: UInt32.self, hasBit: (0, 64)) }

  var requiredFixed64: UInt64 {
    get { return _storage.value(at: 128, default: 0, hasBit: (0, 128)) }
    set { _uniqueStorage().updateValue(at: 128, to: newValue, willBeSet: true, hasBit: (0, 128)) }
  }
  /// Returns true if `requiredFixed64` has been explicitly set.
  var hasRequiredFixed64: Bool { return _storage.isPresent(hasBit: (0, 128)) }
  /// Clears the value of `requiredFixed64`. Subsequent reads from it will return its default value.
  mutating func clearRequiredFixed64() { _uniqueStorage().clearValue(at: 128, type: UInt64.self, hasBit: (0, 128)) }

  var requiredSfixed32: Int32 {
    get { return _storage.value(at: 44, default: 0, hasBit: (1, 1)) }
    set { _uniqueStorage().updateValue(at: 44, to: newValue, willBeSet: true, hasBit: (1, 1)) }
  }
  /// Returns true if `requiredSfixed32` has been explicitly set.
  var hasRequiredSfixed32: Bool { return _storage.isPresent(hasBit: (1, 1)) }
  /// Clears the value of `requiredSfixed32`. Subsequent reads from it will return its default value.
  mutating func clearRequiredSfixed32() { _uniqueStorage().clearValue(at: 44, type: Int32.self, hasBit: (1, 1)) }

  var requiredSfixed64: Int64 {
    get { return _storage.value(at: 136, default: 0, hasBit: (1, 2)) }
    set { _uniqueStorage().updateValue(at: 136, to: newValue, willBeSet: true, hasBit: (1, 2)) }
  }
  /// Returns true if `requiredSfixed64` has been explicitly set.
  var hasRequiredSfixed64: Bool { return _storage.isPresent(hasBit: (1, 2)) }
  /// Clears the value of `requiredSfixed64`. Subsequent reads from it will return its default value.
  mutating func clearRequiredSfixed64() { _uniqueStorage().clearValue(at: 136, type: Int64.self, hasBit: (1, 2)) }

  var requiredFloat: Float {
    get { return _storage.value(at: 48, default: 0, hasBit: (1, 4)) }
    set { _uniqueStorage().updateValue(at: 48, to: newValue, willBeSet: true, hasBit: (1, 4)) }
  }
  /// Returns true if `requiredFloat` has been explicitly set.
  var hasRequiredFloat: Bool { return _storage.isPresent(hasBit: (1, 4)) }
  /// Clears the value of `requiredFloat`. Subsequent reads from it will return its default value.
  mutating func clearRequiredFloat() { _uniqueStorage().clearValue(at: 48, type: Float.self, hasBit: (1, 4)) }

  var requiredDouble: Double {
    get { return _storage.value(at: 144, default: 0, hasBit: (1, 8)) }
    set { _uniqueStorage().updateValue(at: 144, to: newValue, willBeSet: true, hasBit: (1, 8)) }
  }
  /// Returns true if `requiredDouble` has been explicitly set.
  var hasRequiredDouble: Bool { return _storage.isPresent(hasBit: (1, 8)) }
  /// Clears the value of `requiredDouble`. Subsequent reads from it will return its default value.
  mutating func clearRequiredDouble() { _uniqueStorage().clearValue(at: 144, type: Double.self, hasBit: (1, 8)) }

  var requiredBool: Bool {
    get { return _storage.value(at: 24, default: false, hasBit: (1, 16)) }
    set { _uniqueStorage().updateValue(at: 24, to: newValue, willBeSet: true, hasBit: (1, 16)) }
  }
  /// Returns true if `requiredBool` has been explicitly set.
  var hasRequiredBool: Bool { return _storage.isPresent(hasBit: (1, 16)) }
  /// Clears the value of `requiredBool`. Subsequent reads from it will return its default value.
  mutating func clearRequiredBool() { _uniqueStorage().clearValue(at: 24, type: Bool.self, hasBit: (1, 16)) }

  var requiredString: String {
    get { return _storage.value(at: SwiftProtobuf._fieldOffset(256, 228), default: String(), hasBit: (1, 32)) }
    set { _uniqueStorage().updateValue(at: SwiftProtobuf._fieldOffset(256, 228), to: newValue, willBeSet: true, hasBit: (1, 32)) }
  }
  /// Returns true if `requiredString` has been explicitly set.
  var hasRequiredString: Bool { return _storage.isPresent(hasBit: (1, 32)) }
  /// Clears the value of `requiredString`. Subsequent reads from it will return its default value.
  mutating func clearRequiredString() { _uniqueStorage().clearValue(at: SwiftProtobuf._fieldOffset(256, 228), type: String.self, hasBit: (1, 32)) }

  var requiredBytes: Data {
    get { return _storage.value(at: SwiftProtobuf._fieldOffset(272, 240), default: Data(), hasBit: (1, 64)) }
    set { _uniqueStorage().updateValue(at: SwiftProtobuf._fieldOffset(272, 240), to: newValue, willBeSet: true, hasBit: (1, 64)) }
  }
  /// Returns true if `requiredBytes` has been explicitly set.
  var hasRequiredBytes: Bool { return _storage.isPresent(hasBit: (1, 64)) }
  /// Clears the value of `requiredBytes`. Subsequent reads from it will return its default value.
  mutating func clearRequiredBytes() { _uniqueStorage().clearValue(at: SwiftProtobuf._fieldOffset(272, 240), type: Data.self, hasBit: (1, 64)) }

  var requiredGroup: SwiftProtoTesting_TestAllRequiredTypes.RequiredGroup {
    get { return _storage.value(at: 200, default: SwiftProtoTesting_TestAllRequiredTypes.RequiredGroup(), hasBit: (1, 128)) }
    set { _uniqueStorage().updateValue(at: 200, to: newValue, willBeSet: true, hasBit: (1, 128)) }
  }
  /// Returns true if `requiredGroup` has been explicitly set.
  var hasRequiredGroup: Bool { return _storage.isPresent(hasBit: (1, 128)) }
  /// Clears the value of `requiredGroup`. Subsequent reads from it will return its default value.
  mutating func clearRequiredGroup() { _uniqueStorage().clearValue(at: 200, type: SwiftProtoTesting_TestAllRequiredTypes.RequiredGroup.self, hasBit: (1, 128)) }

  var requiredNestedMessage: SwiftProtoTesting_TestAllRequiredTypes.NestedMessage {
    get { return _storage.value(at: SwiftProtobuf._fieldOffset(208, 204), default: SwiftProtoTesting_TestAllRequiredTypes.NestedMessage(), hasBit: (2, 1)) }
    set { _uniqueStorage().updateValue(at: SwiftProtobuf._fieldOffset(208, 204), to: newValue, willBeSet: true, hasBit: (2, 1)) }
  }
  /// Returns true if `requiredNestedMessage` has been explicitly set.
  var hasRequiredNestedMessage: Bool { return _storage.isPresent(hasBit: (2, 1)) }
  /// Clears the value of `requiredNestedMessage`. Subsequent reads from it will return its default value.
  mutating func clearRequiredNestedMessage() { _uniqueStorage().clearValue(at: SwiftProtobuf._fieldOffset(208, 204), type: SwiftProtoTesting_TestAllRequiredTypes.NestedMessage.self, hasBit: (2, 1)) }

  var requiredForeignMessage: SwiftProtoTesting_ForeignMessage {
    get { return _storage.value(at: SwiftProtobuf._fieldOffset(216, 208), default: SwiftProtoTesting_ForeignMessage(), hasBit: (2, 2)) }
    set { _uniqueStorage().updateValue(at: SwiftProtobuf._fieldOffset(216, 208), to: newValue, willBeSet: true, hasBit: (2, 2)) }
  }
  /// Returns true if `requiredForeignMessage` has been explicitly set.
  var hasRequiredForeignMessage: Bool { return _storage.isPresent(hasBit: (2, 2)) }
  /// Clears the value of `requiredForeignMessage`. Subsequent reads from it will return its default value.
  mutating func clearRequiredForeignMessage() { _uniqueStorage().clearValue(at: SwiftProtobuf._fieldOffset(216, 208), type: SwiftProtoTesting_ForeignMessage.self, hasBit: (2, 2)) }

  var requiredImportMessage: SwiftProtoTesting_Import_ImportMessage {
    get { return _storage.value(at: SwiftProtobuf._fieldOffset(224, 212), default: SwiftProtoTesting_Import_ImportMessage(), hasBit: (2, 4)) }
    set { _uniqueStorage().updateValue(at: SwiftProtobuf._fieldOffset(224, 212), to: newValue, willBeSet: true, hasBit: (2, 4)) }
  }
  /// Returns true if `requiredImportMessage` has been explicitly set.
  var hasRequiredImportMessage: Bool { return _storage.isPresent(hasBit: (2, 4)) }
  /// Clears the value of `requiredImportMessage`. Subsequent reads from it will return its default value.
  mutating func clearRequiredImportMessage() { _uniqueStorage().clearValue(at: SwiftProtobuf._fieldOffset(224, 212), type: SwiftProtoTesting_Import_ImportMessage.self, hasBit: (2, 4)) }

  var requiredNestedEnum: SwiftProtoTesting_TestAllRequiredTypes.NestedEnum {
    get { return _storage.value(at: 52, default: .foo, hasBit: (2, 8)) }
    set { _uniqueStorage().updateValue(at: 52, to: newValue, willBeSet: true, hasBit: (2, 8)) }
  }
  /// Returns true if `requiredNestedEnum` has been explicitly set.
  var hasRequiredNestedEnum: Bool { return _storage.isPresent(hasBit: (2, 8)) }
  /// Clears the value of `requiredNestedEnum`. Subsequent reads from it will return its default value.
  mutating func clearRequiredNestedEnum() { _uniqueStorage().clearValue(at: 52, type: SwiftProtoTesting_TestAllRequiredTypes.NestedEnum.self, hasBit: (2, 8)) }

  var requiredForeignEnum: SwiftProtoTesting_ForeignEnum {
    get { return _storage.value(at: 56, default: .foreignFoo, hasBit: (2, 16)) }
    set { _uniqueStorage().updateValue(at: 56, to: newValue, willBeSet: true, hasBit: (2, 16)) }
  }
  /// Returns true if `requiredForeignEnum` has been explicitly set.
  var hasRequiredForeignEnum: Bool { return _storage.isPresent(hasBit: (2, 16)) }
  /// Clears the value of `requiredForeignEnum`. Subsequent reads from it will return its default value.
  mutating func clearRequiredForeignEnum() { _uniqueStorage().clearValue(at: 56, type: SwiftProtoTesting_ForeignEnum.self, hasBit: (2, 16)) }

  var requiredImportEnum: SwiftProtoTesting_Import_ImportEnum {
    get { return _storage.value(at: 60, default: .importFoo, hasBit: (2, 32)) }
    set { _uniqueStorage().updateValue(at: 60, to: newValue, willBeSet: true, hasBit: (2, 32)) }
  }
  /// Returns true if `requiredImportEnum` has been explicitly set.
  var hasRequiredImportEnum: Bool { return _storage.isPresent(hasBit: (2, 32)) }
  /// Clears the value of `requiredImportEnum`. Subsequent reads from it will return its default value.
  mutating func clearRequiredImportEnum() { _uniqueStorage().clearValue(at: 60, type: SwiftProtoTesting_Import_ImportEnum.self, hasBit: (2, 32)) }

  /// Defined in unittest_import_public.proto
  var requiredPublicImportMessage: SwiftProtoTesting_Import_PublicImportMessage {
    get { return _storage.value(at: SwiftProtobuf._fieldOffset(232, 216), default: SwiftProtoTesting_Import_PublicImportMessage(), hasBit: (2, 64)) }
    set { _uniqueStorage().updateValue(at: SwiftProtobuf._fieldOffset(232, 216), to: newValue, willBeSet: true, hasBit: (2, 64)) }
  }
  /// Returns true if `requiredPublicImportMessage` has been explicitly set.
  var hasRequiredPublicImportMessage: Bool { return _storage.isPresent(hasBit: (2, 64)) }
  /// Clears the value of `requiredPublicImportMessage`. Subsequent reads from it will return its default value.
  mutating func clearRequiredPublicImportMessage() { _uniqueStorage().clearValue(at: SwiftProtobuf._fieldOffset(232, 216), type: SwiftProtoTesting_Import_PublicImportMessage.self, hasBit: (2, 64)) }

  /// Singular with defaults
  var defaultInt32: Int32 {
    get { return _storage.value(at: 64, default: 41, hasBit: (2, 128)) }
    set { _uniqueStorage().updateValue(at: 64, to: newValue, willBeSet: true, hasBit: (2, 128)) }
  }
  /// Returns true if `defaultInt32` has been explicitly set.
  var hasDefaultInt32: Bool { return _storage.isPresent(hasBit: (2, 128)) }
  /// Clears the value of `defaultInt32`. Subsequent reads from it will return its default value.
  mutating func clearDefaultInt32() { _uniqueStorage().clearValue(at: 64, type: Int32.self, hasBit: (2, 128)) }

  var defaultInt64: Int64 {
    get { return _storage.value(at: 152, default: 42, hasBit: (3, 1)) }
    set { _uniqueStorage().updateValue(at: 152, to: newValue, willBeSet: true, hasBit: (3, 1)) }
  }
  /// Returns true if `defaultInt64` has been explicitly set.
  var hasDefaultInt64: Bool { return _storage.isPresent(hasBit: (3, 1)) }
  /// Clears the value of `defaultInt64`. Subsequent reads from it will return its default value.
  mutating func clearDefaultInt64() { _uniqueStorage().clearValue(at: 152, type: Int64.self, hasBit: (3, 1)) }

  var defaultUint32: UInt32 {
    get { return _storage.value(at: 68, default: 43, hasBit: (3, 2)) }
    set { _uniqueStorage().updateValue(at: 68, to: newValue, willBeSet: true, hasBit: (3, 2)) }
  }
  /// Returns true if `defaultUint32` has been explicitly set.
  var hasDefaultUint32: Bool { return _storage.isPresent(hasBit: (3, 2)) }
  /// Clears the value of `defaultUint32`. Subsequent reads from it will return its default value.
  mutating func clearDefaultUint32() { _uniqueStorage().clearValue(at: 68, type: UInt32.self, hasBit: (3, 2)) }

  var defaultUint64: UInt64 {
    get { return _storage.value(at: 160, default: 44, hasBit: (3, 4)) }
    set { _uniqueStorage().updateValue(at: 160, to: newValue, willBeSet: true, hasBit: (3, 4)) }
  }
  /// Returns true if `defaultUint64` has been explicitly set.
  var hasDefaultUint64: Bool { return _storage.isPresent(hasBit: (3, 4)) }
  /// Clears the value of `defaultUint64`. Subsequent reads from it will return its default value.
  mutating func clearDefaultUint64() { _uniqueStorage().clearValue(at: 160, type: UInt64.self, hasBit: (3, 4)) }

  var defaultSint32: Int32 {
    get { return _storage.value(at: 72, default: -45, hasBit: (3, 8)) }
    set { _uniqueStorage().updateValue(at: 72, to: newValue, willBeSet: true, hasBit: (3, 8)) }
  }
  /// Returns true if `defaultSint32` has been explicitly set.
  var hasDefaultSint32: Bool { return _storage.isPresent(hasBit: (3, 8)) }
  /// Clears the value of `defaultSint32`. Subsequent reads from it will return its default value.
  mutating func clearDefaultSint32() { _uniqueStorage().clearValue(at: 72, type: Int32.self, hasBit: (3, 8)) }

  var defaultSint64: Int64 {
    get { return _storage.value(at: 168, default: 46, hasBit: (3, 16)) }
    set { _uniqueStorage().updateValue(at: 168, to: newValue, willBeSet: true, hasBit: (3, 16)) }
  }
  /// Returns true if `defaultSint64` has been explicitly set.
  var hasDefaultSint64: Bool { return _storage.isPresent(hasBit: (3, 16)) }
  /// Clears the value of `defaultSint64`. Subsequent reads from it will return its default value.
  mutating func clearDefaultSint64() { _uniqueStorage().clearValue(at: 168, type: Int64.self, hasBit: (3, 16)) }

  var defaultFixed32: UInt32 {
    get { return _storage.value(at: 76, default: 47, hasBit: (3, 32)) }
    set { _uniqueStorage().updateValue(at: 76, to: newValue, willBeSet: true, hasBit: (3, 32)) }
  }
  /// Returns true if `defaultFixed32` has been explicitly set.
  var hasDefaultFixed32: Bool { return _storage.isPresent(hasBit: (3, 32)) }
  /// Clears the value of `defaultFixed32`. Subsequent reads from it will return its default value.
  mutating func clearDefaultFixed32() { _uniqueStorage().clearValue(at: 76, type: UInt32.self, hasBit: (3, 32)) }

  var defaultFixed64: UInt64 {
    get { return _storage.value(at: 176, default: 48, hasBit: (3, 64)) }
    set { _uniqueStorage().updateValue(at: 176, to: newValue, willBeSet: true, hasBit: (3, 64)) }
  }
  /// Returns true if `defaultFixed64` has been explicitly set.
  var hasDefaultFixed64: Bool { return _storage.isPresent(hasBit: (3, 64)) }
  /// Clears the value of `defaultFixed64`. Subsequent reads from it will return its default value.
  mutating func clearDefaultFixed64() { _uniqueStorage().clearValue(at: 176, type: UInt64.self, hasBit: (3, 64)) }

  var defaultSfixed32: Int32 {
    get { return _storage.value(at: 80, default: 49, hasBit: (3, 128)) }
    set { _uniqueStorage().updateValue(at: 80, to: newValue, willBeSet: true, hasBit: (3, 128)) }
  }
  /// Returns true if `defaultSfixed32` has been explicitly set.
  var hasDefaultSfixed32: Bool { return _storage.isPresent(hasBit: (3, 128)) }
  /// Clears the value of `defaultSfixed32`. Subsequent reads from it will return its default value.
  mutating func clearDefaultSfixed32() { _uniqueStorage().clearValue(at: 80, type: Int32.self, hasBit: (3, 128)) }

  var defaultSfixed64: Int64 {
    get { return _storage.value(at: 184, default: -50, hasBit: (4, 1)) }
    set { _uniqueStorage().updateValue(at: 184, to: newValue, willBeSet: true, hasBit: (4, 1)) }
  }
  /// Returns true if `defaultSfixed64` has been explicitly set.
  var hasDefaultSfixed64: Bool { return _storage.isPresent(hasBit: (4, 1)) }
  /// Clears the value of `defaultSfixed64`. Subsequent reads from it will return its default value.
  mutating func clearDefaultSfixed64() { _uniqueStorage().clearValue(at: 184, type: Int64.self, hasBit: (4, 1)) }

  var defaultFloat: Float {
    get { return _storage.value(at: 84, default: 51.5, hasBit: (4, 2)) }
    set { _uniqueStorage().updateValue(at: 84, to: newValue, willBeSet: true, hasBit: (4, 2)) }
  }
  /// Returns true if `defaultFloat` has been explicitly set.
  var hasDefaultFloat: Bool { return _storage.isPresent(hasBit: (4, 2)) }
  /// Clears the value of `defaultFloat`. Subsequent reads from it will return its default value.
  mutating func clearDefaultFloat() { _uniqueStorage().clearValue(at: 84, type: Float.self, hasBit: (4, 2)) }

  var defaultDouble: Double {
    get { return _storage.value(at: 192, default: 52000, hasBit: (4, 4)) }
    set { _uniqueStorage().updateValue(at: 192, to: newValue, willBeSet: true, hasBit: (4, 4)) }
  }
  /// Returns true if `defaultDouble` has been explicitly set.
  var hasDefaultDouble: Bool { return _storage.isPresent(hasBit: (4, 4)) }
  /// Clears the value of `defaultDouble`. Subsequent reads from it will return its default value.
  mutating func clearDefaultDouble() { _uniqueStorage().clearValue(at: 192, type: Double.self, hasBit: (4, 4)) }

  var defaultBool: Bool {
    get { return _storage.value(at: 25, default: true, hasBit: (4, 8)) }
    set { _uniqueStorage().updateValue(at: 25, to: newValue, willBeSet: true, hasBit: (4, 8)) }
  }
  /// Returns true if `defaultBool` has been explicitly set.
  var hasDefaultBool: Bool { return _storage.isPresent(hasBit: (4, 8)) }
  /// Clears the value of `defaultBool`. Subsequent reads from it will return its default value.
  mutating func clearDefaultBool() { _uniqueStorage().clearValue(at: 25, type: Bool.self, hasBit: (4, 8)) }

  var defaultString: String {
    get { return _storage.value(at: SwiftProtobuf._fieldOffset(288, 252), default: "hello", hasBit: (4, 16)) }
    set { _uniqueStorage().updateValue(at: SwiftProtobuf._fieldOffset(288, 252), to: newValue, willBeSet: true, hasBit: (4, 16)) }
  }
  /// Returns true if `defaultString` has been explicitly set.
  var hasDefaultString: Bool { return _storage.isPresent(hasBit: (4, 16)) }
  /// Clears the value of `defaultString`. Subsequent reads from it will return its default value.
  mutating func clearDefaultString() { _uniqueStorage().clearValue(at: SwiftProtobuf._fieldOffset(288, 252), type: String.self, hasBit: (4, 16)) }

  var defaultBytes: Data {
    get { return _storage.value(at: SwiftProtobuf._fieldOffset(304, 264), default: Data([119, 111, 114, 108, 100]), hasBit: (4, 32)) }
    set { _uniqueStorage().updateValue(at: SwiftProtobuf._fieldOffset(304, 264), to: newValue, willBeSet: true, hasBit: (4, 32)) }
  }
  /// Returns true if `defaultBytes` has been explicitly set.
  var hasDefaultBytes: Bool { return _storage.isPresent(hasBit: (4, 32)) }
  /// Clears the value of `defaultBytes`. Subsequent reads from it will return its default value.
  mutating func clearDefaultBytes() { _uniqueStorage().clearValue(at: SwiftProtobuf._fieldOffset(304, 264), type: Data.self, hasBit: (4, 32)) }

  var defaultNestedEnum: SwiftProtoTesting_TestAllRequiredTypes.NestedEnum {
    get { return _storage.value(at: 88, default: .bar, hasBit: (4, 64)) }
    set { _uniqueStorage().updateValue(at: 88, to: newValue, willBeSet: true, hasBit: (4, 64)) }
  }
  /// Returns true if `defaultNestedEnum` has been explicitly set.
  var hasDefaultNestedEnum: Bool { return _storage.isPresent(hasBit: (4, 64)) }
  /// Clears the value of `defaultNestedEnum`. Subsequent reads from it will return its default value.
  mutating func clearDefaultNestedEnum() { _uniqueStorage().clearValue(at: 88, type: SwiftProtoTesting_TestAllRequiredTypes.NestedEnum.self, hasBit: (4, 64)) }

  var defaultForeignEnum: SwiftProtoTesting_ForeignEnum {
    get { return _storage.value(at: 92, default: .foreignBar, hasBit: (4, 128)) }
    set { _uniqueStorage().updateValue(at: 92, to: newValue, willBeSet: true, hasBit: (4, 128)) }
  }
  /// Returns true if `defaultForeignEnum` has been explicitly set.
  var hasDefaultForeignEnum: Bool { return _storage.isPresent(hasBit: (4, 128)) }
  /// Clears the value of `defaultForeignEnum`. Subsequent reads from it will return its default value.
  mutating func clearDefaultForeignEnum() { _uniqueStorage().clearValue(at: 92, type: SwiftProtoTesting_ForeignEnum.self, hasBit: (4, 128)) }

  var defaultImportEnum: SwiftProtoTesting_Import_ImportEnum {
    get { return _storage.value(at: 96, default: .importBar, hasBit: (5, 1)) }
    set { _uniqueStorage().updateValue(at: 96, to: newValue, willBeSet: true, hasBit: (5, 1)) }
  }
  /// Returns true if `defaultImportEnum` has been explicitly set.
  var hasDefaultImportEnum: Bool { return _storage.isPresent(hasBit: (5, 1)) }
  /// Clears the value of `defaultImportEnum`. Subsequent reads from it will return its default value.
  mutating func clearDefaultImportEnum() { _uniqueStorage().clearValue(at: 96, type: SwiftProtoTesting_Import_ImportEnum.self, hasBit: (5, 1)) }

  /// For oneof test
  var oneofField: SwiftProtoTesting_TestAllRequiredTypes.OneOf_OneofField? {
    get {
      let populatedField = _storage.populatedOneofMember(at: 8)
      switch populatedField {
      case 0: return nil
      case 111: return .oneofUint32(oneofUint32)
      case 112: return .oneofNestedMessage(oneofNestedMessage)
      case 113: return .oneofString(oneofString)
      case 114: return .oneofBytes(oneofBytes)
      default: preconditionFailure("Internal logic error; populated oneof field \(populatedField) is not a member of this oneof")
      }
    }
    set {
      switch newValue {
      case nil: _storage.clearPopulatedOneofMember(at: 8)
      case .oneofUint32(let value)?: self.oneofUint32 = value
      case .oneofNestedMessage(let value)?: self.oneofNestedMessage = value
      case .oneofString(let value)?: self.oneofString = value
      case .oneofBytes(let value)?: self.oneofBytes = value
      }
    }
  }

  var oneofUint32: UInt32 {
    get { return _storage.value(at: 100, oneofPresence: (8, 111)) }
    set { _uniqueStorage().updateValue(at: 100, to: newValue, oneofPresence: (8, 111)) }
  }

  var oneofNestedMessage: SwiftProtoTesting_TestAllRequiredTypes.NestedMessage {
    get { return _storage.value(at: SwiftProtobuf._fieldOffset(240, 220), default: SwiftProtoTesting_TestAllRequiredTypes.NestedMessage(), oneofPresence: (8, 112)) }
    set { _uniqueStorage().updateValue(at: SwiftProtobuf._fieldOffset(240, 220), to: newValue, oneofPresence: (8, 112)) }
  }

  var oneofString: String {
    get { return _storage.value(at: SwiftProtobuf._fieldOffset(320, 276), oneofPresence: (8, 113)) }
    set { _uniqueStorage().updateValue(at: SwiftProtobuf._fieldOffset(320, 276), to: newValue, oneofPresence: (8, 113)) }
  }

  var oneofBytes: Data {
    get { return _storage.value(at: SwiftProtobuf._fieldOffset(336, 288), oneofPresence: (8, 114)) }
    set { _uniqueStorage().updateValue(at: SwiftProtobuf._fieldOffset(336, 288), to: newValue, oneofPresence: (8, 114)) }
  }

  var unknownFields: SwiftProtobuf.UnknownStorage {
    get { _storage.unknownFields }
    _modify {
      _ = _uniqueStorage()
      yield &_storage.unknownFields
    }
  }

  /// For oneof test
  enum OneOf_OneofField: Equatable, Sendable {
    case oneofUint32(UInt32)
    case oneofNestedMessage(SwiftProtoTesting_TestAllRequiredTypes.NestedMessage)
    case oneofString(String)
    case oneofBytes(Data)
  }

  enum NestedEnum: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case foo = 1
    case bar = 2
    case baz = 3

    /// Intentionally negative.
    case neg = -1

    init() {
      self = .foo
    }

  }

  struct NestedMessage: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The field name "b" fails to compile in proto1 because it conflicts with
    /// a local variable named "b" in one of the generated methods.  Doh.
    /// This file needs to compile in proto1 to test backwards-compatibility.
    var bb: Int32 {
      get { return _storage.value(at: 4, default: 0, hasBit: (0, 1)) }
      set { _uniqueStorage().updateValue(at: 4, to: newValue, willBeSet: true, hasBit: (0, 1)) }
    }
    /// Returns true if `bb` has been explicitly set.
    var hasBb: Bool { return _storage.isPresent(hasBit: (0, 1)) }
    /// Clears the value of `bb`. Subsequent reads from it will return its default value.
    mutating func clearBb() { _uniqueStorage().clearValue(at: 4, type: Int32.self, hasBit: (0, 1)) }

    var unknownFields: SwiftProtobuf.UnknownStorage {
      get { _storage.unknownFields }
      _modify {
        _ = _uniqueStorage()
        yield &_storage.unknownFields
      }
    }

    init() {}

    private var _storage = SwiftProtobuf._MessageStorage(layout: Self._protobuf_messageLayout)

    private mutating func _uniqueStorage() -> SwiftProtobuf._MessageStorage {
      if !isKnownUniquelyReferenced(&_storage) { _storage = _storage.copy() }
      return _storage
    }
  }

  struct RequiredGroup: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var a: Int32 {
      get { return _storage.value(at: 4, default: 0, hasBit: (0, 1)) }
      set { _uniqueStorage().updateValue(at: 4, to: newValue, willBeSet: true, hasBit: (0, 1)) }
    }
    /// Returns true if `a` has been explicitly set.
    var hasA: Bool { return _storage.isPresent(hasBit: (0, 1)) }
    /// Clears the value of `a`. Subsequent reads from it will return its default value.
    mutating func clearA() { _uniqueStorage().clearValue(at: 4, type: Int32.self, hasBit: (0, 1)) }

    var unknownFields: SwiftProtobuf.UnknownStorage {
      get { _storage.unknownFields }
      _modify {
        _ = _uniqueStorage()
        yield &_storage.unknownFields
      }
    }

    init() {}

    private var _storage = SwiftProtobuf._MessageStorage(layout: Self._protobuf_messageLayout)

    private mutating func _uniqueStorage() -> SwiftProtobuf._MessageStorage {
      if !isKnownUniquelyReferenced(&_storage) { _storage = _storage.copy() }
      return _storage
    }
  }

  init() {}

  private var _storage = SwiftProtobuf._MessageStorage(layout: Self._protobuf_messageLayout)

  private mutating func _uniqueStorage() -> SwiftProtobuf._MessageStorage {
    if !isKnownUniquelyReferenced(&_storage) { _storage = _storage.copy() }
    return _storage
  }
}

struct SwiftProtoTesting_TestSomeRequiredTypes: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Singular
  var requiredInt32: Int32 {
    get { return _storage.value(at: 4, default: 0, hasBit: (0, 1)) }
    set { _uniqueStorage().updateValue(at: 4, to: newValue, willBeSet: true, hasBit: (0, 1)) }
  }
  /// Returns true if `requiredInt32` has been explicitly set.
  var hasRequiredInt32: Bool { return _storage.isPresent(hasBit: (0, 1)) }
  /// Clears the value of `requiredInt32`. Subsequent reads from it will return its default value.
  mutating func clearRequiredInt32() { _uniqueStorage().clearValue(at: 4, type: Int32.self, hasBit: (0, 1)) }

  var requiredFloat: Float {
    get { return _storage.value(at: 8, default: 0, hasBit: (0, 2)) }
    set { _uniqueStorage().updateValue(at: 8, to: newValue, willBeSet: true, hasBit: (0, 2)) }
  }
  /// Returns true if `requiredFloat` has been explicitly set.
  var hasRequiredFloat: Bool { return _storage.isPresent(hasBit: (0, 2)) }
  /// Clears the value of `requiredFloat`. Subsequent reads from it will return its default value.
  mutating func clearRequiredFloat() { _uniqueStorage().clearValue(at: 8, type: Float.self, hasBit: (0, 2)) }

  var requiredBool: Bool {
    get { return _storage.value(at: 1, default: false, hasBit: (0, 4)) }
    set { _uniqueStorage().updateValue(at: 1, to: newValue, willBeSet: true, hasBit: (0, 4)) }
  }
  /// Returns true if `requiredBool` has been explicitly set.
  var hasRequiredBool: Bool { return _storage.isPresent(hasBit: (0, 4)) }
  /// Clears the value of `requiredBool`. Subsequent reads from it will return its default value.
  mutating func clearRequiredBool() { _uniqueStorage().clearValue(at: 1, type: Bool.self, hasBit: (0, 4)) }

  var requiredString: String {
    get { return _storage.value(at: SwiftProtobuf._fieldOffset(16, 24), default: String(), hasBit: (0, 8)) }
    set { _uniqueStorage().updateValue(at: SwiftProtobuf._fieldOffset(16, 24), to: newValue, willBeSet: true, hasBit: (0, 8)) }
  }
  /// Returns true if `requiredString` has been explicitly set.
  var hasRequiredString: Bool { return _storage.isPresent(hasBit: (0, 8)) }
  /// Clears the value of `requiredString`. Subsequent reads from it will return its default value.
  mutating func clearRequiredString() { _uniqueStorage().clearValue(at: SwiftProtobuf._fieldOffset(16, 24), type: String.self, hasBit: (0, 8)) }

  var requiredBytes: Data {
    get { return _storage.value(at: SwiftProtobuf._fieldOffset(32, 36), default: Data(), hasBit: (0, 16)) }
    set { _uniqueStorage().updateValue(at: SwiftProtobuf._fieldOffset(32, 36), to: newValue, willBeSet: true, hasBit: (0, 16)) }
  }
  /// Returns true if `requiredBytes` has been explicitly set.
  var hasRequiredBytes: Bool { return _storage.isPresent(hasBit: (0, 16)) }
  /// Clears the value of `requiredBytes`. Subsequent reads from it will return its default value.
  mutating func clearRequiredBytes() { _uniqueStorage().clearValue(at: SwiftProtobuf._fieldOffset(32, 36), type: Data.self, hasBit: (0, 16)) }

  var requiredNestedEnum: SwiftProtoTesting_TestSomeRequiredTypes.NestedEnum {
    get { return _storage.value(at: 12, default: .foo, hasBit: (0, 32)) }
    set { _uniqueStorage().updateValue(at: 12, to: newValue, willBeSet: true, hasBit: (0, 32)) }
  }
  /// Returns true if `requiredNestedEnum` has been explicitly set.
  var hasRequiredNestedEnum: Bool { return _storage.isPresent(hasBit: (0, 32)) }
  /// Clears the value of `requiredNestedEnum`. Subsequent reads from it will return its default value.
  mutating func clearRequiredNestedEnum() { _uniqueStorage().clearValue(at: 12, type: SwiftProtoTesting_TestSomeRequiredTypes.NestedEnum.self, hasBit: (0, 32)) }

  var unknownFields: SwiftProtobuf.UnknownStorage {
    get { _storage.unknownFields }
    _modify {
      _ = _uniqueStorage()
      yield &_storage.unknownFields
    }
  }

  enum NestedEnum: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case foo = 1

    init() {
      self = .foo
    }

  }

  init() {}

  private var _storage = SwiftProtobuf._MessageStorage(layout: Self._protobuf_messageLayout)

  private mutating func _uniqueStorage() -> SwiftProtobuf._MessageStorage {
    if !isKnownUniquelyReferenced(&_storage) { _storage = _storage.copy() }
    return _storage
  }
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "swift_proto_testing"

extension SwiftProtoTesting_TestAllRequiredTypes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TestAllRequiredTypes"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}required_int32\0\u{3}required_int64\0\u{3}required_uint32\0\u{3}required_uint64\0\u{3}required_sint32\0\u{3}required_sint64\0\u{3}required_fixed32\0\u{3}required_fixed64\0\u{3}required_sfixed32\0\u{3}required_sfixed64\0\u{3}required_float\0\u{3}required_double\0\u{3}required_bool\0\u{3}required_string\0\u{3}required_bytes\0\u{7}RequiredGroup\0\u{4}\u{2}required_nested_message\0\u{3}required_foreign_message\0\u{3}required_import_message\0\u{3}required_nested_enum\0\u{3}required_foreign_enum\0\u{3}required_import_enum\0\u{4}\u{3}required_public_import_message\0\u{4}#default_int32\0\u{3}default_int64\0\u{3}default_uint32\0\u{3}default_uint64\0\u{3}default_sint32\0\u{3}default_sint64\0\u{3}default_fixed32\0\u{3}default_fixed64\0\u{3}default_sfixed32\0\u{3}default_sfixed64\0\u{3}default_float\0\u{3}default_double\0\u{3}default_bool\0\u{3}default_string\0\u{3}default_bytes\0\u{4}\u{6}default_nested_enum\0\u{3}default_foreign_enum\0\u{3}default_import_enum\0\u{4}\u{1c}oneof_uint32\0\u{3}oneof_nested_message\0\u{3}oneof_string\0\u{3}oneof_bytes\0")
  #if _pointerBitWidth(_64)
    @_alwaysEmitIntoClient @inline(__always)
    private static var _protobuf_messageLayoutString: StaticString { "\0`\u{2}\0-\0\0)\0\0-\0\0\u{11}\0\0\u{1}\0\0\0\0\u{1c}\0\0\0\0\0\0\u{5}\u{2}\0\0\0\0h\0\0\u{1}\0\0\0\u{3}\u{3}\0\0\0\0 \0\0\u{2}\0\0\0\u{d}\u{4}\0\0\0\0p\0\0\u{3}\0\0\0\u{4}\u{5}\0\0\0\0$\0\0\u{4}\0\0\0\u{11}\u{6}\0\0\0\0x\0\0\u{5}\0\0\0\u{12}\u{7}\0\0\0\0(\0\0\u{6}\0\0\0\u{7}\u{8}\0\0\0\0\0\u{1}\0\u{7}\0\0\0\u{6}\u{9}\0\0\0\0,\0\0\u{8}\0\0\0\u{f}\u{a}\0\0\0\0\u{8}\u{1}\0\u{9}\0\0\0\u{10}\u{b}\0\0\0\00\0\0\u{a}\0\0\0\u{2}\u{c}\0\0\0\0\u{10}\u{1}\0\u{b}\0\0\0\u{1}\u{d}\0\0\0\0\u{18}\0\0\u{c}\0\0\0\u{8}\u{e}\0\0\0\0\0\u{2}\0\u{d}\0\0\0\u{9}\u{f}\0\0\0\0\u{10}\u{2}\0\u{e}\0\0\0\u{c}\u{10}\0\0\0\0H\u{1}\0\u{f}\0\u{1}\0\u{a}\u{12}\0\0\0\0P\u{1}\0\u{10}\0\u{2}\0\u{b}\u{13}\0\0\0\0X\u{1}\0\u{11}\0\u{3}\0\u{b}\u{14}\0\0\0\0`\u{1}\0\u{12}\0\u{4}\0\u{b}\u{15}\0\0\0\04\0\0\u{13}\0\0\0\u{e}\u{16}\0\0\0\08\0\0\u{14}\0\0\0\u{e}\u{17}\0\0\0\0<\0\0\u{15}\0\0\0\u{e}\u{1a}\0\0\0\0h\u{1}\0\u{16}\0\u{5}\0\u{b}=\0\0\0\0@\0\0\u{17}\0\0\0\u{5}>\0\0\0\0\u{18}\u{1}\0\u{18}\0\0\0\u{3}?\0\0\0\0D\0\0\u{19}\0\0\0\u{d}@\0\0\0\0 \u{1}\0\u{1a}\0\0\0\u{4}A\0\0\0\0H\0\0\u{1b}\0\0\0\u{11}B\0\0\0\0(\u{1}\0\u{1c}\0\0\0\u{12}C\0\0\0\0L\0\0\u{1d}\0\0\0\u{7}D\0\0\0\00\u{1}\0\u{1e}\0\0\0\u{6}E\0\0\0\0P\0\0\u{1f}\0\0\0\u{f}F\0\0\0\08\u{1}\0 \0\0\0\u{10}G\0\0\0\0T\0\0!\0\0\0\u{2}H\0\0\0\0@\u{1}\0\"\0\0\0\u{1}I\0\0\0\0\u{19}\0\0#\0\0\0\u{8}J\0\0\0\0 \u{2}\0$\0\0\0\u{9}K\0\0\0\00\u{2}\0%\0\0\0\u{c}Q\0\0\0\0X\0\0&\0\0\0\u{e}R\0\0\0\0\\\0\0'\0\0\0\u{e}S\0\0\0\0`\0\0(\0\0\0\u{e}o\0\0\0\0d\0\0w\u{7f}\0\0\u{d}p\0\0\0\0p\u{1}\0w\u{7f}\u{2}\0\u{b}q\0\0\0\0@\u{2}\0w\u{7f}\0\0\u{9}r\0\0\0\0P\u{2}\0w\u{7f}\0\0\u{c}" }
  #elseif _pointerBitWidth(_32)
    @_alwaysEmitIntoClient @inline(__always)
    private static var _protobuf_messageLayoutString: StaticString { "\0,\u{2}\0-\0\0)\0\0-\0\0\u{11}\0\0\u{1}\0\0\0\0\u{1c}\0\0\0\0\0\0\u{5}\u{2}\0\0\0\0h\0\0\u{1}\0\0\0\u{3}\u{3}\0\0\0\0 \0\0\u{2}\0\0\0\u{d}\u{4}\0\0\0\0p\0\0\u{3}\0\0\0\u{4}\u{5}\0\0\0\0$\0\0\u{4}\0\0\0\u{11}\u{6}\0\0\0\0x\0\0\u{5}\0\0\0\u{12}\u{7}\0\0\0\0(\0\0\u{6}\0\0\0\u{7}\u{8}\0\0\0\0\0\u{1}\0\u{7}\0\0\0\u{6}\u{9}\0\0\0\0,\0\0\u{8}\0\0\0\u{f}\u{a}\0\0\0\0\u{8}\u{1}\0\u{9}\0\0\0\u{10}\u{b}\0\0\0\00\0\0\u{a}\0\0\0\u{2}\u{c}\0\0\0\0\u{10}\u{1}\0\u{b}\0\0\0\u{1}\u{d}\0\0\0\0\u{18}\0\0\u{c}\0\0\0\u{8}\u{e}\0\0\0\0d\u{1}\0\u{d}\0\0\0\u{9}\u{f}\0\0\0\0p\u{1}\0\u{e}\0\0\0\u{c}\u{10}\0\0\0\0H\u{1}\0\u{f}\0\u{1}\0\u{a}\u{12}\0\0\0\0L\u{1}\0\u{10}\0\u{2}\0\u{b}\u{13}\0\0\0\0P\u{1}\0\u{11}\0\u{3}\0\u{b}\u{14}\0\0\0\0T\u{1}\0\u{12}\0\u{4}\0\u{b}\u{15}\0\0\0\04\0\0\u{13}\0\0\0\u{e}\u{16}\0\0\0\08\0\0\u{14}\0\0\0\u{e}\u{17}\0\0\0\0<\0\0\u{15}\0\0\0\u{e}\u{1a}\0\0\0\0X\u{1}\0\u{16}\0\u{5}\0\u{b}=\0\0\0\0@\0\0\u{17}\0\0\0\u{5}>\0\0\0\0\u{18}\u{1}\0\u{18}\0\0\0\u{3}?\0\0\0\0D\0\0\u{19}\0\0\0\u{d}@\0\0\0\0 \u{1}\0\u{1a}\0\0\0\u{4}A\0\0\0\0H\0\0\u{1b}\0\0\0\u{11}B\0\0\0\0(\u{1}\0\u{1c}\0\0\0\u{12}C\0\0\0\0L\0\0\u{1d}\0\0\0\u{7}D\0\0\0\00\u{1}\0\u{1e}\0\0\0\u{6}E\0\0\0\0P\0\0\u{1f}\0\0\0\u{f}F\0\0\0\08\u{1}\0 \0\0\0\u{10}G\0\0\0\0T\0\0!\0\0\0\u{2}H\0\0\0\0@\u{1}\0\"\0\0\0\u{1}I\0\0\0\0\u{19}\0\0#\0\0\0\u{8}J\0\0\0\0|\u{1}\0$\0\0\0\u{9}K\0\0\0\0\u{8}\u{2}\0%\0\0\0\u{c}Q\0\0\0\0X\0\0&\0\0\0\u{e}R\0\0\0\0\\\0\0'\0\0\0\u{e}S\0\0\0\0`\0\0(\0\0\0\u{e}o\0\0\0\0d\0\0w\u{7f}\0\0\u{d}p\0\0\0\0\\\u{1}\0w\u{7f}\u{2}\0\u{b}q\0\0\0\0\u{14}\u{2}\0w\u{7f}\0\0\u{9}r\0\0\0\0 \u{2}\0w\u{7f}\0\0\u{c}" }
  #else
    #error("Unsupported platform")
  #endif

  private static let _protobuf_messageLayout = SwiftProtobuf._MessageLayout(layout: _protobuf_messageLayoutString, deinitializeSubmessage: _protobuf_deinitializeSubmessage, copySubmessage: _protobuf_copySubmessage, areSubmessagesEqual: _protobuf_areSubmessagesEqual, performOnSubmessageStorage: _protobuf_performOnSubmessageStorage)

  private static func _protobuf_deinitializeSubmessage(for token: SwiftProtobuf._MessageLayout.SubmessageToken, field: SwiftProtobuf.FieldLayout, storage: SwiftProtobuf._MessageStorage) {
    switch token.index {
    case 1: storage.deinitializeField(field, type: SwiftProtoTesting_TestAllRequiredTypes.RequiredGroup.self)
    case 2: storage.deinitializeField(field, type: SwiftProtoTesting_TestAllRequiredTypes.NestedMessage.self)
    case 3: storage.deinitializeField(field, type: SwiftProtoTesting_ForeignMessage.self)
    case 4: storage.deinitializeField(field, type: SwiftProtoTesting_Import_ImportMessage.self)
    case 5: storage.deinitializeField(field, type: SwiftProtoTesting_Import_PublicImportMessage.self)
    default: preconditionFailure("invalid submessage token; this is a generator bug")
    }
  }

  private static func _protobuf_copySubmessage(for token: SwiftProtobuf._MessageLayout.SubmessageToken, field: SwiftProtobuf.FieldLayout, from source: SwiftProtobuf._MessageStorage, to destination: SwiftProtobuf._MessageStorage) {
    switch token.index {
    case 1: source.copyField(field, to: destination, type: SwiftProtoTesting_TestAllRequiredTypes.RequiredGroup.self)
    case 2: source.copyField(field, to: destination, type: SwiftProtoTesting_TestAllRequiredTypes.NestedMessage.self)
    case 3: source.copyField(field, to: destination, type: SwiftProtoTesting_ForeignMessage.self)
    case 4: source.copyField(field, to: destination, type: SwiftProtoTesting_Import_ImportMessage.self)
    case 5: source.copyField(field, to: destination, type: SwiftProtoTesting_Import_PublicImportMessage.self)
    default: preconditionFailure("invalid submessage token; this is a generator bug")
    }
  }

  private static func _protobuf_areSubmessagesEqual(for token: SwiftProtobuf._MessageLayout.SubmessageToken, field: SwiftProtobuf.FieldLayout, lhs: SwiftProtobuf._MessageStorage, rhs: SwiftProtobuf._MessageStorage) -> Bool {
    switch token.index {
    case 1: return lhs.isField(field, equalToSameFieldIn: rhs, type: SwiftProtoTesting_TestAllRequiredTypes.RequiredGroup.self)
    case 2: return lhs.isField(field, equalToSameFieldIn: rhs, type: SwiftProtoTesting_TestAllRequiredTypes.NestedMessage.self)
    case 3: return lhs.isField(field, equalToSameFieldIn: rhs, type: SwiftProtoTesting_ForeignMessage.self)
    case 4: return lhs.isField(field, equalToSameFieldIn: rhs, type: SwiftProtoTesting_Import_ImportMessage.self)
    case 5: return lhs.isField(field, equalToSameFieldIn: rhs, type: SwiftProtoTesting_Import_PublicImportMessage.self)
    default: preconditionFailure("invalid submessage token; this is a generator bug")
    }
  }

  private static func _protobuf_performOnSubmessageStorage(for token: SwiftProtobuf._MessageLayout.SubmessageToken, field: SwiftProtobuf.FieldLayout, storage: SwiftProtobuf._MessageStorage, perform: (SwiftProtobuf._MessageStorage) throws -> Bool) throws -> Bool {
    switch token.index {
    case 1: return try storage.performOnSubmessageStorage(of: field, type: SwiftProtoTesting_TestAllRequiredTypes.RequiredGroup.self, perform: perform)
    case 2: return try storage.performOnSubmessageStorage(of: field, type: SwiftProtoTesting_TestAllRequiredTypes.NestedMessage.self, perform: perform)
    case 3: return try storage.performOnSubmessageStorage(of: field, type: SwiftProtoTesting_ForeignMessage.self, perform: perform)
    case 4: return try storage.performOnSubmessageStorage(of: field, type: SwiftProtoTesting_Import_ImportMessage.self, perform: perform)
    case 5: return try storage.performOnSubmessageStorage(of: field, type: SwiftProtoTesting_Import_PublicImportMessage.self, perform: perform)
    default: preconditionFailure("invalid submessage token; this is a generator bug")
    }
  }

  func _protobuf_messageStorage(accessToken: SwiftProtobuf._MessageStorageToken) -> AnyObject { _storage }

  public var isInitialized: Bool {
    return _storage.isInitialized
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    fatalError("table-driven decodeMessage not yet implemented")
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    fatalError("table-driven traverse not yet implemented")
  }

  func serializedBytes<Bytes: SwiftProtobufContiguousBytes>(partial: Bool = false, options: BinaryEncodingOptions = BinaryEncodingOptions()) throws -> Bytes {
    return try _storage.serializedBytes(partial: partial, options: options)
  }
  mutating func _merge(rawBuffer body: UnsafeRawBufferPointer, extensions: (any ExtensionMap)?, partial: Bool, options: BinaryDecodingOptions) throws {
    try _uniqueStorage().merge(byReadingFrom: body, partial: partial, options: options)
  }

  static func ==(lhs: SwiftProtoTesting_TestAllRequiredTypes, rhs: SwiftProtoTesting_TestAllRequiredTypes) -> Bool {
    return lhs._storage.isEqual(to: rhs._storage)
  }
}

extension SwiftProtoTesting_TestAllRequiredTypes.NestedEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{7f}\u{7f}\u{7f}\u{7f}\u{7f}\u{3}NEG\0\u{2}\u{2}FOO\0\u{1}BAR\0\u{1}BAZ\0")
}

extension SwiftProtoTesting_TestAllRequiredTypes.NestedMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SwiftProtoTesting_TestAllRequiredTypes.protoMessageName + ".NestedMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}bb\0")
  #if _pointerBitWidth(_64)
    @_alwaysEmitIntoClient @inline(__always)
    private static var _protobuf_messageLayoutString: StaticString { "\0\u{8}\0\0\u{1}\0\0\u{1}\0\0\u{1}\0\0\u{2}\0\0\u{1}\0\0\0\0\u{4}\0\0\0\0\0\0\u{5}" }
  #elseif _pointerBitWidth(_32)
    @_alwaysEmitIntoClient @inline(__always)
    private static var _protobuf_messageLayoutString: StaticString { "\0\u{8}\0\0\u{1}\0\0\u{1}\0\0\u{1}\0\0\u{2}\0\0\u{1}\0\0\0\0\u{4}\0\0\0\0\0\0\u{5}" }
  #else
    #error("Unsupported platform")
  #endif

  private static let _protobuf_messageLayout = SwiftProtobuf._MessageLayout(layout: _protobuf_messageLayoutString)

  func _protobuf_messageStorage(accessToken: SwiftProtobuf._MessageStorageToken) -> AnyObject { _storage }

  public var isInitialized: Bool {
    return _storage.isInitialized
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    fatalError("table-driven decodeMessage not yet implemented")
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    fatalError("table-driven traverse not yet implemented")
  }

  func serializedBytes<Bytes: SwiftProtobufContiguousBytes>(partial: Bool = false, options: BinaryEncodingOptions = BinaryEncodingOptions()) throws -> Bytes {
    return try _storage.serializedBytes(partial: partial, options: options)
  }
  mutating func _merge(rawBuffer body: UnsafeRawBufferPointer, extensions: (any ExtensionMap)?, partial: Bool, options: BinaryDecodingOptions) throws {
    try _uniqueStorage().merge(byReadingFrom: body, partial: partial, options: options)
  }

  static func ==(lhs: SwiftProtoTesting_TestAllRequiredTypes.NestedMessage, rhs: SwiftProtoTesting_TestAllRequiredTypes.NestedMessage) -> Bool {
    return lhs._storage.isEqual(to: rhs._storage)
  }
}

extension SwiftProtoTesting_TestAllRequiredTypes.RequiredGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SwiftProtoTesting_TestAllRequiredTypes.protoMessageName + ".RequiredGroup"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{11}a\0")
  #if _pointerBitWidth(_64)
    @_alwaysEmitIntoClient @inline(__always)
    private static var _protobuf_messageLayoutString: StaticString { "\0\u{8}\0\0\u{1}\0\0\u{1}\0\0\u{1}\0\0\u{1}\0\0\u{11}\0\0\0\0\u{4}\0\0\0\0\0\0\u{5}" }
  #elseif _pointerBitWidth(_32)
    @_alwaysEmitIntoClient @inline(__always)
    private static var _protobuf_messageLayoutString: StaticString { "\0\u{8}\0\0\u{1}\0\0\u{1}\0\0\u{1}\0\0\u{1}\0\0\u{11}\0\0\0\0\u{4}\0\0\0\0\0\0\u{5}" }
  #else
    #error("Unsupported platform")
  #endif

  private static let _protobuf_messageLayout = SwiftProtobuf._MessageLayout(layout: _protobuf_messageLayoutString)

  func _protobuf_messageStorage(accessToken: SwiftProtobuf._MessageStorageToken) -> AnyObject { _storage }

  public var isInitialized: Bool {
    return _storage.isInitialized
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    fatalError("table-driven decodeMessage not yet implemented")
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    fatalError("table-driven traverse not yet implemented")
  }

  func serializedBytes<Bytes: SwiftProtobufContiguousBytes>(partial: Bool = false, options: BinaryEncodingOptions = BinaryEncodingOptions()) throws -> Bytes {
    return try _storage.serializedBytes(partial: partial, options: options)
  }
  mutating func _merge(rawBuffer body: UnsafeRawBufferPointer, extensions: (any ExtensionMap)?, partial: Bool, options: BinaryDecodingOptions) throws {
    try _uniqueStorage().merge(byReadingFrom: body, partial: partial, options: options)
  }

  static func ==(lhs: SwiftProtoTesting_TestAllRequiredTypes.RequiredGroup, rhs: SwiftProtoTesting_TestAllRequiredTypes.RequiredGroup) -> Bool {
    return lhs._storage.isEqual(to: rhs._storage)
  }
}

extension SwiftProtoTesting_TestSomeRequiredTypes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TestSomeRequiredTypes"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}required_int32\0\u{3}required_float\0\u{3}required_bool\0\u{3}required_string\0\u{3}required_bytes\0\u{3}required_nested_enum\0")
  #if _pointerBitWidth(_64)
    @_alwaysEmitIntoClient @inline(__always)
    private static var _protobuf_messageLayoutString: StaticString { "\00\0\0\u{6}\0\0\u{6}\0\0\u{6}\0\0\u{7}\0\0\u{1}\0\0\0\0\u{4}\0\0\0\0\0\0\u{5}\u{2}\0\0\0\0\u{8}\0\0\u{1}\0\0\0\u{2}\u{3}\0\0\0\0\u{1}\0\0\u{2}\0\0\0\u{8}\u{4}\0\0\0\0\u{10}\0\0\u{3}\0\0\0\u{9}\u{5}\0\0\0\0 \0\0\u{4}\0\0\0\u{c}\u{6}\0\0\0\0\u{c}\0\0\u{5}\0\0\0\u{e}" }
  #elseif _pointerBitWidth(_32)
    @_alwaysEmitIntoClient @inline(__always)
    private static var _protobuf_messageLayoutString: StaticString { "\00\0\0\u{6}\0\0\u{6}\0\0\u{6}\0\0\u{7}\0\0\u{1}\0\0\0\0\u{4}\0\0\0\0\0\0\u{5}\u{2}\0\0\0\0\u{8}\0\0\u{1}\0\0\0\u{2}\u{3}\0\0\0\0\u{1}\0\0\u{2}\0\0\0\u{8}\u{4}\0\0\0\0\u{18}\0\0\u{3}\0\0\0\u{9}\u{5}\0\0\0\0$\0\0\u{4}\0\0\0\u{c}\u{6}\0\0\0\0\u{c}\0\0\u{5}\0\0\0\u{e}" }
  #else
    #error("Unsupported platform")
  #endif

  private static let _protobuf_messageLayout = SwiftProtobuf._MessageLayout(layout: _protobuf_messageLayoutString)

  func _protobuf_messageStorage(accessToken: SwiftProtobuf._MessageStorageToken) -> AnyObject { _storage }

  public var isInitialized: Bool {
    return _storage.isInitialized
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    fatalError("table-driven decodeMessage not yet implemented")
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    fatalError("table-driven traverse not yet implemented")
  }

  func serializedBytes<Bytes: SwiftProtobufContiguousBytes>(partial: Bool = false, options: BinaryEncodingOptions = BinaryEncodingOptions()) throws -> Bytes {
    return try _storage.serializedBytes(partial: partial, options: options)
  }
  mutating func _merge(rawBuffer body: UnsafeRawBufferPointer, extensions: (any ExtensionMap)?, partial: Bool, options: BinaryDecodingOptions) throws {
    try _uniqueStorage().merge(byReadingFrom: body, partial: partial, options: options)
  }

  static func ==(lhs: SwiftProtoTesting_TestSomeRequiredTypes, rhs: SwiftProtoTesting_TestSomeRequiredTypes) -> Bool {
    return lhs._storage.isEqual(to: rhs._storage)
  }
}

extension SwiftProtoTesting_TestSomeRequiredTypes.NestedEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}FOO\0")
}
