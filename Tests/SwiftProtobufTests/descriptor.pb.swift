/*
 * DO NOT EDIT.
 *
 * Generated by the protocol buffer compiler.
 * Source: google/protobuf/descriptor.proto
 *
 */

//  Protocol Buffers - Google's data interchange format
//  Copyright 2008 Google Inc.  All rights reserved.
//  https://developers.google.com/protocol-buffers/
// 
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are
//  met:
// 
//      * Redistributions of source code must retain the above copyright
//  notice, this list of conditions and the following disclaimer.
//      * Redistributions in binary form must reproduce the above
//  copyright notice, this list of conditions and the following disclaimer
//  in the documentation and/or other materials provided with the
//  distribution.
//      * Neither the name of Google Inc. nor the names of its
//  contributors may be used to endorse or promote products derived from
//  this software without specific prior written permission.
// 
//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
//  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
//  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
//  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
//  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
//  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
//  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
//  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//  Author: kenton@google.com (Kenton Varda)
//   Based on original Protocol Buffers design by
//   Sanjay Ghemawat, Jeff Dean, and others.
// 
//  The messages in this file describe the definitions found in .proto files.
//  A valid .proto file can be translated directly to a FileDescriptorProto
//  without any other information (e.g. without reading its imports).

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _1: SwiftProtobuf.ProtobufAPIVersion_1 {}
  typealias Version = _1
}

///   The protocol compiler can output a FileDescriptorSet containing the .proto
///   files it parses.
struct Google_Protobuf_FileDescriptorSet: SwiftProtobuf.Message, SwiftProtobuf.Proto2Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Google_Protobuf_FileDescriptorSet"}
  public var protoMessageName: String {return "FileDescriptorSet"}
  public var protoPackageName: String {return "google.protobuf"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "file", swift: "file"),
  ]

  public var unknown = SwiftProtobuf.UnknownStorage()

  var file: [Google_Protobuf_FileDescriptorProto] = []

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    switch protoFieldNumber {
    case 1: try setter.decodeRepeatedMessageField(fieldType: Google_Protobuf_FileDescriptorProto.self, value: &file)
    default: break
    }
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    if !file.isEmpty {
      try visitor.visitRepeatedMessageField(value: file, fieldNumber: 1)
    }
    unknown.traverse(visitor: visitor)
  }

  public func _protoc_generated_isEqualTo(other: Google_Protobuf_FileDescriptorSet) -> Bool {
    if file != other.file {return false}
    if unknown != other.unknown {return false}
    return true
  }
}

///   Describes a complete .proto file.
struct Google_Protobuf_FileDescriptorProto: SwiftProtobuf.Message, SwiftProtobuf.Proto2Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Google_Protobuf_FileDescriptorProto"}
  public var protoMessageName: String {return "FileDescriptorProto"}
  public var protoPackageName: String {return "google.protobuf"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "name", swift: "name"),
    2: .same(proto: "package", swift: "package"),
    3: .same(proto: "dependency", swift: "dependency"),
    10: .unique(proto: "public_dependency", json: "publicDependency", swift: "publicDependency"),
    11: .unique(proto: "weak_dependency", json: "weakDependency", swift: "weakDependency"),
    4: .unique(proto: "message_type", json: "messageType", swift: "messageType"),
    5: .unique(proto: "enum_type", json: "enumType", swift: "enumType"),
    6: .same(proto: "service", swift: "service"),
    7: .same(proto: "extension", swift: "extension_p"),
    8: .same(proto: "options", swift: "options"),
    9: .unique(proto: "source_code_info", json: "sourceCodeInfo", swift: "sourceCodeInfo"),
    12: .same(proto: "syntax", swift: "syntax"),
  ]

  private class _StorageClass {
    typealias ExtendedMessage = Google_Protobuf_FileDescriptorProto
    var unknown = SwiftProtobuf.UnknownStorage()
    var _name: String? = nil
    var _package: String? = nil
    var _dependency: [String] = []
    var _publicDependency: [Int32] = []
    var _weakDependency: [Int32] = []
    var _messageType: [Google_Protobuf_DescriptorProto] = []
    var _enumType: [Google_Protobuf_EnumDescriptorProto] = []
    var _service: [Google_Protobuf_ServiceDescriptorProto] = []
    var _extension_p: [Google_Protobuf_FieldDescriptorProto] = []
    var _options: Google_Protobuf_FileOptions? = nil
    var _sourceCodeInfo: Google_Protobuf_SourceCodeInfo? = nil
    var _syntax: String? = nil

    init() {}

    func decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
      switch protoFieldNumber {
      case 1: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: &_name)
      case 2: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: &_package)
      case 3: try setter.decodeRepeatedField(fieldType: SwiftProtobuf.ProtobufString.self, value: &_dependency)
      case 10: try setter.decodeRepeatedField(fieldType: SwiftProtobuf.ProtobufInt32.self, value: &_publicDependency)
      case 11: try setter.decodeRepeatedField(fieldType: SwiftProtobuf.ProtobufInt32.self, value: &_weakDependency)
      case 4: try setter.decodeRepeatedMessageField(fieldType: Google_Protobuf_DescriptorProto.self, value: &_messageType)
      case 5: try setter.decodeRepeatedMessageField(fieldType: Google_Protobuf_EnumDescriptorProto.self, value: &_enumType)
      case 6: try setter.decodeRepeatedMessageField(fieldType: Google_Protobuf_ServiceDescriptorProto.self, value: &_service)
      case 7: try setter.decodeRepeatedMessageField(fieldType: Google_Protobuf_FieldDescriptorProto.self, value: &_extension_p)
      case 8: try setter.decodeSingularMessageField(fieldType: Google_Protobuf_FileOptions.self, value: &_options)
      case 9: try setter.decodeSingularMessageField(fieldType: Google_Protobuf_SourceCodeInfo.self, value: &_sourceCodeInfo)
      case 12: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: &_syntax)
      default: break
      }
    }

    func traverse(visitor: SwiftProtobuf.Visitor) throws {
      if let v = _name {
        try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: v, fieldNumber: 1)
      }
      if let v = _package {
        try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: v, fieldNumber: 2)
      }
      if !_dependency.isEmpty {
        try visitor.visitRepeatedField(fieldType: SwiftProtobuf.ProtobufString.self, value: _dependency, fieldNumber: 3)
      }
      if !_messageType.isEmpty {
        try visitor.visitRepeatedMessageField(value: _messageType, fieldNumber: 4)
      }
      if !_enumType.isEmpty {
        try visitor.visitRepeatedMessageField(value: _enumType, fieldNumber: 5)
      }
      if !_service.isEmpty {
        try visitor.visitRepeatedMessageField(value: _service, fieldNumber: 6)
      }
      if !_extension_p.isEmpty {
        try visitor.visitRepeatedMessageField(value: _extension_p, fieldNumber: 7)
      }
      if let v = _options {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _sourceCodeInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if !_publicDependency.isEmpty {
        try visitor.visitRepeatedField(fieldType: SwiftProtobuf.ProtobufInt32.self, value: _publicDependency, fieldNumber: 10)
      }
      if !_weakDependency.isEmpty {
        try visitor.visitRepeatedField(fieldType: SwiftProtobuf.ProtobufInt32.self, value: _weakDependency, fieldNumber: 11)
      }
      if let v = _syntax {
        try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: v, fieldNumber: 12)
      }
      unknown.traverse(visitor: visitor)
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _name != other._name {return false}
      if _package != other._package {return false}
      if _dependency != other._dependency {return false}
      if _publicDependency != other._publicDependency {return false}
      if _weakDependency != other._weakDependency {return false}
      if _messageType != other._messageType {return false}
      if _enumType != other._enumType {return false}
      if _service != other._service {return false}
      if _extension_p != other._extension_p {return false}
      if _options != other._options {return false}
      if _sourceCodeInfo != other._sourceCodeInfo {return false}
      if _syntax != other._syntax {return false}
      if unknown != other.unknown {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone.unknown = unknown
      clone._name = _name
      clone._package = _package
      clone._dependency = _dependency
      clone._publicDependency = _publicDependency
      clone._weakDependency = _weakDependency
      clone._messageType = _messageType
      clone._enumType = _enumType
      clone._service = _service
      clone._extension_p = _extension_p
      clone._options = _options
      clone._sourceCodeInfo = _sourceCodeInfo
      clone._syntax = _syntax
      return clone
    }
  }

  private var _storage = _StorageClass()

  public var unknown: SwiftProtobuf.UnknownStorage {
    get {return _storage.unknown}
    set {_storage.unknown = newValue}
  }

  ///   file name, relative to root of source tree
  var name: String {
    get {return _storage._name ?? ""}
    set {_uniqueStorage()._name = newValue}
  }
  public var hasName: Bool {
    return _storage._name != nil
  }
  public mutating func clearName() {
    return _storage._name = nil
  }

  ///   e.g. "foo", "foo.bar", etc.
  var package: String {
    get {return _storage._package ?? ""}
    set {_uniqueStorage()._package = newValue}
  }
  public var hasPackage: Bool {
    return _storage._package != nil
  }
  public mutating func clearPackage() {
    return _storage._package = nil
  }

  ///   Names of files imported by this file.
  var dependency: [String] {
    get {return _storage._dependency}
    set {_uniqueStorage()._dependency = newValue}
  }

  ///   Indexes of the public imported files in the dependency list above.
  var publicDependency: [Int32] {
    get {return _storage._publicDependency}
    set {_uniqueStorage()._publicDependency = newValue}
  }

  ///   Indexes of the weak imported files in the dependency list.
  ///   For Google-internal migration only. Do not use.
  var weakDependency: [Int32] {
    get {return _storage._weakDependency}
    set {_uniqueStorage()._weakDependency = newValue}
  }

  ///   All top-level definitions in this file.
  var messageType: [Google_Protobuf_DescriptorProto] {
    get {return _storage._messageType}
    set {_uniqueStorage()._messageType = newValue}
  }

  var enumType: [Google_Protobuf_EnumDescriptorProto] {
    get {return _storage._enumType}
    set {_uniqueStorage()._enumType = newValue}
  }

  var service: [Google_Protobuf_ServiceDescriptorProto] {
    get {return _storage._service}
    set {_uniqueStorage()._service = newValue}
  }

  var extension_p: [Google_Protobuf_FieldDescriptorProto] {
    get {return _storage._extension_p}
    set {_uniqueStorage()._extension_p = newValue}
  }

  var options: Google_Protobuf_FileOptions {
    get {return _storage._options ?? Google_Protobuf_FileOptions()}
    set {_uniqueStorage()._options = newValue}
  }
  public var hasOptions: Bool {
    return _storage._options != nil
  }
  public mutating func clearOptions() {
    return _storage._options = nil
  }

  ///   This field contains optional information about the original source code.
  ///   You may safely remove this entire field without harming runtime
  ///   functionality of the descriptors -- the information is needed only by
  ///   development tools.
  var sourceCodeInfo: Google_Protobuf_SourceCodeInfo {
    get {return _storage._sourceCodeInfo ?? Google_Protobuf_SourceCodeInfo()}
    set {_uniqueStorage()._sourceCodeInfo = newValue}
  }
  public var hasSourceCodeInfo: Bool {
    return _storage._sourceCodeInfo != nil
  }
  public mutating func clearSourceCodeInfo() {
    return _storage._sourceCodeInfo = nil
  }

  ///   The syntax of the proto file.
  ///   The supported values are "proto2" and "proto3".
  var syntax: String {
    get {return _storage._syntax ?? ""}
    set {_uniqueStorage()._syntax = newValue}
  }
  public var hasSyntax: Bool {
    return _storage._syntax != nil
  }
  public mutating func clearSyntax() {
    return _storage._syntax = nil
  }

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    try _storage.traverse(visitor: visitor)
  }

  public func _protoc_generated_isEqualTo(other: Google_Protobuf_FileDescriptorProto) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

///   Describes a message type.
struct Google_Protobuf_DescriptorProto: SwiftProtobuf.Message, SwiftProtobuf.Proto2Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Google_Protobuf_DescriptorProto"}
  public var protoMessageName: String {return "DescriptorProto"}
  public var protoPackageName: String {return "google.protobuf"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "name", swift: "name"),
    2: .same(proto: "field", swift: "field"),
    6: .same(proto: "extension", swift: "extension_p"),
    3: .unique(proto: "nested_type", json: "nestedType", swift: "nestedType"),
    4: .unique(proto: "enum_type", json: "enumType", swift: "enumType"),
    5: .unique(proto: "extension_range", json: "extensionRange", swift: "extensionRange"),
    8: .unique(proto: "oneof_decl", json: "oneofDecl", swift: "oneofDecl"),
    7: .same(proto: "options", swift: "options"),
    9: .unique(proto: "reserved_range", json: "reservedRange", swift: "reservedRange"),
    10: .unique(proto: "reserved_name", json: "reservedName", swift: "reservedName"),
  ]

  private class _StorageClass {
    typealias ExtendedMessage = Google_Protobuf_DescriptorProto
    var unknown = SwiftProtobuf.UnknownStorage()
    var _name: String? = nil
    var _field: [Google_Protobuf_FieldDescriptorProto] = []
    var _extension_p: [Google_Protobuf_FieldDescriptorProto] = []
    var _nestedType: [Google_Protobuf_DescriptorProto] = []
    var _enumType: [Google_Protobuf_EnumDescriptorProto] = []
    var _extensionRange: [Google_Protobuf_DescriptorProto.ExtensionRange] = []
    var _oneofDecl: [Google_Protobuf_OneofDescriptorProto] = []
    var _options: Google_Protobuf_MessageOptions? = nil
    var _reservedRange: [Google_Protobuf_DescriptorProto.ReservedRange] = []
    var _reservedName: [String] = []

    init() {}

    func decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
      switch protoFieldNumber {
      case 1: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: &_name)
      case 2: try setter.decodeRepeatedMessageField(fieldType: Google_Protobuf_FieldDescriptorProto.self, value: &_field)
      case 6: try setter.decodeRepeatedMessageField(fieldType: Google_Protobuf_FieldDescriptorProto.self, value: &_extension_p)
      case 3: try setter.decodeRepeatedMessageField(fieldType: Google_Protobuf_DescriptorProto.self, value: &_nestedType)
      case 4: try setter.decodeRepeatedMessageField(fieldType: Google_Protobuf_EnumDescriptorProto.self, value: &_enumType)
      case 5: try setter.decodeRepeatedMessageField(fieldType: Google_Protobuf_DescriptorProto.ExtensionRange.self, value: &_extensionRange)
      case 8: try setter.decodeRepeatedMessageField(fieldType: Google_Protobuf_OneofDescriptorProto.self, value: &_oneofDecl)
      case 7: try setter.decodeSingularMessageField(fieldType: Google_Protobuf_MessageOptions.self, value: &_options)
      case 9: try setter.decodeRepeatedMessageField(fieldType: Google_Protobuf_DescriptorProto.ReservedRange.self, value: &_reservedRange)
      case 10: try setter.decodeRepeatedField(fieldType: SwiftProtobuf.ProtobufString.self, value: &_reservedName)
      default: break
      }
    }

    func traverse(visitor: SwiftProtobuf.Visitor) throws {
      if let v = _name {
        try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: v, fieldNumber: 1)
      }
      if !_field.isEmpty {
        try visitor.visitRepeatedMessageField(value: _field, fieldNumber: 2)
      }
      if !_nestedType.isEmpty {
        try visitor.visitRepeatedMessageField(value: _nestedType, fieldNumber: 3)
      }
      if !_enumType.isEmpty {
        try visitor.visitRepeatedMessageField(value: _enumType, fieldNumber: 4)
      }
      if !_extensionRange.isEmpty {
        try visitor.visitRepeatedMessageField(value: _extensionRange, fieldNumber: 5)
      }
      if !_extension_p.isEmpty {
        try visitor.visitRepeatedMessageField(value: _extension_p, fieldNumber: 6)
      }
      if let v = _options {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if !_oneofDecl.isEmpty {
        try visitor.visitRepeatedMessageField(value: _oneofDecl, fieldNumber: 8)
      }
      if !_reservedRange.isEmpty {
        try visitor.visitRepeatedMessageField(value: _reservedRange, fieldNumber: 9)
      }
      if !_reservedName.isEmpty {
        try visitor.visitRepeatedField(fieldType: SwiftProtobuf.ProtobufString.self, value: _reservedName, fieldNumber: 10)
      }
      unknown.traverse(visitor: visitor)
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _name != other._name {return false}
      if _field != other._field {return false}
      if _extension_p != other._extension_p {return false}
      if _nestedType != other._nestedType {return false}
      if _enumType != other._enumType {return false}
      if _extensionRange != other._extensionRange {return false}
      if _oneofDecl != other._oneofDecl {return false}
      if _options != other._options {return false}
      if _reservedRange != other._reservedRange {return false}
      if _reservedName != other._reservedName {return false}
      if unknown != other.unknown {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone.unknown = unknown
      clone._name = _name
      clone._field = _field
      clone._extension_p = _extension_p
      clone._nestedType = _nestedType
      clone._enumType = _enumType
      clone._extensionRange = _extensionRange
      clone._oneofDecl = _oneofDecl
      clone._options = _options
      clone._reservedRange = _reservedRange
      clone._reservedName = _reservedName
      return clone
    }
  }

  private var _storage = _StorageClass()

  public var unknown: SwiftProtobuf.UnknownStorage {
    get {return _storage.unknown}
    set {_storage.unknown = newValue}
  }

  struct ExtensionRange: SwiftProtobuf.Message, SwiftProtobuf.Proto2Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
    public var swiftClassName: String {return "Google_Protobuf_DescriptorProto.ExtensionRange"}
    public var protoMessageName: String {return "ExtensionRange"}
    public var protoPackageName: String {return "google.protobuf"}
    public static let _protobuf_fieldNames: FieldNameMap = [
      1: .same(proto: "start", swift: "start"),
      2: .same(proto: "end", swift: "end"),
    ]

    public var unknown = SwiftProtobuf.UnknownStorage()

    private var _start: Int32? = nil
    var start: Int32 {
      get {return _start ?? 0}
      set {_start = newValue}
    }
    public var hasStart: Bool {
      return _start != nil
    }
    public mutating func clearStart() {
      return _start = nil
    }

    private var _end: Int32? = nil
    var end: Int32 {
      get {return _end ?? 0}
      set {_end = newValue}
    }
    public var hasEnd: Bool {
      return _end != nil
    }
    public mutating func clearEnd() {
      return _end = nil
    }

    init() {}

    public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
      switch protoFieldNumber {
      case 1: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufInt32.self, value: &_start)
      case 2: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufInt32.self, value: &_end)
      default: break
      }
    }

    public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
      if let v = _start {
        try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufInt32.self, value: v, fieldNumber: 1)
      }
      if let v = _end {
        try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufInt32.self, value: v, fieldNumber: 2)
      }
      unknown.traverse(visitor: visitor)
    }

    public func _protoc_generated_isEqualTo(other: Google_Protobuf_DescriptorProto.ExtensionRange) -> Bool {
      if _start != other._start {return false}
      if _end != other._end {return false}
      if unknown != other.unknown {return false}
      return true
    }
  }

  ///   Range of reserved tag numbers. Reserved tag numbers may not be used by
  ///   fields or extension ranges in the same message. Reserved ranges may
  ///   not overlap.
  struct ReservedRange: SwiftProtobuf.Message, SwiftProtobuf.Proto2Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
    public var swiftClassName: String {return "Google_Protobuf_DescriptorProto.ReservedRange"}
    public var protoMessageName: String {return "ReservedRange"}
    public var protoPackageName: String {return "google.protobuf"}
    public static let _protobuf_fieldNames: FieldNameMap = [
      1: .same(proto: "start", swift: "start"),
      2: .same(proto: "end", swift: "end"),
    ]

    public var unknown = SwiftProtobuf.UnknownStorage()

    ///   Inclusive.
    private var _start: Int32? = nil
    var start: Int32 {
      get {return _start ?? 0}
      set {_start = newValue}
    }
    public var hasStart: Bool {
      return _start != nil
    }
    public mutating func clearStart() {
      return _start = nil
    }

    ///   Exclusive.
    private var _end: Int32? = nil
    var end: Int32 {
      get {return _end ?? 0}
      set {_end = newValue}
    }
    public var hasEnd: Bool {
      return _end != nil
    }
    public mutating func clearEnd() {
      return _end = nil
    }

    init() {}

    public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
      switch protoFieldNumber {
      case 1: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufInt32.self, value: &_start)
      case 2: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufInt32.self, value: &_end)
      default: break
      }
    }

    public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
      if let v = _start {
        try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufInt32.self, value: v, fieldNumber: 1)
      }
      if let v = _end {
        try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufInt32.self, value: v, fieldNumber: 2)
      }
      unknown.traverse(visitor: visitor)
    }

    public func _protoc_generated_isEqualTo(other: Google_Protobuf_DescriptorProto.ReservedRange) -> Bool {
      if _start != other._start {return false}
      if _end != other._end {return false}
      if unknown != other.unknown {return false}
      return true
    }
  }

  var name: String {
    get {return _storage._name ?? ""}
    set {_uniqueStorage()._name = newValue}
  }
  public var hasName: Bool {
    return _storage._name != nil
  }
  public mutating func clearName() {
    return _storage._name = nil
  }

  var field: [Google_Protobuf_FieldDescriptorProto] {
    get {return _storage._field}
    set {_uniqueStorage()._field = newValue}
  }

  var extension_p: [Google_Protobuf_FieldDescriptorProto] {
    get {return _storage._extension_p}
    set {_uniqueStorage()._extension_p = newValue}
  }

  var nestedType: [Google_Protobuf_DescriptorProto] {
    get {return _storage._nestedType}
    set {_uniqueStorage()._nestedType = newValue}
  }

  var enumType: [Google_Protobuf_EnumDescriptorProto] {
    get {return _storage._enumType}
    set {_uniqueStorage()._enumType = newValue}
  }

  var extensionRange: [Google_Protobuf_DescriptorProto.ExtensionRange] {
    get {return _storage._extensionRange}
    set {_uniqueStorage()._extensionRange = newValue}
  }

  var oneofDecl: [Google_Protobuf_OneofDescriptorProto] {
    get {return _storage._oneofDecl}
    set {_uniqueStorage()._oneofDecl = newValue}
  }

  var options: Google_Protobuf_MessageOptions {
    get {return _storage._options ?? Google_Protobuf_MessageOptions()}
    set {_uniqueStorage()._options = newValue}
  }
  public var hasOptions: Bool {
    return _storage._options != nil
  }
  public mutating func clearOptions() {
    return _storage._options = nil
  }

  var reservedRange: [Google_Protobuf_DescriptorProto.ReservedRange] {
    get {return _storage._reservedRange}
    set {_uniqueStorage()._reservedRange = newValue}
  }

  ///   Reserved field names, which may not be used by fields in the same message.
  ///   A given name may only be reserved once.
  var reservedName: [String] {
    get {return _storage._reservedName}
    set {_uniqueStorage()._reservedName = newValue}
  }

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    try _storage.traverse(visitor: visitor)
  }

  public func _protoc_generated_isEqualTo(other: Google_Protobuf_DescriptorProto) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

///   Describes a field within a message.
struct Google_Protobuf_FieldDescriptorProto: SwiftProtobuf.Message, SwiftProtobuf.Proto2Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Google_Protobuf_FieldDescriptorProto"}
  public var protoMessageName: String {return "FieldDescriptorProto"}
  public var protoPackageName: String {return "google.protobuf"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "name", swift: "name"),
    3: .same(proto: "number", swift: "number"),
    4: .same(proto: "label", swift: "label"),
    5: .same(proto: "type", swift: "type"),
    6: .unique(proto: "type_name", json: "typeName", swift: "typeName"),
    2: .same(proto: "extendee", swift: "extendee"),
    7: .unique(proto: "default_value", json: "defaultValue", swift: "defaultValue"),
    9: .unique(proto: "oneof_index", json: "oneofIndex", swift: "oneofIndex"),
    10: .unique(proto: "json_name", json: "jsonName", swift: "jsonName"),
    8: .same(proto: "options", swift: "options"),
  ]

  private class _StorageClass {
    typealias ExtendedMessage = Google_Protobuf_FieldDescriptorProto
    var unknown = SwiftProtobuf.UnknownStorage()
    var _name: String? = nil
    var _number: Int32? = nil
    var _label: Google_Protobuf_FieldDescriptorProto.Label? = nil
    var _type: Google_Protobuf_FieldDescriptorProto.TypeEnum? = nil
    var _typeName: String? = nil
    var _extendee: String? = nil
    var _defaultValue: String? = nil
    var _oneofIndex: Int32? = nil
    var _jsonName: String? = nil
    var _options: Google_Protobuf_FieldOptions? = nil

    init() {}

    func decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
      switch protoFieldNumber {
      case 1: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: &_name)
      case 3: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufInt32.self, value: &_number)
      case 4: try setter.decodeSingularField(fieldType: Google_Protobuf_FieldDescriptorProto.Label.self, value: &_label)
      case 5: try setter.decodeSingularField(fieldType: Google_Protobuf_FieldDescriptorProto.TypeEnum.self, value: &_type)
      case 6: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: &_typeName)
      case 2: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: &_extendee)
      case 7: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: &_defaultValue)
      case 9: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufInt32.self, value: &_oneofIndex)
      case 10: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: &_jsonName)
      case 8: try setter.decodeSingularMessageField(fieldType: Google_Protobuf_FieldOptions.self, value: &_options)
      default: break
      }
    }

    func traverse(visitor: SwiftProtobuf.Visitor) throws {
      if let v = _name {
        try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: v, fieldNumber: 1)
      }
      if let v = _extendee {
        try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: v, fieldNumber: 2)
      }
      if let v = _number {
        try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufInt32.self, value: v, fieldNumber: 3)
      }
      if let v = _label {
        try visitor.visitSingularField(fieldType: Google_Protobuf_FieldDescriptorProto.Label.self, value: v, fieldNumber: 4)
      }
      if let v = _type {
        try visitor.visitSingularField(fieldType: Google_Protobuf_FieldDescriptorProto.TypeEnum.self, value: v, fieldNumber: 5)
      }
      if let v = _typeName {
        try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: v, fieldNumber: 6)
      }
      if let v = _defaultValue {
        try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: v, fieldNumber: 7)
      }
      if let v = _options {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _oneofIndex {
        try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufInt32.self, value: v, fieldNumber: 9)
      }
      if let v = _jsonName {
        try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: v, fieldNumber: 10)
      }
      unknown.traverse(visitor: visitor)
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _name != other._name {return false}
      if _number != other._number {return false}
      if _label != other._label {return false}
      if _type != other._type {return false}
      if _typeName != other._typeName {return false}
      if _extendee != other._extendee {return false}
      if _defaultValue != other._defaultValue {return false}
      if _oneofIndex != other._oneofIndex {return false}
      if _jsonName != other._jsonName {return false}
      if _options != other._options {return false}
      if unknown != other.unknown {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone.unknown = unknown
      clone._name = _name
      clone._number = _number
      clone._label = _label
      clone._type = _type
      clone._typeName = _typeName
      clone._extendee = _extendee
      clone._defaultValue = _defaultValue
      clone._oneofIndex = _oneofIndex
      clone._jsonName = _jsonName
      clone._options = _options
      return clone
    }
  }

  private var _storage = _StorageClass()

  public var unknown: SwiftProtobuf.UnknownStorage {
    get {return _storage.unknown}
    set {_storage.unknown = newValue}
  }

  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int

    ///   0 is reserved for errors.
    ///   Order is weird for historical reasons.
    case double // = 1
    case float // = 2

    ///   Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if
    ///   negative values are likely.
    case int64 // = 3
    case uint64 // = 4

    ///   Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if
    ///   negative values are likely.
    case int32 // = 5
    case fixed64 // = 6
    case fixed32 // = 7
    case bool // = 8
    case string // = 9

    ///   Tag-delimited aggregate.
    ///   Group type is deprecated and not supported in proto3. However, Proto3
    ///   implementations should still be able to parse the group wire format and
    ///   treat group fields as unknown fields.
    case group // = 10

    ///   Length-delimited aggregate.
    case message // = 11

    ///   New in version 2.
    case bytes // = 12
    case uint32 // = 13
    case `enum` // = 14
    case sfixed32 // = 15
    case sfixed64 // = 16

    ///   Uses ZigZag encoding.
    case sint32 // = 17

    ///   Uses ZigZag encoding.
    case sint64 // = 18

    init() {
      self = .double
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .double
      case 2: self = .float
      case 3: self = .int64
      case 4: self = .uint64
      case 5: self = .int32
      case 6: self = .fixed64
      case 7: self = .fixed32
      case 8: self = .bool
      case 9: self = .string
      case 10: self = .group
      case 11: self = .message
      case 12: self = .bytes
      case 13: self = .uint32
      case 14: self = .`enum`
      case 15: self = .sfixed32
      case 16: self = .sfixed64
      case 17: self = .sint32
      case 18: self = .sint64
      default: return nil
      }
    }

    init?(name: String) {
      switch name {
      case "double": self = .double
      case "float": self = .float
      case "int64": self = .int64
      case "uint64": self = .uint64
      case "int32": self = .int32
      case "fixed64": self = .fixed64
      case "fixed32": self = .fixed32
      case "bool": self = .bool
      case "string": self = .string
      case "group": self = .group
      case "message": self = .message
      case "bytes": self = .bytes
      case "uint32": self = .uint32
      case "enum": self = .`enum`
      case "sfixed32": self = .sfixed32
      case "sfixed64": self = .sfixed64
      case "sint32": self = .sint32
      case "sint64": self = .sint64
      default: return nil
      }
    }

    init?(jsonName: String) {
      switch jsonName {
      case "TYPE_DOUBLE": self = .double
      case "TYPE_FLOAT": self = .float
      case "TYPE_INT64": self = .int64
      case "TYPE_UINT64": self = .uint64
      case "TYPE_INT32": self = .int32
      case "TYPE_FIXED64": self = .fixed64
      case "TYPE_FIXED32": self = .fixed32
      case "TYPE_BOOL": self = .bool
      case "TYPE_STRING": self = .string
      case "TYPE_GROUP": self = .group
      case "TYPE_MESSAGE": self = .message
      case "TYPE_BYTES": self = .bytes
      case "TYPE_UINT32": self = .uint32
      case "TYPE_ENUM": self = .`enum`
      case "TYPE_SFIXED32": self = .sfixed32
      case "TYPE_SFIXED64": self = .sfixed64
      case "TYPE_SINT32": self = .sint32
      case "TYPE_SINT64": self = .sint64
      default: return nil
      }
    }

    init?(protoName: String) {
      switch protoName {
      case "TYPE_DOUBLE": self = .double
      case "TYPE_FLOAT": self = .float
      case "TYPE_INT64": self = .int64
      case "TYPE_UINT64": self = .uint64
      case "TYPE_INT32": self = .int32
      case "TYPE_FIXED64": self = .fixed64
      case "TYPE_FIXED32": self = .fixed32
      case "TYPE_BOOL": self = .bool
      case "TYPE_STRING": self = .string
      case "TYPE_GROUP": self = .group
      case "TYPE_MESSAGE": self = .message
      case "TYPE_BYTES": self = .bytes
      case "TYPE_UINT32": self = .uint32
      case "TYPE_ENUM": self = .`enum`
      case "TYPE_SFIXED32": self = .sfixed32
      case "TYPE_SFIXED64": self = .sfixed64
      case "TYPE_SINT32": self = .sint32
      case "TYPE_SINT64": self = .sint64
      default: return nil
      }
    }

    var rawValue: Int {
      get {
        switch self {
        case .double: return 1
        case .float: return 2
        case .int64: return 3
        case .uint64: return 4
        case .int32: return 5
        case .fixed64: return 6
        case .fixed32: return 7
        case .bool: return 8
        case .string: return 9
        case .group: return 10
        case .message: return 11
        case .bytes: return 12
        case .uint32: return 13
        case .`enum`: return 14
        case .sfixed32: return 15
        case .sfixed64: return 16
        case .sint32: return 17
        case .sint64: return 18
        }
      }
    }

    var json: String {
      get {
        switch self {
        case .double: return "\"TYPE_DOUBLE\""
        case .float: return "\"TYPE_FLOAT\""
        case .int64: return "\"TYPE_INT64\""
        case .uint64: return "\"TYPE_UINT64\""
        case .int32: return "\"TYPE_INT32\""
        case .fixed64: return "\"TYPE_FIXED64\""
        case .fixed32: return "\"TYPE_FIXED32\""
        case .bool: return "\"TYPE_BOOL\""
        case .string: return "\"TYPE_STRING\""
        case .group: return "\"TYPE_GROUP\""
        case .message: return "\"TYPE_MESSAGE\""
        case .bytes: return "\"TYPE_BYTES\""
        case .uint32: return "\"TYPE_UINT32\""
        case .`enum`: return "\"TYPE_ENUM\""
        case .sfixed32: return "\"TYPE_SFIXED32\""
        case .sfixed64: return "\"TYPE_SFIXED64\""
        case .sint32: return "\"TYPE_SINT32\""
        case .sint64: return "\"TYPE_SINT64\""
        }
      }
    }

    var hashValue: Int { return rawValue }

    var debugDescription: String {
      get {
        switch self {
        case .double: return ".double"
        case .float: return ".float"
        case .int64: return ".int64"
        case .uint64: return ".uint64"
        case .int32: return ".int32"
        case .fixed64: return ".fixed64"
        case .fixed32: return ".fixed32"
        case .bool: return ".bool"
        case .string: return ".string"
        case .group: return ".group"
        case .message: return ".message"
        case .bytes: return ".bytes"
        case .uint32: return ".uint32"
        case .`enum`: return ".enum"
        case .sfixed32: return ".sfixed32"
        case .sfixed64: return ".sfixed64"
        case .sint32: return ".sint32"
        case .sint64: return ".sint64"
        }
      }
    }

  }

  enum Label: SwiftProtobuf.Enum {
    typealias RawValue = Int

    ///   0 is reserved for errors
    case `optional` // = 1
    case `required` // = 2
    case repeated // = 3

    init() {
      self = .`optional`
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .`optional`
      case 2: self = .`required`
      case 3: self = .repeated
      default: return nil
      }
    }

    init?(name: String) {
      switch name {
      case "optional": self = .`optional`
      case "required": self = .`required`
      case "repeated": self = .repeated
      default: return nil
      }
    }

    init?(jsonName: String) {
      switch jsonName {
      case "LABEL_OPTIONAL": self = .`optional`
      case "LABEL_REQUIRED": self = .`required`
      case "LABEL_REPEATED": self = .repeated
      default: return nil
      }
    }

    init?(protoName: String) {
      switch protoName {
      case "LABEL_OPTIONAL": self = .`optional`
      case "LABEL_REQUIRED": self = .`required`
      case "LABEL_REPEATED": self = .repeated
      default: return nil
      }
    }

    var rawValue: Int {
      get {
        switch self {
        case .`optional`: return 1
        case .`required`: return 2
        case .repeated: return 3
        }
      }
    }

    var json: String {
      get {
        switch self {
        case .`optional`: return "\"LABEL_OPTIONAL\""
        case .`required`: return "\"LABEL_REQUIRED\""
        case .repeated: return "\"LABEL_REPEATED\""
        }
      }
    }

    var hashValue: Int { return rawValue }

    var debugDescription: String {
      get {
        switch self {
        case .`optional`: return ".optional"
        case .`required`: return ".required"
        case .repeated: return ".repeated"
        }
      }
    }

  }

  var name: String {
    get {return _storage._name ?? ""}
    set {_uniqueStorage()._name = newValue}
  }
  public var hasName: Bool {
    return _storage._name != nil
  }
  public mutating func clearName() {
    return _storage._name = nil
  }

  var number: Int32 {
    get {return _storage._number ?? 0}
    set {_uniqueStorage()._number = newValue}
  }
  public var hasNumber: Bool {
    return _storage._number != nil
  }
  public mutating func clearNumber() {
    return _storage._number = nil
  }

  var label: Google_Protobuf_FieldDescriptorProto.Label {
    get {return _storage._label ?? Google_Protobuf_FieldDescriptorProto.Label.`optional`}
    set {_uniqueStorage()._label = newValue}
  }
  public var hasLabel: Bool {
    return _storage._label != nil
  }
  public mutating func clearLabel() {
    return _storage._label = nil
  }

  ///   If type_name is set, this need not be set.  If both this and type_name
  ///   are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.
  var type: Google_Protobuf_FieldDescriptorProto.TypeEnum {
    get {return _storage._type ?? Google_Protobuf_FieldDescriptorProto.TypeEnum.double}
    set {_uniqueStorage()._type = newValue}
  }
  public var hasType: Bool {
    return _storage._type != nil
  }
  public mutating func clearType() {
    return _storage._type = nil
  }

  ///   For message and enum types, this is the name of the type.  If the name
  ///   starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
  ///   rules are used to find the type (i.e. first the nested types within this
  ///   message are searched, then within the parent, on up to the root
  ///   namespace).
  var typeName: String {
    get {return _storage._typeName ?? ""}
    set {_uniqueStorage()._typeName = newValue}
  }
  public var hasTypeName: Bool {
    return _storage._typeName != nil
  }
  public mutating func clearTypeName() {
    return _storage._typeName = nil
  }

  ///   For extensions, this is the name of the type being extended.  It is
  ///   resolved in the same manner as type_name.
  var extendee: String {
    get {return _storage._extendee ?? ""}
    set {_uniqueStorage()._extendee = newValue}
  }
  public var hasExtendee: Bool {
    return _storage._extendee != nil
  }
  public mutating func clearExtendee() {
    return _storage._extendee = nil
  }

  ///   For numeric types, contains the original text representation of the value.
  ///   For booleans, "true" or "false".
  ///   For strings, contains the default text contents (not escaped in any way).
  ///   For bytes, contains the C escaped value.  All bytes >= 128 are escaped.
  ///   TODO(kenton):  Base-64 encode?
  var defaultValue: String {
    get {return _storage._defaultValue ?? ""}
    set {_uniqueStorage()._defaultValue = newValue}
  }
  public var hasDefaultValue: Bool {
    return _storage._defaultValue != nil
  }
  public mutating func clearDefaultValue() {
    return _storage._defaultValue = nil
  }

  ///   If set, gives the index of a oneof in the containing type's oneof_decl
  ///   list.  This field is a member of that oneof.
  var oneofIndex: Int32 {
    get {return _storage._oneofIndex ?? 0}
    set {_uniqueStorage()._oneofIndex = newValue}
  }
  public var hasOneofIndex: Bool {
    return _storage._oneofIndex != nil
  }
  public mutating func clearOneofIndex() {
    return _storage._oneofIndex = nil
  }

  ///   JSON name of this field. The value is set by protocol compiler. If the
  ///   user has set a "json_name" option on this field, that option's value
  ///   will be used. Otherwise, it's deduced from the field's name by converting
  ///   it to camelCase.
  var jsonName: String {
    get {return _storage._jsonName ?? ""}
    set {_uniqueStorage()._jsonName = newValue}
  }
  public var hasJsonName: Bool {
    return _storage._jsonName != nil
  }
  public mutating func clearJsonName() {
    return _storage._jsonName = nil
  }

  var options: Google_Protobuf_FieldOptions {
    get {return _storage._options ?? Google_Protobuf_FieldOptions()}
    set {_uniqueStorage()._options = newValue}
  }
  public var hasOptions: Bool {
    return _storage._options != nil
  }
  public mutating func clearOptions() {
    return _storage._options = nil
  }

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    try _storage.traverse(visitor: visitor)
  }

  public func _protoc_generated_isEqualTo(other: Google_Protobuf_FieldDescriptorProto) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

///   Describes a oneof.
struct Google_Protobuf_OneofDescriptorProto: SwiftProtobuf.Message, SwiftProtobuf.Proto2Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Google_Protobuf_OneofDescriptorProto"}
  public var protoMessageName: String {return "OneofDescriptorProto"}
  public var protoPackageName: String {return "google.protobuf"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "name", swift: "name"),
    2: .same(proto: "options", swift: "options"),
  ]

  private class _StorageClass {
    typealias ExtendedMessage = Google_Protobuf_OneofDescriptorProto
    var unknown = SwiftProtobuf.UnknownStorage()
    var _name: String? = nil
    var _options: Google_Protobuf_OneofOptions? = nil

    init() {}

    func decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
      switch protoFieldNumber {
      case 1: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: &_name)
      case 2: try setter.decodeSingularMessageField(fieldType: Google_Protobuf_OneofOptions.self, value: &_options)
      default: break
      }
    }

    func traverse(visitor: SwiftProtobuf.Visitor) throws {
      if let v = _name {
        try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: v, fieldNumber: 1)
      }
      if let v = _options {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      unknown.traverse(visitor: visitor)
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _name != other._name {return false}
      if _options != other._options {return false}
      if unknown != other.unknown {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone.unknown = unknown
      clone._name = _name
      clone._options = _options
      return clone
    }
  }

  private var _storage = _StorageClass()

  public var unknown: SwiftProtobuf.UnknownStorage {
    get {return _storage.unknown}
    set {_storage.unknown = newValue}
  }

  var name: String {
    get {return _storage._name ?? ""}
    set {_uniqueStorage()._name = newValue}
  }
  public var hasName: Bool {
    return _storage._name != nil
  }
  public mutating func clearName() {
    return _storage._name = nil
  }

  var options: Google_Protobuf_OneofOptions {
    get {return _storage._options ?? Google_Protobuf_OneofOptions()}
    set {_uniqueStorage()._options = newValue}
  }
  public var hasOptions: Bool {
    return _storage._options != nil
  }
  public mutating func clearOptions() {
    return _storage._options = nil
  }

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    try _storage.traverse(visitor: visitor)
  }

  public func _protoc_generated_isEqualTo(other: Google_Protobuf_OneofDescriptorProto) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

///   Describes an enum type.
struct Google_Protobuf_EnumDescriptorProto: SwiftProtobuf.Message, SwiftProtobuf.Proto2Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Google_Protobuf_EnumDescriptorProto"}
  public var protoMessageName: String {return "EnumDescriptorProto"}
  public var protoPackageName: String {return "google.protobuf"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "name", swift: "name"),
    2: .same(proto: "value", swift: "value"),
    3: .same(proto: "options", swift: "options"),
  ]

  private class _StorageClass {
    typealias ExtendedMessage = Google_Protobuf_EnumDescriptorProto
    var unknown = SwiftProtobuf.UnknownStorage()
    var _name: String? = nil
    var _value: [Google_Protobuf_EnumValueDescriptorProto] = []
    var _options: Google_Protobuf_EnumOptions? = nil

    init() {}

    func decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
      switch protoFieldNumber {
      case 1: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: &_name)
      case 2: try setter.decodeRepeatedMessageField(fieldType: Google_Protobuf_EnumValueDescriptorProto.self, value: &_value)
      case 3: try setter.decodeSingularMessageField(fieldType: Google_Protobuf_EnumOptions.self, value: &_options)
      default: break
      }
    }

    func traverse(visitor: SwiftProtobuf.Visitor) throws {
      if let v = _name {
        try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: v, fieldNumber: 1)
      }
      if !_value.isEmpty {
        try visitor.visitRepeatedMessageField(value: _value, fieldNumber: 2)
      }
      if let v = _options {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      unknown.traverse(visitor: visitor)
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _name != other._name {return false}
      if _value != other._value {return false}
      if _options != other._options {return false}
      if unknown != other.unknown {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone.unknown = unknown
      clone._name = _name
      clone._value = _value
      clone._options = _options
      return clone
    }
  }

  private var _storage = _StorageClass()

  public var unknown: SwiftProtobuf.UnknownStorage {
    get {return _storage.unknown}
    set {_storage.unknown = newValue}
  }

  var name: String {
    get {return _storage._name ?? ""}
    set {_uniqueStorage()._name = newValue}
  }
  public var hasName: Bool {
    return _storage._name != nil
  }
  public mutating func clearName() {
    return _storage._name = nil
  }

  var value: [Google_Protobuf_EnumValueDescriptorProto] {
    get {return _storage._value}
    set {_uniqueStorage()._value = newValue}
  }

  var options: Google_Protobuf_EnumOptions {
    get {return _storage._options ?? Google_Protobuf_EnumOptions()}
    set {_uniqueStorage()._options = newValue}
  }
  public var hasOptions: Bool {
    return _storage._options != nil
  }
  public mutating func clearOptions() {
    return _storage._options = nil
  }

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    try _storage.traverse(visitor: visitor)
  }

  public func _protoc_generated_isEqualTo(other: Google_Protobuf_EnumDescriptorProto) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

///   Describes a value within an enum.
struct Google_Protobuf_EnumValueDescriptorProto: SwiftProtobuf.Message, SwiftProtobuf.Proto2Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Google_Protobuf_EnumValueDescriptorProto"}
  public var protoMessageName: String {return "EnumValueDescriptorProto"}
  public var protoPackageName: String {return "google.protobuf"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "name", swift: "name"),
    2: .same(proto: "number", swift: "number"),
    3: .same(proto: "options", swift: "options"),
  ]

  private class _StorageClass {
    typealias ExtendedMessage = Google_Protobuf_EnumValueDescriptorProto
    var unknown = SwiftProtobuf.UnknownStorage()
    var _name: String? = nil
    var _number: Int32? = nil
    var _options: Google_Protobuf_EnumValueOptions? = nil

    init() {}

    func decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
      switch protoFieldNumber {
      case 1: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: &_name)
      case 2: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufInt32.self, value: &_number)
      case 3: try setter.decodeSingularMessageField(fieldType: Google_Protobuf_EnumValueOptions.self, value: &_options)
      default: break
      }
    }

    func traverse(visitor: SwiftProtobuf.Visitor) throws {
      if let v = _name {
        try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: v, fieldNumber: 1)
      }
      if let v = _number {
        try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufInt32.self, value: v, fieldNumber: 2)
      }
      if let v = _options {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      unknown.traverse(visitor: visitor)
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _name != other._name {return false}
      if _number != other._number {return false}
      if _options != other._options {return false}
      if unknown != other.unknown {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone.unknown = unknown
      clone._name = _name
      clone._number = _number
      clone._options = _options
      return clone
    }
  }

  private var _storage = _StorageClass()

  public var unknown: SwiftProtobuf.UnknownStorage {
    get {return _storage.unknown}
    set {_storage.unknown = newValue}
  }

  var name: String {
    get {return _storage._name ?? ""}
    set {_uniqueStorage()._name = newValue}
  }
  public var hasName: Bool {
    return _storage._name != nil
  }
  public mutating func clearName() {
    return _storage._name = nil
  }

  var number: Int32 {
    get {return _storage._number ?? 0}
    set {_uniqueStorage()._number = newValue}
  }
  public var hasNumber: Bool {
    return _storage._number != nil
  }
  public mutating func clearNumber() {
    return _storage._number = nil
  }

  var options: Google_Protobuf_EnumValueOptions {
    get {return _storage._options ?? Google_Protobuf_EnumValueOptions()}
    set {_uniqueStorage()._options = newValue}
  }
  public var hasOptions: Bool {
    return _storage._options != nil
  }
  public mutating func clearOptions() {
    return _storage._options = nil
  }

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    try _storage.traverse(visitor: visitor)
  }

  public func _protoc_generated_isEqualTo(other: Google_Protobuf_EnumValueDescriptorProto) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

///   Describes a service.
struct Google_Protobuf_ServiceDescriptorProto: SwiftProtobuf.Message, SwiftProtobuf.Proto2Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Google_Protobuf_ServiceDescriptorProto"}
  public var protoMessageName: String {return "ServiceDescriptorProto"}
  public var protoPackageName: String {return "google.protobuf"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "name", swift: "name"),
    2: .same(proto: "method", swift: "method"),
    3: .same(proto: "options", swift: "options"),
  ]

  private class _StorageClass {
    typealias ExtendedMessage = Google_Protobuf_ServiceDescriptorProto
    var unknown = SwiftProtobuf.UnknownStorage()
    var _name: String? = nil
    var _method: [Google_Protobuf_MethodDescriptorProto] = []
    var _options: Google_Protobuf_ServiceOptions? = nil

    init() {}

    func decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
      switch protoFieldNumber {
      case 1: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: &_name)
      case 2: try setter.decodeRepeatedMessageField(fieldType: Google_Protobuf_MethodDescriptorProto.self, value: &_method)
      case 3: try setter.decodeSingularMessageField(fieldType: Google_Protobuf_ServiceOptions.self, value: &_options)
      default: break
      }
    }

    func traverse(visitor: SwiftProtobuf.Visitor) throws {
      if let v = _name {
        try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: v, fieldNumber: 1)
      }
      if !_method.isEmpty {
        try visitor.visitRepeatedMessageField(value: _method, fieldNumber: 2)
      }
      if let v = _options {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      unknown.traverse(visitor: visitor)
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _name != other._name {return false}
      if _method != other._method {return false}
      if _options != other._options {return false}
      if unknown != other.unknown {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone.unknown = unknown
      clone._name = _name
      clone._method = _method
      clone._options = _options
      return clone
    }
  }

  private var _storage = _StorageClass()

  public var unknown: SwiftProtobuf.UnknownStorage {
    get {return _storage.unknown}
    set {_storage.unknown = newValue}
  }

  var name: String {
    get {return _storage._name ?? ""}
    set {_uniqueStorage()._name = newValue}
  }
  public var hasName: Bool {
    return _storage._name != nil
  }
  public mutating func clearName() {
    return _storage._name = nil
  }

  var method: [Google_Protobuf_MethodDescriptorProto] {
    get {return _storage._method}
    set {_uniqueStorage()._method = newValue}
  }

  var options: Google_Protobuf_ServiceOptions {
    get {return _storage._options ?? Google_Protobuf_ServiceOptions()}
    set {_uniqueStorage()._options = newValue}
  }
  public var hasOptions: Bool {
    return _storage._options != nil
  }
  public mutating func clearOptions() {
    return _storage._options = nil
  }

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    try _storage.traverse(visitor: visitor)
  }

  public func _protoc_generated_isEqualTo(other: Google_Protobuf_ServiceDescriptorProto) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

///   Describes a method of a service.
struct Google_Protobuf_MethodDescriptorProto: SwiftProtobuf.Message, SwiftProtobuf.Proto2Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Google_Protobuf_MethodDescriptorProto"}
  public var protoMessageName: String {return "MethodDescriptorProto"}
  public var protoPackageName: String {return "google.protobuf"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "name", swift: "name"),
    2: .unique(proto: "input_type", json: "inputType", swift: "inputType"),
    3: .unique(proto: "output_type", json: "outputType", swift: "outputType"),
    4: .same(proto: "options", swift: "options"),
    5: .unique(proto: "client_streaming", json: "clientStreaming", swift: "clientStreaming"),
    6: .unique(proto: "server_streaming", json: "serverStreaming", swift: "serverStreaming"),
  ]

  private class _StorageClass {
    typealias ExtendedMessage = Google_Protobuf_MethodDescriptorProto
    var unknown = SwiftProtobuf.UnknownStorage()
    var _name: String? = nil
    var _inputType: String? = nil
    var _outputType: String? = nil
    var _options: Google_Protobuf_MethodOptions? = nil
    var _clientStreaming: Bool? = nil
    var _serverStreaming: Bool? = nil

    init() {}

    func decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
      switch protoFieldNumber {
      case 1: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: &_name)
      case 2: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: &_inputType)
      case 3: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: &_outputType)
      case 4: try setter.decodeSingularMessageField(fieldType: Google_Protobuf_MethodOptions.self, value: &_options)
      case 5: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBool.self, value: &_clientStreaming)
      case 6: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBool.self, value: &_serverStreaming)
      default: break
      }
    }

    func traverse(visitor: SwiftProtobuf.Visitor) throws {
      if let v = _name {
        try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: v, fieldNumber: 1)
      }
      if let v = _inputType {
        try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: v, fieldNumber: 2)
      }
      if let v = _outputType {
        try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: v, fieldNumber: 3)
      }
      if let v = _options {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _clientStreaming {
        try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBool.self, value: v, fieldNumber: 5)
      }
      if let v = _serverStreaming {
        try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBool.self, value: v, fieldNumber: 6)
      }
      unknown.traverse(visitor: visitor)
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _name != other._name {return false}
      if _inputType != other._inputType {return false}
      if _outputType != other._outputType {return false}
      if _options != other._options {return false}
      if _clientStreaming != other._clientStreaming {return false}
      if _serverStreaming != other._serverStreaming {return false}
      if unknown != other.unknown {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone.unknown = unknown
      clone._name = _name
      clone._inputType = _inputType
      clone._outputType = _outputType
      clone._options = _options
      clone._clientStreaming = _clientStreaming
      clone._serverStreaming = _serverStreaming
      return clone
    }
  }

  private var _storage = _StorageClass()

  public var unknown: SwiftProtobuf.UnknownStorage {
    get {return _storage.unknown}
    set {_storage.unknown = newValue}
  }

  var name: String {
    get {return _storage._name ?? ""}
    set {_uniqueStorage()._name = newValue}
  }
  public var hasName: Bool {
    return _storage._name != nil
  }
  public mutating func clearName() {
    return _storage._name = nil
  }

  ///   Input and output type names.  These are resolved in the same way as
  ///   FieldDescriptorProto.type_name, but must refer to a message type.
  var inputType: String {
    get {return _storage._inputType ?? ""}
    set {_uniqueStorage()._inputType = newValue}
  }
  public var hasInputType: Bool {
    return _storage._inputType != nil
  }
  public mutating func clearInputType() {
    return _storage._inputType = nil
  }

  var outputType: String {
    get {return _storage._outputType ?? ""}
    set {_uniqueStorage()._outputType = newValue}
  }
  public var hasOutputType: Bool {
    return _storage._outputType != nil
  }
  public mutating func clearOutputType() {
    return _storage._outputType = nil
  }

  var options: Google_Protobuf_MethodOptions {
    get {return _storage._options ?? Google_Protobuf_MethodOptions()}
    set {_uniqueStorage()._options = newValue}
  }
  public var hasOptions: Bool {
    return _storage._options != nil
  }
  public mutating func clearOptions() {
    return _storage._options = nil
  }

  ///   Identifies if client streams multiple client messages
  var clientStreaming: Bool {
    get {return _storage._clientStreaming ?? false}
    set {_uniqueStorage()._clientStreaming = newValue}
  }
  public var hasClientStreaming: Bool {
    return _storage._clientStreaming != nil
  }
  public mutating func clearClientStreaming() {
    return _storage._clientStreaming = nil
  }

  ///   Identifies if server streams multiple server messages
  var serverStreaming: Bool {
    get {return _storage._serverStreaming ?? false}
    set {_uniqueStorage()._serverStreaming = newValue}
  }
  public var hasServerStreaming: Bool {
    return _storage._serverStreaming != nil
  }
  public mutating func clearServerStreaming() {
    return _storage._serverStreaming = nil
  }

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    try _storage.traverse(visitor: visitor)
  }

  public func _protoc_generated_isEqualTo(other: Google_Protobuf_MethodDescriptorProto) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

//  ===================================================================
//  Options

//  Each of the definitions above may have "options" attached.  These are
//  just annotations which may cause code to be generated slightly differently
//  or may contain hints for code that manipulates protocol messages.
// 
//  Clients may define custom options as extensions of the *Options messages.
//  These extensions may not yet be known at parsing time, so the parser cannot
//  store the values in them.  Instead it stores them in a field in the *Options
//  message called uninterpreted_option. This field must have the same name
//  across all *Options messages. We then use this field to populate the
//  extensions when we build a descriptor, at which point all protos have been
//  parsed and so all extensions are known.
// 
//  Extension numbers for custom options may be chosen as follows:
//  * For options which will only be used within a single application or
//    organization, or for experimental options, use field numbers 50000
//    through 99999.  It is up to you to ensure that you do not use the
//    same number for multiple options.
//  * For options which will be published and used publicly by multiple
//    independent entities, e-mail protobuf-global-extension-registry@google.com
//    to reserve extension numbers. Simply provide your project name (e.g.
//    Objective-C plugin) and your project website (if available) -- there's no
//    need to explain how you intend to use them. Usually you only need one
//    extension number. You can declare multiple options with only one extension
//    number by putting them in a sub-message. See the Custom Options section of
//    the docs for examples:
//    https://developers.google.com/protocol-buffers/docs/proto#options
//    If this turns out to be popular, a web service will be set up
//    to automatically assign option numbers.

struct Google_Protobuf_FileOptions: SwiftProtobuf.Message, SwiftProtobuf.Proto2Message, SwiftProtobuf.ExtensibleMessage, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Google_Protobuf_FileOptions"}
  public var protoMessageName: String {return "FileOptions"}
  public var protoPackageName: String {return "google.protobuf"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .unique(proto: "java_package", json: "javaPackage", swift: "javaPackage"),
    8: .unique(proto: "java_outer_classname", json: "javaOuterClassname", swift: "javaOuterClassname"),
    10: .unique(proto: "java_multiple_files", json: "javaMultipleFiles", swift: "javaMultipleFiles"),
    20: .unique(proto: "java_generate_equals_and_hash", json: "javaGenerateEqualsAndHash", swift: "javaGenerateEqualsAndHash"),
    27: .unique(proto: "java_string_check_utf8", json: "javaStringCheckUtf8", swift: "javaStringCheckUtf8"),
    9: .unique(proto: "optimize_for", json: "optimizeFor", swift: "optimizeFor"),
    11: .unique(proto: "go_package", json: "goPackage", swift: "goPackage"),
    16: .unique(proto: "cc_generic_services", json: "ccGenericServices", swift: "ccGenericServices"),
    17: .unique(proto: "java_generic_services", json: "javaGenericServices", swift: "javaGenericServices"),
    18: .unique(proto: "py_generic_services", json: "pyGenericServices", swift: "pyGenericServices"),
    23: .same(proto: "deprecated", swift: "deprecated"),
    31: .unique(proto: "cc_enable_arenas", json: "ccEnableArenas", swift: "ccEnableArenas"),
    36: .unique(proto: "objc_class_prefix", json: "objcClassPrefix", swift: "objcClassPrefix"),
    37: .unique(proto: "csharp_namespace", json: "csharpNamespace", swift: "csharpNamespace"),
    39: .unique(proto: "swift_prefix", json: "swiftPrefix", swift: "swiftPrefix"),
    999: .unique(proto: "uninterpreted_option", json: "uninterpretedOption", swift: "uninterpretedOption"),
  ]

  public var unknown = SwiftProtobuf.UnknownStorage()

  ///   Generated classes can be optimized for speed or code size.
  enum OptimizeMode: SwiftProtobuf.Enum {
    typealias RawValue = Int

    ///   Generate complete code for parsing, serialization,
    case speed // = 1

    ///   etc.
    case codeSize // = 2

    ///   Generate code using MessageLite and the lite runtime.
    case liteRuntime // = 3

    init() {
      self = .speed
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .speed
      case 2: self = .codeSize
      case 3: self = .liteRuntime
      default: return nil
      }
    }

    init?(name: String) {
      switch name {
      case "speed": self = .speed
      case "codeSize": self = .codeSize
      case "liteRuntime": self = .liteRuntime
      default: return nil
      }
    }

    init?(jsonName: String) {
      switch jsonName {
      case "SPEED": self = .speed
      case "CODE_SIZE": self = .codeSize
      case "LITE_RUNTIME": self = .liteRuntime
      default: return nil
      }
    }

    init?(protoName: String) {
      switch protoName {
      case "SPEED": self = .speed
      case "CODE_SIZE": self = .codeSize
      case "LITE_RUNTIME": self = .liteRuntime
      default: return nil
      }
    }

    var rawValue: Int {
      get {
        switch self {
        case .speed: return 1
        case .codeSize: return 2
        case .liteRuntime: return 3
        }
      }
    }

    var json: String {
      get {
        switch self {
        case .speed: return "\"SPEED\""
        case .codeSize: return "\"CODE_SIZE\""
        case .liteRuntime: return "\"LITE_RUNTIME\""
        }
      }
    }

    var hashValue: Int { return rawValue }

    var debugDescription: String {
      get {
        switch self {
        case .speed: return ".speed"
        case .codeSize: return ".codeSize"
        case .liteRuntime: return ".liteRuntime"
        }
      }
    }

  }

  ///   Sets the Java package where classes generated from this .proto will be
  ///   placed.  By default, the proto package is used, but this is often
  ///   inappropriate because proto packages do not normally start with backwards
  ///   domain names.
  private var _javaPackage: String? = nil
  var javaPackage: String {
    get {return _javaPackage ?? ""}
    set {_javaPackage = newValue}
  }
  public var hasJavaPackage: Bool {
    return _javaPackage != nil
  }
  public mutating func clearJavaPackage() {
    return _javaPackage = nil
  }

  ///   If set, all the classes from the .proto file are wrapped in a single
  ///   outer class with the given name.  This applies to both Proto1
  ///   (equivalent to the old "--one_java_file" option) and Proto2 (where
  ///   a .proto always translates to a single class, but you may want to
  ///   explicitly choose the class name).
  private var _javaOuterClassname: String? = nil
  var javaOuterClassname: String {
    get {return _javaOuterClassname ?? ""}
    set {_javaOuterClassname = newValue}
  }
  public var hasJavaOuterClassname: Bool {
    return _javaOuterClassname != nil
  }
  public mutating func clearJavaOuterClassname() {
    return _javaOuterClassname = nil
  }

  ///   If set true, then the Java code generator will generate a separate .java
  ///   file for each top-level message, enum, and service defined in the .proto
  ///   file.  Thus, these types will *not* be nested inside the outer class
  ///   named by java_outer_classname.  However, the outer class will still be
  ///   generated to contain the file's getDescriptor() method as well as any
  ///   top-level extensions defined in the file.
  private var _javaMultipleFiles: Bool? = nil
  var javaMultipleFiles: Bool {
    get {return _javaMultipleFiles ?? false}
    set {_javaMultipleFiles = newValue}
  }
  public var hasJavaMultipleFiles: Bool {
    return _javaMultipleFiles != nil
  }
  public mutating func clearJavaMultipleFiles() {
    return _javaMultipleFiles = nil
  }

  ///   This option does nothing.
  private var _javaGenerateEqualsAndHash: Bool? = nil
  var javaGenerateEqualsAndHash: Bool {
    get {return _javaGenerateEqualsAndHash ?? false}
    set {_javaGenerateEqualsAndHash = newValue}
  }
  public var hasJavaGenerateEqualsAndHash: Bool {
    return _javaGenerateEqualsAndHash != nil
  }
  public mutating func clearJavaGenerateEqualsAndHash() {
    return _javaGenerateEqualsAndHash = nil
  }

  ///   If set true, then the Java2 code generator will generate code that
  ///   throws an exception whenever an attempt is made to assign a non-UTF-8
  ///   byte sequence to a string field.
  ///   Message reflection will do the same.
  ///   However, an extension field still accepts non-UTF-8 byte sequences.
  ///   This option has no effect on when used with the lite runtime.
  private var _javaStringCheckUtf8: Bool? = nil
  var javaStringCheckUtf8: Bool {
    get {return _javaStringCheckUtf8 ?? false}
    set {_javaStringCheckUtf8 = newValue}
  }
  public var hasJavaStringCheckUtf8: Bool {
    return _javaStringCheckUtf8 != nil
  }
  public mutating func clearJavaStringCheckUtf8() {
    return _javaStringCheckUtf8 = nil
  }

  private var _optimizeFor: Google_Protobuf_FileOptions.OptimizeMode? = nil
  var optimizeFor: Google_Protobuf_FileOptions.OptimizeMode {
    get {return _optimizeFor ?? Google_Protobuf_FileOptions.OptimizeMode.speed}
    set {_optimizeFor = newValue}
  }
  public var hasOptimizeFor: Bool {
    return _optimizeFor != nil
  }
  public mutating func clearOptimizeFor() {
    return _optimizeFor = nil
  }

  ///   Sets the Go package where structs generated from this .proto will be
  ///   placed. If omitted, the Go package will be derived from the following:
  ///     - The basename of the package import path, if provided.
  ///     - Otherwise, the package statement in the .proto file, if present.
  ///     - Otherwise, the basename of the .proto file, without extension.
  private var _goPackage: String? = nil
  var goPackage: String {
    get {return _goPackage ?? ""}
    set {_goPackage = newValue}
  }
  public var hasGoPackage: Bool {
    return _goPackage != nil
  }
  public mutating func clearGoPackage() {
    return _goPackage = nil
  }

  ///   Should generic services be generated in each language?  "Generic" services
  ///   are not specific to any particular RPC system.  They are generated by the
  ///   main code generators in each language (without additional plugins).
  ///   Generic services were the only kind of service generation supported by
  ///   early versions of google.protobuf.
  ///  
  ///   Generic services are now considered deprecated in favor of using plugins
  ///   that generate code specific to your particular RPC system.  Therefore,
  ///   these default to false.  Old code which depends on generic services should
  ///   explicitly set them to true.
  private var _ccGenericServices: Bool? = nil
  var ccGenericServices: Bool {
    get {return _ccGenericServices ?? false}
    set {_ccGenericServices = newValue}
  }
  public var hasCcGenericServices: Bool {
    return _ccGenericServices != nil
  }
  public mutating func clearCcGenericServices() {
    return _ccGenericServices = nil
  }

  private var _javaGenericServices: Bool? = nil
  var javaGenericServices: Bool {
    get {return _javaGenericServices ?? false}
    set {_javaGenericServices = newValue}
  }
  public var hasJavaGenericServices: Bool {
    return _javaGenericServices != nil
  }
  public mutating func clearJavaGenericServices() {
    return _javaGenericServices = nil
  }

  private var _pyGenericServices: Bool? = nil
  var pyGenericServices: Bool {
    get {return _pyGenericServices ?? false}
    set {_pyGenericServices = newValue}
  }
  public var hasPyGenericServices: Bool {
    return _pyGenericServices != nil
  }
  public mutating func clearPyGenericServices() {
    return _pyGenericServices = nil
  }

  ///   Is this file deprecated?
  ///   Depending on the target platform, this can emit Deprecated annotations
  ///   for everything in the file, or it will be completely ignored; in the very
  ///   least, this is a formalization for deprecating files.
  private var _deprecated: Bool? = nil
  var deprecated: Bool {
    get {return _deprecated ?? false}
    set {_deprecated = newValue}
  }
  public var hasDeprecated: Bool {
    return _deprecated != nil
  }
  public mutating func clearDeprecated() {
    return _deprecated = nil
  }

  ///   Enables the use of arenas for the proto messages in this file. This applies
  ///   only to generated classes for C++.
  private var _ccEnableArenas: Bool? = nil
  var ccEnableArenas: Bool {
    get {return _ccEnableArenas ?? false}
    set {_ccEnableArenas = newValue}
  }
  public var hasCcEnableArenas: Bool {
    return _ccEnableArenas != nil
  }
  public mutating func clearCcEnableArenas() {
    return _ccEnableArenas = nil
  }

  ///   Sets the objective c class prefix which is prepended to all objective c
  ///   generated classes from this .proto. There is no default.
  private var _objcClassPrefix: String? = nil
  var objcClassPrefix: String {
    get {return _objcClassPrefix ?? ""}
    set {_objcClassPrefix = newValue}
  }
  public var hasObjcClassPrefix: Bool {
    return _objcClassPrefix != nil
  }
  public mutating func clearObjcClassPrefix() {
    return _objcClassPrefix = nil
  }

  ///   Namespace for generated classes; defaults to the package.
  private var _csharpNamespace: String? = nil
  var csharpNamespace: String {
    get {return _csharpNamespace ?? ""}
    set {_csharpNamespace = newValue}
  }
  public var hasCsharpNamespace: Bool {
    return _csharpNamespace != nil
  }
  public mutating func clearCsharpNamespace() {
    return _csharpNamespace = nil
  }

  ///   By default Swift generators will take the proto package and CamelCase it
  ///   replacing '.' with underscore and use that to prefix the types/symbols
  ///   defined. When this options is provided, they will use this value instead
  ///   to prefix the types/symbols defined.
  private var _swiftPrefix: String? = nil
  var swiftPrefix: String {
    get {return _swiftPrefix ?? ""}
    set {_swiftPrefix = newValue}
  }
  public var hasSwiftPrefix: Bool {
    return _swiftPrefix != nil
  }
  public mutating func clearSwiftPrefix() {
    return _swiftPrefix = nil
  }

  ///   The parser stores options it doesn't recognize here. See above.
  var uninterpretedOption: [Google_Protobuf_UninterpretedOption] = []

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    switch protoFieldNumber {
    case 1: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: &_javaPackage)
    case 8: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: &_javaOuterClassname)
    case 10: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBool.self, value: &_javaMultipleFiles)
    case 20: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBool.self, value: &_javaGenerateEqualsAndHash)
    case 27: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBool.self, value: &_javaStringCheckUtf8)
    case 9: try setter.decodeSingularField(fieldType: Google_Protobuf_FileOptions.OptimizeMode.self, value: &_optimizeFor)
    case 11: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: &_goPackage)
    case 16: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBool.self, value: &_ccGenericServices)
    case 17: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBool.self, value: &_javaGenericServices)
    case 18: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBool.self, value: &_pyGenericServices)
    case 23: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBool.self, value: &_deprecated)
    case 31: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBool.self, value: &_ccEnableArenas)
    case 36: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: &_objcClassPrefix)
    case 37: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: &_csharpNamespace)
    case 39: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: &_swiftPrefix)
    case 999: try setter.decodeRepeatedMessageField(fieldType: Google_Protobuf_UninterpretedOption.self, value: &uninterpretedOption)
    default: if (1000 <= protoFieldNumber && protoFieldNumber < 536870912) {
        try setter.decodeExtensionField(values: &extensionFieldValues, messageType: Google_Protobuf_FileOptions.self, protoFieldNumber: protoFieldNumber)
      }
    }
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    if let v = _javaPackage {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: v, fieldNumber: 1)
    }
    if let v = _javaOuterClassname {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: v, fieldNumber: 8)
    }
    if let v = _optimizeFor {
      try visitor.visitSingularField(fieldType: Google_Protobuf_FileOptions.OptimizeMode.self, value: v, fieldNumber: 9)
    }
    if let v = _javaMultipleFiles {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBool.self, value: v, fieldNumber: 10)
    }
    if let v = _goPackage {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: v, fieldNumber: 11)
    }
    if let v = _ccGenericServices {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBool.self, value: v, fieldNumber: 16)
    }
    if let v = _javaGenericServices {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBool.self, value: v, fieldNumber: 17)
    }
    if let v = _pyGenericServices {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBool.self, value: v, fieldNumber: 18)
    }
    if let v = _javaGenerateEqualsAndHash {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBool.self, value: v, fieldNumber: 20)
    }
    if let v = _deprecated {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBool.self, value: v, fieldNumber: 23)
    }
    if let v = _javaStringCheckUtf8 {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBool.self, value: v, fieldNumber: 27)
    }
    if let v = _ccEnableArenas {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBool.self, value: v, fieldNumber: 31)
    }
    if let v = _objcClassPrefix {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: v, fieldNumber: 36)
    }
    if let v = _csharpNamespace {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: v, fieldNumber: 37)
    }
    if let v = _swiftPrefix {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: v, fieldNumber: 39)
    }
    if !uninterpretedOption.isEmpty {
      try visitor.visitRepeatedMessageField(value: uninterpretedOption, fieldNumber: 999)
    }
    try extensionFieldValues.traverse(visitor: visitor, start: 1000, end: 536870912)
    unknown.traverse(visitor: visitor)
  }

  public func _protoc_generated_isEqualTo(other: Google_Protobuf_FileOptions) -> Bool {
    if _javaPackage != other._javaPackage {return false}
    if _javaOuterClassname != other._javaOuterClassname {return false}
    if _javaMultipleFiles != other._javaMultipleFiles {return false}
    if _javaGenerateEqualsAndHash != other._javaGenerateEqualsAndHash {return false}
    if _javaStringCheckUtf8 != other._javaStringCheckUtf8 {return false}
    if _optimizeFor != other._optimizeFor {return false}
    if _goPackage != other._goPackage {return false}
    if _ccGenericServices != other._ccGenericServices {return false}
    if _javaGenericServices != other._javaGenericServices {return false}
    if _pyGenericServices != other._pyGenericServices {return false}
    if _deprecated != other._deprecated {return false}
    if _ccEnableArenas != other._ccEnableArenas {return false}
    if _objcClassPrefix != other._objcClassPrefix {return false}
    if _csharpNamespace != other._csharpNamespace {return false}
    if _swiftPrefix != other._swiftPrefix {return false}
    if uninterpretedOption != other.uninterpretedOption {return false}
    if unknown != other.unknown {return false}
    if extensionFieldValues != other.extensionFieldValues {return false}
    return true
  }

  private var extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()

  public mutating func setExtensionValue<F: SwiftProtobuf.ExtensionField>(ext: SwiftProtobuf.MessageExtension<F, Google_Protobuf_FileOptions>, value: F.ValueType) {
    extensionFieldValues[ext.protoFieldNumber] = ext.set(value: value)
  }

  public mutating func clearExtensionValue<F: SwiftProtobuf.ExtensionField>(ext: SwiftProtobuf.MessageExtension<F, Google_Protobuf_FileOptions>) {
    extensionFieldValues[ext.protoFieldNumber] = nil
  }

  public func getExtensionValue<F: SwiftProtobuf.ExtensionField>(ext: SwiftProtobuf.MessageExtension<F, Google_Protobuf_FileOptions>) -> F.ValueType {
    if let fieldValue = extensionFieldValues[ext.protoFieldNumber] as? F {
      return fieldValue.value
    }
    return ext.defaultValue
  }

  public func hasExtensionValue<F: SwiftProtobuf.ExtensionField>(ext: SwiftProtobuf.MessageExtension<F, Google_Protobuf_FileOptions>) -> Bool {
    return extensionFieldValues[ext.protoFieldNumber] is F
  }
  public func _protobuf_fieldNames(for number: Int) -> FieldNameMap.Names? {
    return Google_Protobuf_FileOptions._protobuf_fieldNames.fieldNames(for: number) ?? extensionFieldValues.fieldNames(for: number)
  }
}

struct Google_Protobuf_MessageOptions: SwiftProtobuf.Message, SwiftProtobuf.Proto2Message, SwiftProtobuf.ExtensibleMessage, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Google_Protobuf_MessageOptions"}
  public var protoMessageName: String {return "MessageOptions"}
  public var protoPackageName: String {return "google.protobuf"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .unique(proto: "message_set_wire_format", json: "messageSetWireFormat", swift: "messageSetWireFormat"),
    2: .unique(proto: "no_standard_descriptor_accessor", json: "noStandardDescriptorAccessor", swift: "noStandardDescriptorAccessor"),
    3: .same(proto: "deprecated", swift: "deprecated"),
    7: .unique(proto: "map_entry", json: "mapEntry", swift: "mapEntry"),
    999: .unique(proto: "uninterpreted_option", json: "uninterpretedOption", swift: "uninterpretedOption"),
  ]

  public var unknown = SwiftProtobuf.UnknownStorage()

  ///   Set true to use the old proto1 MessageSet wire format for extensions.
  ///   This is provided for backwards-compatibility with the MessageSet wire
  ///   format.  You should not use this for any other reason:  It's less
  ///   efficient, has fewer features, and is more complicated.
  ///  
  ///   The message must be defined exactly as follows:
  ///     message Foo {
  ///       option message_set_wire_format = true;
  ///       extensions 4 to max;
  ///     }
  ///   Note that the message cannot have any defined fields; MessageSets only
  ///   have extensions.
  ///  
  ///   All extensions of your type must be singular messages; e.g. they cannot
  ///   be int32s, enums, or repeated messages.
  ///  
  ///   Because this is an option, the above two restrictions are not enforced by
  ///   the protocol compiler.
  private var _messageSetWireFormat: Bool? = nil
  var messageSetWireFormat: Bool {
    get {return _messageSetWireFormat ?? false}
    set {_messageSetWireFormat = newValue}
  }
  public var hasMessageSetWireFormat: Bool {
    return _messageSetWireFormat != nil
  }
  public mutating func clearMessageSetWireFormat() {
    return _messageSetWireFormat = nil
  }

  ///   Disables the generation of the standard "descriptor()" accessor, which can
  ///   conflict with a field of the same name.  This is meant to make migration
  ///   from proto1 easier; new code should avoid fields named "descriptor".
  private var _noStandardDescriptorAccessor: Bool? = nil
  var noStandardDescriptorAccessor: Bool {
    get {return _noStandardDescriptorAccessor ?? false}
    set {_noStandardDescriptorAccessor = newValue}
  }
  public var hasNoStandardDescriptorAccessor: Bool {
    return _noStandardDescriptorAccessor != nil
  }
  public mutating func clearNoStandardDescriptorAccessor() {
    return _noStandardDescriptorAccessor = nil
  }

  ///   Is this message deprecated?
  ///   Depending on the target platform, this can emit Deprecated annotations
  ///   for the message, or it will be completely ignored; in the very least,
  ///   this is a formalization for deprecating messages.
  private var _deprecated: Bool? = nil
  var deprecated: Bool {
    get {return _deprecated ?? false}
    set {_deprecated = newValue}
  }
  public var hasDeprecated: Bool {
    return _deprecated != nil
  }
  public mutating func clearDeprecated() {
    return _deprecated = nil
  }

  ///   Whether the message is an automatically generated map entry type for the
  ///   maps field.
  ///  
  ///   For maps fields:
  ///       map<KeyType, ValueType> map_field = 1;
  ///   The parsed descriptor looks like:
  ///       message MapFieldEntry {
  ///           option map_entry = true;
  ///           optional KeyType key = 1;
  ///           optional ValueType value = 2;
  ///       }
  ///       repeated MapFieldEntry map_field = 1;
  ///  
  ///   Implementations may choose not to generate the map_entry=true message, but
  ///   use a native map in the target language to hold the keys and values.
  ///   The reflection APIs in such implementions still need to work as
  ///   if the field is a repeated message field.
  ///  
  ///   NOTE: Do not set the option in .proto files. Always use the maps syntax
  ///   instead. The option should only be implicitly set by the proto compiler
  ///   parser.
  private var _mapEntry: Bool? = nil
  var mapEntry: Bool {
    get {return _mapEntry ?? false}
    set {_mapEntry = newValue}
  }
  public var hasMapEntry: Bool {
    return _mapEntry != nil
  }
  public mutating func clearMapEntry() {
    return _mapEntry = nil
  }

  ///   The parser stores options it doesn't recognize here. See above.
  var uninterpretedOption: [Google_Protobuf_UninterpretedOption] = []

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    switch protoFieldNumber {
    case 1: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBool.self, value: &_messageSetWireFormat)
    case 2: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBool.self, value: &_noStandardDescriptorAccessor)
    case 3: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBool.self, value: &_deprecated)
    case 7: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBool.self, value: &_mapEntry)
    case 999: try setter.decodeRepeatedMessageField(fieldType: Google_Protobuf_UninterpretedOption.self, value: &uninterpretedOption)
    default: if (1000 <= protoFieldNumber && protoFieldNumber < 536870912) {
        try setter.decodeExtensionField(values: &extensionFieldValues, messageType: Google_Protobuf_MessageOptions.self, protoFieldNumber: protoFieldNumber)
      }
    }
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    if let v = _messageSetWireFormat {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBool.self, value: v, fieldNumber: 1)
    }
    if let v = _noStandardDescriptorAccessor {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBool.self, value: v, fieldNumber: 2)
    }
    if let v = _deprecated {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBool.self, value: v, fieldNumber: 3)
    }
    if let v = _mapEntry {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBool.self, value: v, fieldNumber: 7)
    }
    if !uninterpretedOption.isEmpty {
      try visitor.visitRepeatedMessageField(value: uninterpretedOption, fieldNumber: 999)
    }
    try extensionFieldValues.traverse(visitor: visitor, start: 1000, end: 536870912)
    unknown.traverse(visitor: visitor)
  }

  public func _protoc_generated_isEqualTo(other: Google_Protobuf_MessageOptions) -> Bool {
    if _messageSetWireFormat != other._messageSetWireFormat {return false}
    if _noStandardDescriptorAccessor != other._noStandardDescriptorAccessor {return false}
    if _deprecated != other._deprecated {return false}
    if _mapEntry != other._mapEntry {return false}
    if uninterpretedOption != other.uninterpretedOption {return false}
    if unknown != other.unknown {return false}
    if extensionFieldValues != other.extensionFieldValues {return false}
    return true
  }

  private var extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()

  public mutating func setExtensionValue<F: SwiftProtobuf.ExtensionField>(ext: SwiftProtobuf.MessageExtension<F, Google_Protobuf_MessageOptions>, value: F.ValueType) {
    extensionFieldValues[ext.protoFieldNumber] = ext.set(value: value)
  }

  public mutating func clearExtensionValue<F: SwiftProtobuf.ExtensionField>(ext: SwiftProtobuf.MessageExtension<F, Google_Protobuf_MessageOptions>) {
    extensionFieldValues[ext.protoFieldNumber] = nil
  }

  public func getExtensionValue<F: SwiftProtobuf.ExtensionField>(ext: SwiftProtobuf.MessageExtension<F, Google_Protobuf_MessageOptions>) -> F.ValueType {
    if let fieldValue = extensionFieldValues[ext.protoFieldNumber] as? F {
      return fieldValue.value
    }
    return ext.defaultValue
  }

  public func hasExtensionValue<F: SwiftProtobuf.ExtensionField>(ext: SwiftProtobuf.MessageExtension<F, Google_Protobuf_MessageOptions>) -> Bool {
    return extensionFieldValues[ext.protoFieldNumber] is F
  }
  public func _protobuf_fieldNames(for number: Int) -> FieldNameMap.Names? {
    return Google_Protobuf_MessageOptions._protobuf_fieldNames.fieldNames(for: number) ?? extensionFieldValues.fieldNames(for: number)
  }
}

struct Google_Protobuf_FieldOptions: SwiftProtobuf.Message, SwiftProtobuf.Proto2Message, SwiftProtobuf.ExtensibleMessage, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Google_Protobuf_FieldOptions"}
  public var protoMessageName: String {return "FieldOptions"}
  public var protoPackageName: String {return "google.protobuf"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "ctype", swift: "ctype"),
    2: .same(proto: "packed", swift: "packed"),
    6: .same(proto: "jstype", swift: "jstype"),
    5: .same(proto: "lazy", swift: "lazy"),
    3: .same(proto: "deprecated", swift: "deprecated"),
    10: .same(proto: "weak", swift: "weak"),
    999: .unique(proto: "uninterpreted_option", json: "uninterpretedOption", swift: "uninterpretedOption"),
  ]

  public var unknown = SwiftProtobuf.UnknownStorage()

  enum CType: SwiftProtobuf.Enum {
    typealias RawValue = Int

    ///   Default mode.
    case string // = 0
    case cord // = 1
    case stringPiece // = 2

    init() {
      self = .string
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .string
      case 1: self = .cord
      case 2: self = .stringPiece
      default: return nil
      }
    }

    init?(name: String) {
      switch name {
      case "string": self = .string
      case "cord": self = .cord
      case "stringPiece": self = .stringPiece
      default: return nil
      }
    }

    init?(jsonName: String) {
      switch jsonName {
      case "STRING": self = .string
      case "CORD": self = .cord
      case "STRING_PIECE": self = .stringPiece
      default: return nil
      }
    }

    init?(protoName: String) {
      switch protoName {
      case "STRING": self = .string
      case "CORD": self = .cord
      case "STRING_PIECE": self = .stringPiece
      default: return nil
      }
    }

    var rawValue: Int {
      get {
        switch self {
        case .string: return 0
        case .cord: return 1
        case .stringPiece: return 2
        }
      }
    }

    var json: String {
      get {
        switch self {
        case .string: return "\"STRING\""
        case .cord: return "\"CORD\""
        case .stringPiece: return "\"STRING_PIECE\""
        }
      }
    }

    var hashValue: Int { return rawValue }

    var debugDescription: String {
      get {
        switch self {
        case .string: return ".string"
        case .cord: return ".cord"
        case .stringPiece: return ".stringPiece"
        }
      }
    }

  }

  enum JSType: SwiftProtobuf.Enum {
    typealias RawValue = Int

    ///   Use the default type.
    case jsNormal // = 0

    ///   Use JavaScript strings.
    case jsString // = 1

    ///   Use JavaScript numbers.
    case jsNumber // = 2

    init() {
      self = .jsNormal
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .jsNormal
      case 1: self = .jsString
      case 2: self = .jsNumber
      default: return nil
      }
    }

    init?(name: String) {
      switch name {
      case "jsNormal": self = .jsNormal
      case "jsString": self = .jsString
      case "jsNumber": self = .jsNumber
      default: return nil
      }
    }

    init?(jsonName: String) {
      switch jsonName {
      case "JS_NORMAL": self = .jsNormal
      case "JS_STRING": self = .jsString
      case "JS_NUMBER": self = .jsNumber
      default: return nil
      }
    }

    init?(protoName: String) {
      switch protoName {
      case "JS_NORMAL": self = .jsNormal
      case "JS_STRING": self = .jsString
      case "JS_NUMBER": self = .jsNumber
      default: return nil
      }
    }

    var rawValue: Int {
      get {
        switch self {
        case .jsNormal: return 0
        case .jsString: return 1
        case .jsNumber: return 2
        }
      }
    }

    var json: String {
      get {
        switch self {
        case .jsNormal: return "\"JS_NORMAL\""
        case .jsString: return "\"JS_STRING\""
        case .jsNumber: return "\"JS_NUMBER\""
        }
      }
    }

    var hashValue: Int { return rawValue }

    var debugDescription: String {
      get {
        switch self {
        case .jsNormal: return ".jsNormal"
        case .jsString: return ".jsString"
        case .jsNumber: return ".jsNumber"
        }
      }
    }

  }

  ///   The ctype option instructs the C++ code generator to use a different
  ///   representation of the field than it normally would.  See the specific
  ///   options below.  This option is not yet implemented in the open source
  ///   release -- sorry, we'll try to include it in a future version!
  private var _ctype: Google_Protobuf_FieldOptions.CType? = nil
  var ctype: Google_Protobuf_FieldOptions.CType {
    get {return _ctype ?? Google_Protobuf_FieldOptions.CType.string}
    set {_ctype = newValue}
  }
  public var hasCtype: Bool {
    return _ctype != nil
  }
  public mutating func clearCtype() {
    return _ctype = nil
  }

  ///   The packed option can be enabled for repeated primitive fields to enable
  ///   a more efficient representation on the wire. Rather than repeatedly
  ///   writing the tag and type for each element, the entire array is encoded as
  ///   a single length-delimited blob. In proto3, only explicit setting it to
  ///   false will avoid using packed encoding.
  private var _packed: Bool? = nil
  var packed: Bool {
    get {return _packed ?? false}
    set {_packed = newValue}
  }
  public var hasPacked: Bool {
    return _packed != nil
  }
  public mutating func clearPacked() {
    return _packed = nil
  }

  ///   The jstype option determines the JavaScript type used for values of the
  ///   field.  The option is permitted only for 64 bit integral and fixed types
  ///   (int64, uint64, sint64, fixed64, sfixed64).  By default these types are
  ///   represented as JavaScript strings.  This avoids loss of precision that can
  ///   happen when a large value is converted to a floating point JavaScript
  ///   numbers.  Specifying JS_NUMBER for the jstype causes the generated
  ///   JavaScript code to use the JavaScript "number" type instead of strings.
  ///   This option is an enum to permit additional types to be added,
  ///   e.g. goog.math.Integer.
  private var _jstype: Google_Protobuf_FieldOptions.JSType? = nil
  var jstype: Google_Protobuf_FieldOptions.JSType {
    get {return _jstype ?? Google_Protobuf_FieldOptions.JSType.jsNormal}
    set {_jstype = newValue}
  }
  public var hasJstype: Bool {
    return _jstype != nil
  }
  public mutating func clearJstype() {
    return _jstype = nil
  }

  ///   Should this field be parsed lazily?  Lazy applies only to message-type
  ///   fields.  It means that when the outer message is initially parsed, the
  ///   inner message's contents will not be parsed but instead stored in encoded
  ///   form.  The inner message will actually be parsed when it is first accessed.
  ///  
  ///   This is only a hint.  Implementations are free to choose whether to use
  ///   eager or lazy parsing regardless of the value of this option.  However,
  ///   setting this option true suggests that the protocol author believes that
  ///   using lazy parsing on this field is worth the additional bookkeeping
  ///   overhead typically needed to implement it.
  ///  
  ///   This option does not affect the public interface of any generated code;
  ///   all method signatures remain the same.  Furthermore, thread-safety of the
  ///   interface is not affected by this option; const methods remain safe to
  ///   call from multiple threads concurrently, while non-const methods continue
  ///   to require exclusive access.
  ///  
  ///  
  ///   Note that implementations may choose not to check required fields within
  ///   a lazy sub-message.  That is, calling IsInitialized() on the outer message
  ///   may return true even if the inner message has missing required fields.
  ///   This is necessary because otherwise the inner message would have to be
  ///   parsed in order to perform the check, defeating the purpose of lazy
  ///   parsing.  An implementation which chooses not to check required fields
  ///   must be consistent about it.  That is, for any particular sub-message, the
  ///   implementation must either *always* check its required fields, or *never*
  ///   check its required fields, regardless of whether or not the message has
  ///   been parsed.
  private var _lazy: Bool? = nil
  var lazy: Bool {
    get {return _lazy ?? false}
    set {_lazy = newValue}
  }
  public var hasLazy: Bool {
    return _lazy != nil
  }
  public mutating func clearLazy() {
    return _lazy = nil
  }

  ///   Is this field deprecated?
  ///   Depending on the target platform, this can emit Deprecated annotations
  ///   for accessors, or it will be completely ignored; in the very least, this
  ///   is a formalization for deprecating fields.
  private var _deprecated: Bool? = nil
  var deprecated: Bool {
    get {return _deprecated ?? false}
    set {_deprecated = newValue}
  }
  public var hasDeprecated: Bool {
    return _deprecated != nil
  }
  public mutating func clearDeprecated() {
    return _deprecated = nil
  }

  ///   For Google-internal migration only. Do not use.
  private var _weak: Bool? = nil
  var weak: Bool {
    get {return _weak ?? false}
    set {_weak = newValue}
  }
  public var hasWeak: Bool {
    return _weak != nil
  }
  public mutating func clearWeak() {
    return _weak = nil
  }

  ///   The parser stores options it doesn't recognize here. See above.
  var uninterpretedOption: [Google_Protobuf_UninterpretedOption] = []

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    switch protoFieldNumber {
    case 1: try setter.decodeSingularField(fieldType: Google_Protobuf_FieldOptions.CType.self, value: &_ctype)
    case 2: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBool.self, value: &_packed)
    case 6: try setter.decodeSingularField(fieldType: Google_Protobuf_FieldOptions.JSType.self, value: &_jstype)
    case 5: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBool.self, value: &_lazy)
    case 3: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBool.self, value: &_deprecated)
    case 10: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBool.self, value: &_weak)
    case 999: try setter.decodeRepeatedMessageField(fieldType: Google_Protobuf_UninterpretedOption.self, value: &uninterpretedOption)
    default: if (1000 <= protoFieldNumber && protoFieldNumber < 536870912) {
        try setter.decodeExtensionField(values: &extensionFieldValues, messageType: Google_Protobuf_FieldOptions.self, protoFieldNumber: protoFieldNumber)
      }
    }
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    if let v = _ctype {
      try visitor.visitSingularField(fieldType: Google_Protobuf_FieldOptions.CType.self, value: v, fieldNumber: 1)
    }
    if let v = _packed {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBool.self, value: v, fieldNumber: 2)
    }
    if let v = _deprecated {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBool.self, value: v, fieldNumber: 3)
    }
    if let v = _lazy {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBool.self, value: v, fieldNumber: 5)
    }
    if let v = _jstype {
      try visitor.visitSingularField(fieldType: Google_Protobuf_FieldOptions.JSType.self, value: v, fieldNumber: 6)
    }
    if let v = _weak {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBool.self, value: v, fieldNumber: 10)
    }
    if !uninterpretedOption.isEmpty {
      try visitor.visitRepeatedMessageField(value: uninterpretedOption, fieldNumber: 999)
    }
    try extensionFieldValues.traverse(visitor: visitor, start: 1000, end: 536870912)
    unknown.traverse(visitor: visitor)
  }

  public func _protoc_generated_isEqualTo(other: Google_Protobuf_FieldOptions) -> Bool {
    if _ctype != other._ctype {return false}
    if _packed != other._packed {return false}
    if _jstype != other._jstype {return false}
    if _lazy != other._lazy {return false}
    if _deprecated != other._deprecated {return false}
    if _weak != other._weak {return false}
    if uninterpretedOption != other.uninterpretedOption {return false}
    if unknown != other.unknown {return false}
    if extensionFieldValues != other.extensionFieldValues {return false}
    return true
  }

  private var extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()

  public mutating func setExtensionValue<F: SwiftProtobuf.ExtensionField>(ext: SwiftProtobuf.MessageExtension<F, Google_Protobuf_FieldOptions>, value: F.ValueType) {
    extensionFieldValues[ext.protoFieldNumber] = ext.set(value: value)
  }

  public mutating func clearExtensionValue<F: SwiftProtobuf.ExtensionField>(ext: SwiftProtobuf.MessageExtension<F, Google_Protobuf_FieldOptions>) {
    extensionFieldValues[ext.protoFieldNumber] = nil
  }

  public func getExtensionValue<F: SwiftProtobuf.ExtensionField>(ext: SwiftProtobuf.MessageExtension<F, Google_Protobuf_FieldOptions>) -> F.ValueType {
    if let fieldValue = extensionFieldValues[ext.protoFieldNumber] as? F {
      return fieldValue.value
    }
    return ext.defaultValue
  }

  public func hasExtensionValue<F: SwiftProtobuf.ExtensionField>(ext: SwiftProtobuf.MessageExtension<F, Google_Protobuf_FieldOptions>) -> Bool {
    return extensionFieldValues[ext.protoFieldNumber] is F
  }
  public func _protobuf_fieldNames(for number: Int) -> FieldNameMap.Names? {
    return Google_Protobuf_FieldOptions._protobuf_fieldNames.fieldNames(for: number) ?? extensionFieldValues.fieldNames(for: number)
  }
}

struct Google_Protobuf_OneofOptions: SwiftProtobuf.Message, SwiftProtobuf.Proto2Message, SwiftProtobuf.ExtensibleMessage, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Google_Protobuf_OneofOptions"}
  public var protoMessageName: String {return "OneofOptions"}
  public var protoPackageName: String {return "google.protobuf"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    999: .unique(proto: "uninterpreted_option", json: "uninterpretedOption", swift: "uninterpretedOption"),
  ]

  public var unknown = SwiftProtobuf.UnknownStorage()

  ///   The parser stores options it doesn't recognize here. See above.
  var uninterpretedOption: [Google_Protobuf_UninterpretedOption] = []

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    switch protoFieldNumber {
    case 999: try setter.decodeRepeatedMessageField(fieldType: Google_Protobuf_UninterpretedOption.self, value: &uninterpretedOption)
    default: if (1000 <= protoFieldNumber && protoFieldNumber < 536870912) {
        try setter.decodeExtensionField(values: &extensionFieldValues, messageType: Google_Protobuf_OneofOptions.self, protoFieldNumber: protoFieldNumber)
      }
    }
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    if !uninterpretedOption.isEmpty {
      try visitor.visitRepeatedMessageField(value: uninterpretedOption, fieldNumber: 999)
    }
    try extensionFieldValues.traverse(visitor: visitor, start: 1000, end: 536870912)
    unknown.traverse(visitor: visitor)
  }

  public func _protoc_generated_isEqualTo(other: Google_Protobuf_OneofOptions) -> Bool {
    if uninterpretedOption != other.uninterpretedOption {return false}
    if unknown != other.unknown {return false}
    if extensionFieldValues != other.extensionFieldValues {return false}
    return true
  }

  private var extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()

  public mutating func setExtensionValue<F: SwiftProtobuf.ExtensionField>(ext: SwiftProtobuf.MessageExtension<F, Google_Protobuf_OneofOptions>, value: F.ValueType) {
    extensionFieldValues[ext.protoFieldNumber] = ext.set(value: value)
  }

  public mutating func clearExtensionValue<F: SwiftProtobuf.ExtensionField>(ext: SwiftProtobuf.MessageExtension<F, Google_Protobuf_OneofOptions>) {
    extensionFieldValues[ext.protoFieldNumber] = nil
  }

  public func getExtensionValue<F: SwiftProtobuf.ExtensionField>(ext: SwiftProtobuf.MessageExtension<F, Google_Protobuf_OneofOptions>) -> F.ValueType {
    if let fieldValue = extensionFieldValues[ext.protoFieldNumber] as? F {
      return fieldValue.value
    }
    return ext.defaultValue
  }

  public func hasExtensionValue<F: SwiftProtobuf.ExtensionField>(ext: SwiftProtobuf.MessageExtension<F, Google_Protobuf_OneofOptions>) -> Bool {
    return extensionFieldValues[ext.protoFieldNumber] is F
  }
  public func _protobuf_fieldNames(for number: Int) -> FieldNameMap.Names? {
    return Google_Protobuf_OneofOptions._protobuf_fieldNames.fieldNames(for: number) ?? extensionFieldValues.fieldNames(for: number)
  }
}

struct Google_Protobuf_EnumOptions: SwiftProtobuf.Message, SwiftProtobuf.Proto2Message, SwiftProtobuf.ExtensibleMessage, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Google_Protobuf_EnumOptions"}
  public var protoMessageName: String {return "EnumOptions"}
  public var protoPackageName: String {return "google.protobuf"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    2: .unique(proto: "allow_alias", json: "allowAlias", swift: "allowAlias"),
    3: .same(proto: "deprecated", swift: "deprecated"),
    999: .unique(proto: "uninterpreted_option", json: "uninterpretedOption", swift: "uninterpretedOption"),
  ]

  public var unknown = SwiftProtobuf.UnknownStorage()

  ///   Set this option to true to allow mapping different tag names to the same
  ///   value.
  private var _allowAlias: Bool? = nil
  var allowAlias: Bool {
    get {return _allowAlias ?? false}
    set {_allowAlias = newValue}
  }
  public var hasAllowAlias: Bool {
    return _allowAlias != nil
  }
  public mutating func clearAllowAlias() {
    return _allowAlias = nil
  }

  ///   Is this enum deprecated?
  ///   Depending on the target platform, this can emit Deprecated annotations
  ///   for the enum, or it will be completely ignored; in the very least, this
  ///   is a formalization for deprecating enums.
  private var _deprecated: Bool? = nil
  var deprecated: Bool {
    get {return _deprecated ?? false}
    set {_deprecated = newValue}
  }
  public var hasDeprecated: Bool {
    return _deprecated != nil
  }
  public mutating func clearDeprecated() {
    return _deprecated = nil
  }

  ///   The parser stores options it doesn't recognize here. See above.
  var uninterpretedOption: [Google_Protobuf_UninterpretedOption] = []

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    switch protoFieldNumber {
    case 2: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBool.self, value: &_allowAlias)
    case 3: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBool.self, value: &_deprecated)
    case 999: try setter.decodeRepeatedMessageField(fieldType: Google_Protobuf_UninterpretedOption.self, value: &uninterpretedOption)
    default: if (1000 <= protoFieldNumber && protoFieldNumber < 536870912) {
        try setter.decodeExtensionField(values: &extensionFieldValues, messageType: Google_Protobuf_EnumOptions.self, protoFieldNumber: protoFieldNumber)
      }
    }
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    if let v = _allowAlias {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBool.self, value: v, fieldNumber: 2)
    }
    if let v = _deprecated {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBool.self, value: v, fieldNumber: 3)
    }
    if !uninterpretedOption.isEmpty {
      try visitor.visitRepeatedMessageField(value: uninterpretedOption, fieldNumber: 999)
    }
    try extensionFieldValues.traverse(visitor: visitor, start: 1000, end: 536870912)
    unknown.traverse(visitor: visitor)
  }

  public func _protoc_generated_isEqualTo(other: Google_Protobuf_EnumOptions) -> Bool {
    if _allowAlias != other._allowAlias {return false}
    if _deprecated != other._deprecated {return false}
    if uninterpretedOption != other.uninterpretedOption {return false}
    if unknown != other.unknown {return false}
    if extensionFieldValues != other.extensionFieldValues {return false}
    return true
  }

  private var extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()

  public mutating func setExtensionValue<F: SwiftProtobuf.ExtensionField>(ext: SwiftProtobuf.MessageExtension<F, Google_Protobuf_EnumOptions>, value: F.ValueType) {
    extensionFieldValues[ext.protoFieldNumber] = ext.set(value: value)
  }

  public mutating func clearExtensionValue<F: SwiftProtobuf.ExtensionField>(ext: SwiftProtobuf.MessageExtension<F, Google_Protobuf_EnumOptions>) {
    extensionFieldValues[ext.protoFieldNumber] = nil
  }

  public func getExtensionValue<F: SwiftProtobuf.ExtensionField>(ext: SwiftProtobuf.MessageExtension<F, Google_Protobuf_EnumOptions>) -> F.ValueType {
    if let fieldValue = extensionFieldValues[ext.protoFieldNumber] as? F {
      return fieldValue.value
    }
    return ext.defaultValue
  }

  public func hasExtensionValue<F: SwiftProtobuf.ExtensionField>(ext: SwiftProtobuf.MessageExtension<F, Google_Protobuf_EnumOptions>) -> Bool {
    return extensionFieldValues[ext.protoFieldNumber] is F
  }
  public func _protobuf_fieldNames(for number: Int) -> FieldNameMap.Names? {
    return Google_Protobuf_EnumOptions._protobuf_fieldNames.fieldNames(for: number) ?? extensionFieldValues.fieldNames(for: number)
  }
}

struct Google_Protobuf_EnumValueOptions: SwiftProtobuf.Message, SwiftProtobuf.Proto2Message, SwiftProtobuf.ExtensibleMessage, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Google_Protobuf_EnumValueOptions"}
  public var protoMessageName: String {return "EnumValueOptions"}
  public var protoPackageName: String {return "google.protobuf"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "deprecated", swift: "deprecated"),
    999: .unique(proto: "uninterpreted_option", json: "uninterpretedOption", swift: "uninterpretedOption"),
  ]

  public var unknown = SwiftProtobuf.UnknownStorage()

  ///   Is this enum value deprecated?
  ///   Depending on the target platform, this can emit Deprecated annotations
  ///   for the enum value, or it will be completely ignored; in the very least,
  ///   this is a formalization for deprecating enum values.
  private var _deprecated: Bool? = nil
  var deprecated: Bool {
    get {return _deprecated ?? false}
    set {_deprecated = newValue}
  }
  public var hasDeprecated: Bool {
    return _deprecated != nil
  }
  public mutating func clearDeprecated() {
    return _deprecated = nil
  }

  ///   The parser stores options it doesn't recognize here. See above.
  var uninterpretedOption: [Google_Protobuf_UninterpretedOption] = []

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    switch protoFieldNumber {
    case 1: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBool.self, value: &_deprecated)
    case 999: try setter.decodeRepeatedMessageField(fieldType: Google_Protobuf_UninterpretedOption.self, value: &uninterpretedOption)
    default: if (1000 <= protoFieldNumber && protoFieldNumber < 536870912) {
        try setter.decodeExtensionField(values: &extensionFieldValues, messageType: Google_Protobuf_EnumValueOptions.self, protoFieldNumber: protoFieldNumber)
      }
    }
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    if let v = _deprecated {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBool.self, value: v, fieldNumber: 1)
    }
    if !uninterpretedOption.isEmpty {
      try visitor.visitRepeatedMessageField(value: uninterpretedOption, fieldNumber: 999)
    }
    try extensionFieldValues.traverse(visitor: visitor, start: 1000, end: 536870912)
    unknown.traverse(visitor: visitor)
  }

  public func _protoc_generated_isEqualTo(other: Google_Protobuf_EnumValueOptions) -> Bool {
    if _deprecated != other._deprecated {return false}
    if uninterpretedOption != other.uninterpretedOption {return false}
    if unknown != other.unknown {return false}
    if extensionFieldValues != other.extensionFieldValues {return false}
    return true
  }

  private var extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()

  public mutating func setExtensionValue<F: SwiftProtobuf.ExtensionField>(ext: SwiftProtobuf.MessageExtension<F, Google_Protobuf_EnumValueOptions>, value: F.ValueType) {
    extensionFieldValues[ext.protoFieldNumber] = ext.set(value: value)
  }

  public mutating func clearExtensionValue<F: SwiftProtobuf.ExtensionField>(ext: SwiftProtobuf.MessageExtension<F, Google_Protobuf_EnumValueOptions>) {
    extensionFieldValues[ext.protoFieldNumber] = nil
  }

  public func getExtensionValue<F: SwiftProtobuf.ExtensionField>(ext: SwiftProtobuf.MessageExtension<F, Google_Protobuf_EnumValueOptions>) -> F.ValueType {
    if let fieldValue = extensionFieldValues[ext.protoFieldNumber] as? F {
      return fieldValue.value
    }
    return ext.defaultValue
  }

  public func hasExtensionValue<F: SwiftProtobuf.ExtensionField>(ext: SwiftProtobuf.MessageExtension<F, Google_Protobuf_EnumValueOptions>) -> Bool {
    return extensionFieldValues[ext.protoFieldNumber] is F
  }
  public func _protobuf_fieldNames(for number: Int) -> FieldNameMap.Names? {
    return Google_Protobuf_EnumValueOptions._protobuf_fieldNames.fieldNames(for: number) ?? extensionFieldValues.fieldNames(for: number)
  }
}

struct Google_Protobuf_ServiceOptions: SwiftProtobuf.Message, SwiftProtobuf.Proto2Message, SwiftProtobuf.ExtensibleMessage, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Google_Protobuf_ServiceOptions"}
  public var protoMessageName: String {return "ServiceOptions"}
  public var protoPackageName: String {return "google.protobuf"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    33: .same(proto: "deprecated", swift: "deprecated"),
    999: .unique(proto: "uninterpreted_option", json: "uninterpretedOption", swift: "uninterpretedOption"),
  ]

  public var unknown = SwiftProtobuf.UnknownStorage()

  //  Note:  Field numbers 1 through 32 are reserved for Google's internal RPC
  //    framework.  We apologize for hoarding these numbers to ourselves, but
  //    we were already using them long before we decided to release Protocol
  //    Buffers.

  ///   Is this service deprecated?
  ///   Depending on the target platform, this can emit Deprecated annotations
  ///   for the service, or it will be completely ignored; in the very least,
  ///   this is a formalization for deprecating services.
  private var _deprecated: Bool? = nil
  var deprecated: Bool {
    get {return _deprecated ?? false}
    set {_deprecated = newValue}
  }
  public var hasDeprecated: Bool {
    return _deprecated != nil
  }
  public mutating func clearDeprecated() {
    return _deprecated = nil
  }

  ///   The parser stores options it doesn't recognize here. See above.
  var uninterpretedOption: [Google_Protobuf_UninterpretedOption] = []

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    switch protoFieldNumber {
    case 33: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBool.self, value: &_deprecated)
    case 999: try setter.decodeRepeatedMessageField(fieldType: Google_Protobuf_UninterpretedOption.self, value: &uninterpretedOption)
    default: if (1000 <= protoFieldNumber && protoFieldNumber < 536870912) {
        try setter.decodeExtensionField(values: &extensionFieldValues, messageType: Google_Protobuf_ServiceOptions.self, protoFieldNumber: protoFieldNumber)
      }
    }
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    if let v = _deprecated {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBool.self, value: v, fieldNumber: 33)
    }
    if !uninterpretedOption.isEmpty {
      try visitor.visitRepeatedMessageField(value: uninterpretedOption, fieldNumber: 999)
    }
    try extensionFieldValues.traverse(visitor: visitor, start: 1000, end: 536870912)
    unknown.traverse(visitor: visitor)
  }

  public func _protoc_generated_isEqualTo(other: Google_Protobuf_ServiceOptions) -> Bool {
    if _deprecated != other._deprecated {return false}
    if uninterpretedOption != other.uninterpretedOption {return false}
    if unknown != other.unknown {return false}
    if extensionFieldValues != other.extensionFieldValues {return false}
    return true
  }

  private var extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()

  public mutating func setExtensionValue<F: SwiftProtobuf.ExtensionField>(ext: SwiftProtobuf.MessageExtension<F, Google_Protobuf_ServiceOptions>, value: F.ValueType) {
    extensionFieldValues[ext.protoFieldNumber] = ext.set(value: value)
  }

  public mutating func clearExtensionValue<F: SwiftProtobuf.ExtensionField>(ext: SwiftProtobuf.MessageExtension<F, Google_Protobuf_ServiceOptions>) {
    extensionFieldValues[ext.protoFieldNumber] = nil
  }

  public func getExtensionValue<F: SwiftProtobuf.ExtensionField>(ext: SwiftProtobuf.MessageExtension<F, Google_Protobuf_ServiceOptions>) -> F.ValueType {
    if let fieldValue = extensionFieldValues[ext.protoFieldNumber] as? F {
      return fieldValue.value
    }
    return ext.defaultValue
  }

  public func hasExtensionValue<F: SwiftProtobuf.ExtensionField>(ext: SwiftProtobuf.MessageExtension<F, Google_Protobuf_ServiceOptions>) -> Bool {
    return extensionFieldValues[ext.protoFieldNumber] is F
  }
  public func _protobuf_fieldNames(for number: Int) -> FieldNameMap.Names? {
    return Google_Protobuf_ServiceOptions._protobuf_fieldNames.fieldNames(for: number) ?? extensionFieldValues.fieldNames(for: number)
  }
}

struct Google_Protobuf_MethodOptions: SwiftProtobuf.Message, SwiftProtobuf.Proto2Message, SwiftProtobuf.ExtensibleMessage, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Google_Protobuf_MethodOptions"}
  public var protoMessageName: String {return "MethodOptions"}
  public var protoPackageName: String {return "google.protobuf"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    33: .same(proto: "deprecated", swift: "deprecated"),
    34: .unique(proto: "idempotency_level", json: "idempotencyLevel", swift: "idempotencyLevel"),
    999: .unique(proto: "uninterpreted_option", json: "uninterpretedOption", swift: "uninterpretedOption"),
  ]

  public var unknown = SwiftProtobuf.UnknownStorage()

  ///   Is this method side-effect-free (or safe in HTTP parlance), or idempotent,
  ///   or neither? HTTP based RPC implementation may choose GET verb for safe
  ///   methods, and PUT verb for idempotent methods instead of the default POST.
  enum IdempotencyLevel: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case idempotencyUnknown // = 0

    ///   implies idempotent
    case noSideEffects // = 1

    ///   idempotent, but may have side effects
    case idempotent // = 2

    init() {
      self = .idempotencyUnknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .idempotencyUnknown
      case 1: self = .noSideEffects
      case 2: self = .idempotent
      default: return nil
      }
    }

    init?(name: String) {
      switch name {
      case "idempotencyUnknown": self = .idempotencyUnknown
      case "noSideEffects": self = .noSideEffects
      case "idempotent": self = .idempotent
      default: return nil
      }
    }

    init?(jsonName: String) {
      switch jsonName {
      case "IDEMPOTENCY_UNKNOWN": self = .idempotencyUnknown
      case "NO_SIDE_EFFECTS": self = .noSideEffects
      case "IDEMPOTENT": self = .idempotent
      default: return nil
      }
    }

    init?(protoName: String) {
      switch protoName {
      case "IDEMPOTENCY_UNKNOWN": self = .idempotencyUnknown
      case "NO_SIDE_EFFECTS": self = .noSideEffects
      case "IDEMPOTENT": self = .idempotent
      default: return nil
      }
    }

    var rawValue: Int {
      get {
        switch self {
        case .idempotencyUnknown: return 0
        case .noSideEffects: return 1
        case .idempotent: return 2
        }
      }
    }

    var json: String {
      get {
        switch self {
        case .idempotencyUnknown: return "\"IDEMPOTENCY_UNKNOWN\""
        case .noSideEffects: return "\"NO_SIDE_EFFECTS\""
        case .idempotent: return "\"IDEMPOTENT\""
        }
      }
    }

    var hashValue: Int { return rawValue }

    var debugDescription: String {
      get {
        switch self {
        case .idempotencyUnknown: return ".idempotencyUnknown"
        case .noSideEffects: return ".noSideEffects"
        case .idempotent: return ".idempotent"
        }
      }
    }

  }

  //  Note:  Field numbers 1 through 32 are reserved for Google's internal RPC
  //    framework.  We apologize for hoarding these numbers to ourselves, but
  //    we were already using them long before we decided to release Protocol
  //    Buffers.

  ///   Is this method deprecated?
  ///   Depending on the target platform, this can emit Deprecated annotations
  ///   for the method, or it will be completely ignored; in the very least,
  ///   this is a formalization for deprecating methods.
  private var _deprecated: Bool? = nil
  var deprecated: Bool {
    get {return _deprecated ?? false}
    set {_deprecated = newValue}
  }
  public var hasDeprecated: Bool {
    return _deprecated != nil
  }
  public mutating func clearDeprecated() {
    return _deprecated = nil
  }

  private var _idempotencyLevel: Google_Protobuf_MethodOptions.IdempotencyLevel? = nil
  var idempotencyLevel: Google_Protobuf_MethodOptions.IdempotencyLevel {
    get {return _idempotencyLevel ?? Google_Protobuf_MethodOptions.IdempotencyLevel.idempotencyUnknown}
    set {_idempotencyLevel = newValue}
  }
  public var hasIdempotencyLevel: Bool {
    return _idempotencyLevel != nil
  }
  public mutating func clearIdempotencyLevel() {
    return _idempotencyLevel = nil
  }

  ///   The parser stores options it doesn't recognize here. See above.
  var uninterpretedOption: [Google_Protobuf_UninterpretedOption] = []

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    switch protoFieldNumber {
    case 33: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBool.self, value: &_deprecated)
    case 34: try setter.decodeSingularField(fieldType: Google_Protobuf_MethodOptions.IdempotencyLevel.self, value: &_idempotencyLevel)
    case 999: try setter.decodeRepeatedMessageField(fieldType: Google_Protobuf_UninterpretedOption.self, value: &uninterpretedOption)
    default: if (1000 <= protoFieldNumber && protoFieldNumber < 536870912) {
        try setter.decodeExtensionField(values: &extensionFieldValues, messageType: Google_Protobuf_MethodOptions.self, protoFieldNumber: protoFieldNumber)
      }
    }
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    if let v = _deprecated {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBool.self, value: v, fieldNumber: 33)
    }
    if let v = _idempotencyLevel {
      try visitor.visitSingularField(fieldType: Google_Protobuf_MethodOptions.IdempotencyLevel.self, value: v, fieldNumber: 34)
    }
    if !uninterpretedOption.isEmpty {
      try visitor.visitRepeatedMessageField(value: uninterpretedOption, fieldNumber: 999)
    }
    try extensionFieldValues.traverse(visitor: visitor, start: 1000, end: 536870912)
    unknown.traverse(visitor: visitor)
  }

  public func _protoc_generated_isEqualTo(other: Google_Protobuf_MethodOptions) -> Bool {
    if _deprecated != other._deprecated {return false}
    if _idempotencyLevel != other._idempotencyLevel {return false}
    if uninterpretedOption != other.uninterpretedOption {return false}
    if unknown != other.unknown {return false}
    if extensionFieldValues != other.extensionFieldValues {return false}
    return true
  }

  private var extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()

  public mutating func setExtensionValue<F: SwiftProtobuf.ExtensionField>(ext: SwiftProtobuf.MessageExtension<F, Google_Protobuf_MethodOptions>, value: F.ValueType) {
    extensionFieldValues[ext.protoFieldNumber] = ext.set(value: value)
  }

  public mutating func clearExtensionValue<F: SwiftProtobuf.ExtensionField>(ext: SwiftProtobuf.MessageExtension<F, Google_Protobuf_MethodOptions>) {
    extensionFieldValues[ext.protoFieldNumber] = nil
  }

  public func getExtensionValue<F: SwiftProtobuf.ExtensionField>(ext: SwiftProtobuf.MessageExtension<F, Google_Protobuf_MethodOptions>) -> F.ValueType {
    if let fieldValue = extensionFieldValues[ext.protoFieldNumber] as? F {
      return fieldValue.value
    }
    return ext.defaultValue
  }

  public func hasExtensionValue<F: SwiftProtobuf.ExtensionField>(ext: SwiftProtobuf.MessageExtension<F, Google_Protobuf_MethodOptions>) -> Bool {
    return extensionFieldValues[ext.protoFieldNumber] is F
  }
  public func _protobuf_fieldNames(for number: Int) -> FieldNameMap.Names? {
    return Google_Protobuf_MethodOptions._protobuf_fieldNames.fieldNames(for: number) ?? extensionFieldValues.fieldNames(for: number)
  }
}

///   A message representing a option the parser does not recognize. This only
///   appears in options protos created by the compiler::Parser class.
///   DescriptorPool resolves these when building Descriptor objects. Therefore,
///   options protos in descriptor objects (e.g. returned by Descriptor::options(),
///   or produced by Descriptor::CopyTo()) will never have UninterpretedOptions
///   in them.
struct Google_Protobuf_UninterpretedOption: SwiftProtobuf.Message, SwiftProtobuf.Proto2Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Google_Protobuf_UninterpretedOption"}
  public var protoMessageName: String {return "UninterpretedOption"}
  public var protoPackageName: String {return "google.protobuf"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    2: .same(proto: "name", swift: "name"),
    3: .unique(proto: "identifier_value", json: "identifierValue", swift: "identifierValue"),
    4: .unique(proto: "positive_int_value", json: "positiveIntValue", swift: "positiveIntValue"),
    5: .unique(proto: "negative_int_value", json: "negativeIntValue", swift: "negativeIntValue"),
    6: .unique(proto: "double_value", json: "doubleValue", swift: "doubleValue"),
    7: .unique(proto: "string_value", json: "stringValue", swift: "stringValue"),
    8: .unique(proto: "aggregate_value", json: "aggregateValue", swift: "aggregateValue"),
  ]

  public var unknown = SwiftProtobuf.UnknownStorage()

  ///   The name of the uninterpreted option.  Each string represents a segment in
  ///   a dot-separated name.  is_extension is true iff a segment represents an
  ///   extension (denoted with parentheses in options specs in .proto files).
  ///   E.g.,{ ["foo", false], ["bar.baz", true], ["qux", false] } represents
  ///   "foo.(bar.baz).qux".
  struct NamePart: SwiftProtobuf.Message, SwiftProtobuf.Proto2Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
    public var swiftClassName: String {return "Google_Protobuf_UninterpretedOption.NamePart"}
    public var protoMessageName: String {return "NamePart"}
    public var protoPackageName: String {return "google.protobuf"}
    public static let _protobuf_fieldNames: FieldNameMap = [
      1: .unique(proto: "name_part", json: "namePart", swift: "namePart"),
      2: .unique(proto: "is_extension", json: "isExtension", swift: "isExtension"),
    ]

    public var unknown = SwiftProtobuf.UnknownStorage()

    private var _namePart: String? = nil
    var namePart: String {
      get {return _namePart ?? ""}
      set {_namePart = newValue}
    }
    public var hasNamePart: Bool {
      return _namePart != nil
    }
    public mutating func clearNamePart() {
      return _namePart = nil
    }

    private var _isExtension: Bool? = nil
    var isExtension: Bool {
      get {return _isExtension ?? false}
      set {_isExtension = newValue}
    }
    public var hasIsExtension: Bool {
      return _isExtension != nil
    }
    public mutating func clearIsExtension() {
      return _isExtension = nil
    }

    init() {}

    public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
      switch protoFieldNumber {
      case 1: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: &_namePart)
      case 2: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBool.self, value: &_isExtension)
      default: break
      }
    }

    public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: _namePart ?? "", fieldNumber: 1)
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBool.self, value: _isExtension ?? false, fieldNumber: 2)
      unknown.traverse(visitor: visitor)
    }

    public func _protoc_generated_isEqualTo(other: Google_Protobuf_UninterpretedOption.NamePart) -> Bool {
      if _namePart != other._namePart {return false}
      if _isExtension != other._isExtension {return false}
      if unknown != other.unknown {return false}
      return true
    }
  }

  var name: [Google_Protobuf_UninterpretedOption.NamePart] = []

  ///   The value of the uninterpreted option, in whatever type the tokenizer
  ///   identified it as during parsing. Exactly one of these should be set.
  private var _identifierValue: String? = nil
  var identifierValue: String {
    get {return _identifierValue ?? ""}
    set {_identifierValue = newValue}
  }
  public var hasIdentifierValue: Bool {
    return _identifierValue != nil
  }
  public mutating func clearIdentifierValue() {
    return _identifierValue = nil
  }

  private var _positiveIntValue: UInt64? = nil
  var positiveIntValue: UInt64 {
    get {return _positiveIntValue ?? 0}
    set {_positiveIntValue = newValue}
  }
  public var hasPositiveIntValue: Bool {
    return _positiveIntValue != nil
  }
  public mutating func clearPositiveIntValue() {
    return _positiveIntValue = nil
  }

  private var _negativeIntValue: Int64? = nil
  var negativeIntValue: Int64 {
    get {return _negativeIntValue ?? 0}
    set {_negativeIntValue = newValue}
  }
  public var hasNegativeIntValue: Bool {
    return _negativeIntValue != nil
  }
  public mutating func clearNegativeIntValue() {
    return _negativeIntValue = nil
  }

  private var _doubleValue: Double? = nil
  var doubleValue: Double {
    get {return _doubleValue ?? 0}
    set {_doubleValue = newValue}
  }
  public var hasDoubleValue: Bool {
    return _doubleValue != nil
  }
  public mutating func clearDoubleValue() {
    return _doubleValue = nil
  }

  private var _stringValue: Data? = nil
  var stringValue: Data {
    get {return _stringValue ?? Data()}
    set {_stringValue = newValue}
  }
  public var hasStringValue: Bool {
    return _stringValue != nil
  }
  public mutating func clearStringValue() {
    return _stringValue = nil
  }

  private var _aggregateValue: String? = nil
  var aggregateValue: String {
    get {return _aggregateValue ?? ""}
    set {_aggregateValue = newValue}
  }
  public var hasAggregateValue: Bool {
    return _aggregateValue != nil
  }
  public mutating func clearAggregateValue() {
    return _aggregateValue = nil
  }

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    switch protoFieldNumber {
    case 2: try setter.decodeRepeatedMessageField(fieldType: Google_Protobuf_UninterpretedOption.NamePart.self, value: &name)
    case 3: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: &_identifierValue)
    case 4: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufUInt64.self, value: &_positiveIntValue)
    case 5: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufInt64.self, value: &_negativeIntValue)
    case 6: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufDouble.self, value: &_doubleValue)
    case 7: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: &_stringValue)
    case 8: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: &_aggregateValue)
    default: break
    }
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    if !name.isEmpty {
      try visitor.visitRepeatedMessageField(value: name, fieldNumber: 2)
    }
    if let v = _identifierValue {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: v, fieldNumber: 3)
    }
    if let v = _positiveIntValue {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufUInt64.self, value: v, fieldNumber: 4)
    }
    if let v = _negativeIntValue {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufInt64.self, value: v, fieldNumber: 5)
    }
    if let v = _doubleValue {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufDouble.self, value: v, fieldNumber: 6)
    }
    if let v = _stringValue {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: v, fieldNumber: 7)
    }
    if let v = _aggregateValue {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: v, fieldNumber: 8)
    }
    unknown.traverse(visitor: visitor)
  }

  public func _protoc_generated_isEqualTo(other: Google_Protobuf_UninterpretedOption) -> Bool {
    if name != other.name {return false}
    if _identifierValue != other._identifierValue {return false}
    if _positiveIntValue != other._positiveIntValue {return false}
    if _negativeIntValue != other._negativeIntValue {return false}
    if _doubleValue != other._doubleValue {return false}
    if _stringValue != other._stringValue {return false}
    if _aggregateValue != other._aggregateValue {return false}
    if unknown != other.unknown {return false}
    return true
  }
}

//  ===================================================================
//  Optional source code info

///   Encapsulates information about the original source file from which a
///   FileDescriptorProto was generated.
struct Google_Protobuf_SourceCodeInfo: SwiftProtobuf.Message, SwiftProtobuf.Proto2Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Google_Protobuf_SourceCodeInfo"}
  public var protoMessageName: String {return "SourceCodeInfo"}
  public var protoPackageName: String {return "google.protobuf"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "location", swift: "location"),
  ]

  public var unknown = SwiftProtobuf.UnknownStorage()

  struct Location: SwiftProtobuf.Message, SwiftProtobuf.Proto2Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
    public var swiftClassName: String {return "Google_Protobuf_SourceCodeInfo.Location"}
    public var protoMessageName: String {return "Location"}
    public var protoPackageName: String {return "google.protobuf"}
    public static let _protobuf_fieldNames: FieldNameMap = [
      1: .same(proto: "path", swift: "path"),
      2: .same(proto: "span", swift: "span"),
      3: .unique(proto: "leading_comments", json: "leadingComments", swift: "leadingComments"),
      4: .unique(proto: "trailing_comments", json: "trailingComments", swift: "trailingComments"),
      6: .unique(proto: "leading_detached_comments", json: "leadingDetachedComments", swift: "leadingDetachedComments"),
    ]

    public var unknown = SwiftProtobuf.UnknownStorage()

    ///   Identifies which part of the FileDescriptorProto was defined at this
    ///   location.
    ///  
    ///   Each element is a field number or an index.  They form a path from
    ///   the root FileDescriptorProto to the place where the definition.  For
    ///   example, this path:
    ///     [ 4, 3, 2, 7, 1 ]
    ///   refers to:
    ///     file.message_type(3)  // 4, 3
    ///         .field(7)         // 2, 7
    ///         .name()           // 1
    ///   This is because FileDescriptorProto.message_type has field number 4:
    ///     repeated DescriptorProto message_type = 4;
    ///   and DescriptorProto.field has field number 2:
    ///     repeated FieldDescriptorProto field = 2;
    ///   and FieldDescriptorProto.name has field number 1:
    ///     optional string name = 1;
    ///  
    ///   Thus, the above path gives the location of a field name.  If we removed
    ///   the last element:
    ///     [ 4, 3, 2, 7 ]
    ///   this path refers to the whole field declaration (from the beginning
    ///   of the label to the terminating semicolon).
    var path: [Int32] = []

    ///   Always has exactly three or four elements: start line, start column,
    ///   end line (optional, otherwise assumed same as start line), end column.
    ///   These are packed into a single field for efficiency.  Note that line
    ///   and column numbers are zero-based -- typically you will want to add
    ///   1 to each before displaying to a user.
    var span: [Int32] = []

    ///   If this SourceCodeInfo represents a complete declaration, these are any
    ///   comments appearing before and after the declaration which appear to be
    ///   attached to the declaration.
    ///  
    ///   A series of line comments appearing on consecutive lines, with no other
    ///   tokens appearing on those lines, will be treated as a single comment.
    ///  
    ///   leading_detached_comments will keep paragraphs of comments that appear
    ///   before (but not connected to) the current element. Each paragraph,
    ///   separated by empty lines, will be one comment element in the repeated
    ///   field.
    ///  
    ///   Only the comment content is provided; comment markers (e.g. //) are
    ///   stripped out.  For block comments, leading whitespace and an asterisk
    ///   will be stripped from the beginning of each line other than the first.
    ///   Newlines are included in the output.
    ///  
    ///   Examples:
    ///  
    ///     optional int32 foo = 1;  // Comment attached to foo.
    ///     // Comment attached to bar.
    ///     optional int32 bar = 2;
    ///  
    ///     optional string baz = 3;
    ///     // Comment attached to baz.
    ///     // Another line attached to baz.
    ///  
    ///     // Comment attached to qux.
    ///     //
    ///     // Another line attached to qux.
    ///     optional double qux = 4;
    ///  
    ///     // Detached comment for corge. This is not leading or trailing comments
    ///     // to qux or corge because there are blank lines separating it from
    ///     // both.
    ///  
    ///     // Detached comment for corge paragraph 2.
    ///  
    ///     optional string corge = 5;
    ///     /* Block comment attached
    ///      * to corge.  Leading asterisks
    ///      * will be removed. */
    ///     /* Block comment attached to
    ///      * grault. */
    ///     optional int32 grault = 6;
    ///  
    ///     // ignored detached comments.
    private var _leadingComments: String? = nil
    var leadingComments: String {
      get {return _leadingComments ?? ""}
      set {_leadingComments = newValue}
    }
    public var hasLeadingComments: Bool {
      return _leadingComments != nil
    }
    public mutating func clearLeadingComments() {
      return _leadingComments = nil
    }

    private var _trailingComments: String? = nil
    var trailingComments: String {
      get {return _trailingComments ?? ""}
      set {_trailingComments = newValue}
    }
    public var hasTrailingComments: Bool {
      return _trailingComments != nil
    }
    public mutating func clearTrailingComments() {
      return _trailingComments = nil
    }

    var leadingDetachedComments: [String] = []

    init() {}

    public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
      switch protoFieldNumber {
      case 1: try setter.decodeRepeatedField(fieldType: SwiftProtobuf.ProtobufInt32.self, value: &path)
      case 2: try setter.decodeRepeatedField(fieldType: SwiftProtobuf.ProtobufInt32.self, value: &span)
      case 3: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: &_leadingComments)
      case 4: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: &_trailingComments)
      case 6: try setter.decodeRepeatedField(fieldType: SwiftProtobuf.ProtobufString.self, value: &leadingDetachedComments)
      default: break
      }
    }

    public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
      if !path.isEmpty {
        try visitor.visitPackedField(fieldType: SwiftProtobuf.ProtobufInt32.self, value: path, fieldNumber: 1)
      }
      if !span.isEmpty {
        try visitor.visitPackedField(fieldType: SwiftProtobuf.ProtobufInt32.self, value: span, fieldNumber: 2)
      }
      if let v = _leadingComments {
        try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: v, fieldNumber: 3)
      }
      if let v = _trailingComments {
        try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: v, fieldNumber: 4)
      }
      if !leadingDetachedComments.isEmpty {
        try visitor.visitRepeatedField(fieldType: SwiftProtobuf.ProtobufString.self, value: leadingDetachedComments, fieldNumber: 6)
      }
      unknown.traverse(visitor: visitor)
    }

    public func _protoc_generated_isEqualTo(other: Google_Protobuf_SourceCodeInfo.Location) -> Bool {
      if path != other.path {return false}
      if span != other.span {return false}
      if _leadingComments != other._leadingComments {return false}
      if _trailingComments != other._trailingComments {return false}
      if leadingDetachedComments != other.leadingDetachedComments {return false}
      if unknown != other.unknown {return false}
      return true
    }
  }

  ///   A Location identifies a piece of source code in a .proto file which
  ///   corresponds to a particular definition.  This information is intended
  ///   to be useful to IDEs, code indexers, documentation generators, and similar
  ///   tools.
  ///  
  ///   For example, say we have a file like:
  ///     message Foo {
  ///       optional string foo = 1;
  ///     }
  ///   Let's look at just the field definition:
  ///     optional string foo = 1;
  ///     ^       ^^     ^^  ^  ^^^
  ///     a       bc     de  f  ghi
  ///   We have the following locations:
  ///     span   path               represents
  ///     [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
  ///     [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
  ///     [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
  ///     [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
  ///     [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
  ///  
  ///   Notes:
  ///   - A location may refer to a repeated field itself (i.e. not to any
  ///     particular index within it).  This is used whenever a set of elements are
  ///     logically enclosed in a single code segment.  For example, an entire
  ///     extend block (possibly containing multiple extension definitions) will
  ///     have an outer location whose path refers to the "extensions" repeated
  ///     field without an index.
  ///   - Multiple locations may have the same path.  This happens when a single
  ///     logical declaration is spread out across multiple places.  The most
  ///     obvious example is the "extend" block again -- there may be multiple
  ///     extend blocks in the same scope, each of which will have the same path.
  ///   - A location's span is not always a subset of its parent's span.  For
  ///     example, the "extendee" of an extension declaration appears at the
  ///     beginning of the "extend" block and is shared by all extensions within
  ///     the block.
  ///   - Just because a location's span is a subset of some other location's span
  ///     does not mean that it is a descendent.  For example, a "group" defines
  ///     both a type and a field in a single declaration.  Thus, the locations
  ///     corresponding to the type and field and their components will overlap.
  ///   - Code which tries to interpret locations should probably be designed to
  ///     ignore those that it doesn't understand, as more types of locations could
  ///     be recorded in the future.
  var location: [Google_Protobuf_SourceCodeInfo.Location] = []

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    switch protoFieldNumber {
    case 1: try setter.decodeRepeatedMessageField(fieldType: Google_Protobuf_SourceCodeInfo.Location.self, value: &location)
    default: break
    }
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    if !location.isEmpty {
      try visitor.visitRepeatedMessageField(value: location, fieldNumber: 1)
    }
    unknown.traverse(visitor: visitor)
  }

  public func _protoc_generated_isEqualTo(other: Google_Protobuf_SourceCodeInfo) -> Bool {
    if location != other.location {return false}
    if unknown != other.unknown {return false}
    return true
  }
}

///   Describes the relationship between generated code and its original source
///   file. A GeneratedCodeInfo message is associated with only one generated
///   source file, but may contain references to different source .proto files.
struct Google_Protobuf_GeneratedCodeInfo: SwiftProtobuf.Message, SwiftProtobuf.Proto2Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Google_Protobuf_GeneratedCodeInfo"}
  public var protoMessageName: String {return "GeneratedCodeInfo"}
  public var protoPackageName: String {return "google.protobuf"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "annotation", swift: "annotation"),
  ]

  public var unknown = SwiftProtobuf.UnknownStorage()

  struct Annotation: SwiftProtobuf.Message, SwiftProtobuf.Proto2Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
    public var swiftClassName: String {return "Google_Protobuf_GeneratedCodeInfo.Annotation"}
    public var protoMessageName: String {return "Annotation"}
    public var protoPackageName: String {return "google.protobuf"}
    public static let _protobuf_fieldNames: FieldNameMap = [
      1: .same(proto: "path", swift: "path"),
      2: .unique(proto: "source_file", json: "sourceFile", swift: "sourceFile"),
      3: .same(proto: "begin", swift: "begin"),
      4: .same(proto: "end", swift: "end"),
    ]

    public var unknown = SwiftProtobuf.UnknownStorage()

    ///   Identifies the element in the original source .proto file. This field
    ///   is formatted the same as SourceCodeInfo.Location.path.
    var path: [Int32] = []

    ///   Identifies the filesystem path to the original source .proto.
    private var _sourceFile: String? = nil
    var sourceFile: String {
      get {return _sourceFile ?? ""}
      set {_sourceFile = newValue}
    }
    public var hasSourceFile: Bool {
      return _sourceFile != nil
    }
    public mutating func clearSourceFile() {
      return _sourceFile = nil
    }

    ///   Identifies the starting offset in bytes in the generated code
    ///   that relates to the identified object.
    private var _begin: Int32? = nil
    var begin: Int32 {
      get {return _begin ?? 0}
      set {_begin = newValue}
    }
    public var hasBegin: Bool {
      return _begin != nil
    }
    public mutating func clearBegin() {
      return _begin = nil
    }

    ///   Identifies the ending offset in bytes in the generated code that
    ///   relates to the identified offset. The end offset should be one past
    ///   the last relevant byte (so the length of the text = end - begin).
    private var _end: Int32? = nil
    var end: Int32 {
      get {return _end ?? 0}
      set {_end = newValue}
    }
    public var hasEnd: Bool {
      return _end != nil
    }
    public mutating func clearEnd() {
      return _end = nil
    }

    init() {}

    public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
      switch protoFieldNumber {
      case 1: try setter.decodeRepeatedField(fieldType: SwiftProtobuf.ProtobufInt32.self, value: &path)
      case 2: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: &_sourceFile)
      case 3: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufInt32.self, value: &_begin)
      case 4: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufInt32.self, value: &_end)
      default: break
      }
    }

    public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
      if !path.isEmpty {
        try visitor.visitPackedField(fieldType: SwiftProtobuf.ProtobufInt32.self, value: path, fieldNumber: 1)
      }
      if let v = _sourceFile {
        try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: v, fieldNumber: 2)
      }
      if let v = _begin {
        try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufInt32.self, value: v, fieldNumber: 3)
      }
      if let v = _end {
        try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufInt32.self, value: v, fieldNumber: 4)
      }
      unknown.traverse(visitor: visitor)
    }

    public func _protoc_generated_isEqualTo(other: Google_Protobuf_GeneratedCodeInfo.Annotation) -> Bool {
      if path != other.path {return false}
      if _sourceFile != other._sourceFile {return false}
      if _begin != other._begin {return false}
      if _end != other._end {return false}
      if unknown != other.unknown {return false}
      return true
    }
  }

  ///   An Annotation connects some span of text in generated code to an element
  ///   of its generating .proto file.
  var annotation: [Google_Protobuf_GeneratedCodeInfo.Annotation] = []

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    switch protoFieldNumber {
    case 1: try setter.decodeRepeatedMessageField(fieldType: Google_Protobuf_GeneratedCodeInfo.Annotation.self, value: &annotation)
    default: break
    }
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    if !annotation.isEmpty {
      try visitor.visitRepeatedMessageField(value: annotation, fieldNumber: 1)
    }
    unknown.traverse(visitor: visitor)
  }

  public func _protoc_generated_isEqualTo(other: Google_Protobuf_GeneratedCodeInfo) -> Bool {
    if annotation != other.annotation {return false}
    if unknown != other.unknown {return false}
    return true
  }
}
